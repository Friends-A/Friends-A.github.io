{"meta":{"title":"执念","subtitle":"风沙销寒骨，执念盼青州","description":null,"author":"执念","url":"https://blog.wzy1999.wang"},"pages":[{"title":"404","date":"2019-02-12T13:42:21.000Z","updated":"2019-02-12T13:42:21.418Z","comments":true,"path":"404/index.html","permalink":"https://blog.wzy1999.wang/404/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2019-02-05T12:52:06.331Z","updated":"2019-02-05T12:52:06.331Z","comments":false,"path":"/404.html","permalink":"https://blog.wzy1999.wang//404.html","excerpt":"","text":"404 L2Dwidget.init({\"pluginModelPath\":\"assets/\",\"model\":{\"jsonPath\":\"/live2dw/assets/koharu.model.json\"},\"display\":{\"position\":\"right\",\"width\":150,\"height\":300},\"mobile\":{\"show\":false},\"log\":false,\"pluginJsPath\":\"lib/\",\"pluginRootPath\":\"live2dw/\",\"tagMode\":false});"},{"title":"分类","date":"2019-01-21T11:37:59.000Z","updated":"2019-01-21T11:39:11.988Z","comments":false,"path":"categories/index.html","permalink":"https://blog.wzy1999.wang/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-02-05T13:05:37.000Z","updated":"2019-02-05T13:11:03.590Z","comments":true,"path":"about/index.html","permalink":"https://blog.wzy1999.wang/about/index.html","excerpt":"","text":"​ 蒟蒻、废柴、败犬 ​ 梦想改变世界"},{"title":"categories","date":"2019-02-13T03:03:47.166Z","updated":"2019-02-12T06:36:13.291Z","comments":true,"path":"categories2/index.html","permalink":"https://blog.wzy1999.wang/categories2/index.html","excerpt":"","text":""},{"title":"实用链接","date":"2019-01-22T14:23:02.000Z","updated":"2019-01-22T14:51:06.313Z","comments":false,"path":"links/index.html","permalink":"https://blog.wzy1999.wang/links/index.html","excerpt":"","text":"数据结构 数据结构算法可视化 VisuAlgo 在线工具 手写识别工具 代码粘贴 在线LaTeX公式编辑 ico图标在线制作 OEIS 洛谷图床 洛谷在线IDE Chrome插件下载~无需翻墙~ 在线Markdown编辑器 软件下载 天若OCR 提取码：fmek JPEGView 提取码：y2n9 Mathpix"},{"title":"search","date":"2019-02-12T13:44:09.000Z","updated":"2019-02-12T13:44:09.797Z","comments":true,"path":"search/index.html","permalink":"https://blog.wzy1999.wang/search/index.html","excerpt":"","text":""},{"title":"标签","date":"2016-11-27T10:00:00.000Z","updated":"2018-09-09T02:19:13.000Z","comments":false,"path":"tags/index.html","permalink":"https://blog.wzy1999.wang/tags/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-02-12T13:45:10.597Z","updated":"2019-02-12T06:36:13.291Z","comments":true,"path":"tags2/index.html","permalink":"https://blog.wzy1999.wang/tags2/index.html","excerpt":"","text":""}],"posts":[{"title":"模式匹配与正则表达式","slug":"pyl-5","date":"2019-02-11T08:52:25.000Z","updated":"2019-02-11T13:30:49.188Z","comments":true,"path":"learn/pyl-5/","link":"","permalink":"https://blog.wzy1999.wang/learn/pyl-5/","excerpt":"Python中所有的正则表达式的函数都在re模块中 向re.compile()中传入一个字符串（原始字符串），表示正则表达式，将返回一个Regex模式对象","text":"Python中所有的正则表达式的函数都在re模块中 向re.compile()中传入一个字符串（原始字符串），表示正则表达式，将返回一个Regex模式对象 使用search()方法查找传入的字符串，如果没有匹配到，返回None，匹配到的字符串将会被放在search()返回的Match对象的group()方法中 12345&gt;&gt;&gt; import re&gt;&gt;&gt; num=re.compile(r'\\d\\d\\d\\d-\\d\\d-\\d\\d')&gt;&gt;&gt; birthday=num.search('birthday is 1926-28-17')&gt;&gt;&gt; print(\"He's birthday is \"+birthday.group())He's birthday is 1926-28-17 如果想要从生日中提取年、月、日等信息的话，可以添加括号在正则表达式中创建分组。向group()中传入0或不传参数，返回匹配到的整个字符串；传入其余正整数$N$返回匹配到的第$N$部分 12345678910111213&gt;&gt;&gt; import re&gt;&gt;&gt; num=re.compile(r'(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)')&gt;&gt;&gt; birthday=num.search('birthday is 1926-28-17')&gt;&gt;&gt; birthday.group()'1926-28-17'&gt;&gt;&gt; birthday.group(0)'1926-28-17'&gt;&gt;&gt; birthday.group(1)'1926'&gt;&gt;&gt; birthday.group(2)'28'&gt;&gt;&gt; birthday.group(3)'17' 如果想要一次性获得所有分组，使用groups()方法，返回值是元组类型 123456&gt;&gt;&gt; type(birthday.group())&lt;class 'str'&gt;&gt;&gt;&gt; type(birthday.groups())&lt;class 'tuple'&gt;&gt;&gt;&gt; birthday.groups()('1926', '28', '17') 如果待匹配的表达式有多个时，在表达式之间使用|（管道）可以达到目的。此时search返回的是第一次匹配到的字符串；如果想要获得所有的匹配，可以使用findall()来代替search()，但是findall()返回的是列表 123456789&gt;&gt;&gt; st=re.compile(r'orange|tangerine')&gt;&gt;&gt; like=st.search('I like eat orange or tangerine.')&gt;&gt;&gt; like.group()'orange'&gt;&gt;&gt; like=st.findall('I like eat orange or tangerine.')&gt;&gt;&gt; type(like)&lt;class 'list'&gt;&gt;&gt;&gt; like['orange', 'tangerine'] 利用(str)?可以实现可选匹配，在匹配的时候，str可以出现零次或一次 1234567&gt;&gt;&gt; num=re.compile(r'b(a)?b')&gt;&gt;&gt; n=num.search('bab')&gt;&gt;&gt; n1=num.search('bb')&gt;&gt;&gt; n.group()'bab'&gt;&gt;&gt; n1.group()'bb' (str)*str部分可以出现零次或多次；(str)+ str部分可以出现一次或多次 12345678910111213141516// 星号匹配&gt;&gt;&gt; num=re.compile(r'b(a)*b')&gt;&gt;&gt; n=num.search('baaaaaaaaab')&gt;&gt;&gt; n1=num.search('bb')&gt;&gt;&gt; n.group()'baaaaaaaaab'&gt;&gt;&gt; n1.group()'bb'// 加号匹配&gt;&gt;&gt; num=re.compile(r'b(a)+b')&gt;&gt;&gt; n=num.search('baaaaaaaaab')&gt;&gt;&gt; n1=num.search('bab')&gt;&gt;&gt; n.group()'baaaaaaaaab'&gt;&gt;&gt; n1.group()'bab' 利用花括号可以实现匹配特定的次数：(str){3,}将str匹配3次或更多次。(str){,5}将str匹配0-5次 1234567&gt;&gt;&gt; num=re.compile(r'(a)&#123;3&#125;')&gt;&gt;&gt; n=num.search('aaa')&gt;&gt;&gt; n1=num.search('aa')&gt;&gt;&gt; n.group()'aaa'&gt;&gt;&gt; n1==NoneTrue 正则表达式默认是“贪心”的，会尽可能匹配最长的字符串。在花括号后添加?可以改为非贪心匹配（匹配最短的） 12345678&gt;&gt;&gt; num=re.compile(r'(a)&#123;3,5&#125;')&gt;&gt;&gt; n1=num.search('aaaaa')&gt;&gt;&gt; n1.group()'aaaaa'&gt;&gt;&gt; num=re.compile(r'(a)&#123;3,5&#125;?')&gt;&gt;&gt; n1=num.search('aaaaa')&gt;&gt;&gt; n1.group()'aaa' 缩写字符分类 表示 \\d 0到9的任何数字 \\D 除0到9的数字以外的任何字符 \\w 任何字母、数字或下划线字符（可以认为是匹配“单词”字符） \\W 除了字母、数字和下划线以外的任何字符 \\s 空格、制表符或换行符（可以认为是匹配“空白”字符） \\S 除空格、制表符和换行符以外的任何字符 可以使用[]来创建自己的字符分类。例如：[0-9]匹配所有的数字，[a-z]匹配所有的小写字母；在字符前加上^表示匹配不在创建字符分类中的所有字符。对于正则表达式符号，不需要进行转义 12345678&gt;&gt;&gt; a=re.compile(r'[0-9]')&gt;&gt;&gt; a1=re.compile(r'[^0-9]')&gt;&gt;&gt; b=a.findall('abc123de')&gt;&gt;&gt; b1=a1.findall('abc123de')&gt;&gt;&gt; b['1', '2', '3']&gt;&gt;&gt; b1['a', 'b', 'c', 'd', 'e'] 在正则表达式开始出插入^，表示匹配必须在被查找文本的开始出；在末尾插入$，表示必须以这个正则表达式的模式结束；同时使用二者，表示整个字符串必须匹配该模式r&#39;^\\d+$匹配全是数字的字符串 .可以匹配除了换行以外的所有字符，被称为“通配符” 1234&gt;&gt;&gt; a=re.compile(r'.234')&gt;&gt;&gt; b=a.findall('1234 2234 3234')&gt;&gt;&gt; b['1234', '2234', '3234'] 用.*进行组合，可以匹配任意字符，任意长度的文本，默认是贪心的；.*?这种匹配是非贪心的 12345678&gt;&gt;&gt; num=re.compile(r'&lt;.*&gt;')&gt;&gt;&gt; a=num.search('&lt;1+2+3&gt;*&lt;4+5+6&gt;+10')&gt;&gt;&gt; a.group()'&lt;1+2+3&gt;*&lt;4+5+6&gt;'&gt;&gt;&gt; num=re.compile(r'&lt;.*?&gt;')&gt;&gt;&gt; a=num.search('&lt;1+2+3&gt;*&lt;4+5+6&gt;+10')&gt;&gt;&gt; a.group()'&lt;1+2+3&gt;'","categories":[{"name":"learn","slug":"learn","permalink":"https://blog.wzy1999.wang/categories/learn/"}],"tags":[{"name":"py_learn","slug":"py-learn","permalink":"https://blog.wzy1999.wang/tags/py-learn/"}]},{"title":"codevs1300：文件排版（DP）","slug":"codevs1300","date":"2019-02-10T12:15:31.000Z","updated":"2019-02-10T12:16:25.343Z","comments":true,"path":"solve/codevs1300/","link":"","permalink":"https://blog.wzy1999.wang/solve/codevs1300/","excerpt":"题目描述写电子邮件是有趣的，但不幸的是经常写不好看，主要是因为所有的行不一样长，你的上司想要发排版精美的电子邮件，你的任务是为他编写一个电子邮件排版程序。","text":"题目描述写电子邮件是有趣的，但不幸的是经常写不好看，主要是因为所有的行不一样长，你的上司想要发排版精美的电子邮件，你的任务是为他编写一个电子邮件排版程序。 完成这个任务最简单的办法是在太短的行中的单词之间插入空格，但这并不是最好的方法，考虑如下例子： This is the example you are actually considering. 假设我们想将第二行变得和第一行一样长，靠简单地插入空格则我们将得到如下结果： This is the example you are actually considering. 但这太难看了，因为在第二行中有一个非常大的空白，如果将第一行的单词“are”移到下一行我们将得到较好的结果： This is the example you are actually considering. 当然，这必须对难看程度进行量化。因此我们必须给出单词之间的空格的难看程度，一个包含$N$个空格符的空白段，其难看程度值为$(n-1)^2$，程序的目的是使难看程度的总和最小化。例如，第一个例子的难看程度是$1+7\\times7=50$，而第二个例子的难看程度仅为$1+1+1+4+1+4=12$。 输出时，每一行的开头和结尾处都必须是一个单词，即每行开头和结尾处不能有空白。唯一例外的是该行仅有一个单词组成的情况，对于这种情况你可将单词放在该行开头处输出，此时如果该单词比该行应有的长度短则我们指定它的最坏程度为$500$，当然在这种情况下，该行的实际长度即为该单词的长度。 输入描述输入文件第一行是一个整数N，表示该段要求达到的宽度，$1\\leq N\\leq 80$。该段文章由一个或多个单词组成，单词由ASCII码值为$33$到$126$（包含$33$和$126$）的字符组成，单词与单词之间用空格隔开（可能超过一个）。单词长度不会超过段落要求达到的宽度。一段文字所有单词的总长度不会超过$10000$个字符，任何一行都不会超过$100$个字符，任何一个单词都在同一行内。 输出描述对于每个段落，找出使其难看程度最小的排版形式并输出句子：“Minimal badness is B.”,B是指按可能的最好排版形式会发生的难看程度值。注意排版后文本行数任意，多余的空格也可删除。 样例输入123428This is the example you areactually considering. 样例输出1Minimal badness is 12. Solve二维的DP：状态$dp[i][j]$表示第$i$个单词末尾放在$j$位置的最小难看程度 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;#define ll long long#define ull unsigned long long#define ms(a,b) memset(a,b,sizeof(a))#define INF 0x7f7f7f7fconst int maxn=1e3+10;const int mod=1e9+7;using namespace std;char ch[maxn];// dp[i][j]表示第i个单词末尾放到位置j的最小难看程度int dp[maxn][maxn];int len[maxn];int main(int argc, char const *argv[])&#123; ios::sync_with_stdio(false); cin.tie(0); int n; cin&gt;&gt;n; int cnt=0; while(cin&gt;&gt;ch) len[++cnt]=strlen(ch); ms(dp,INF); dp[1][n]=500; dp[1][len[1]]=0; for(int i=2;i&lt;=cnt;i++) for(int j=len[i];j&lt;=n;j++) &#123; int res=j-len[i]; // 如果是某行的第一个单词，继承上一行的最后一个状态 if(!res) dp[i][j]=dp[i-1][n]; else &#123; if(j==n) dp[i][j]=dp[i-1][j]+500; for(int k=0;k&lt;res;k++) dp[i][j]=min(dp[i][j],dp[i-1][k]+(res-k-1)*(res-k-1)); &#125; &#125; cout&lt;&lt;\"Minimal badness is \"&lt;&lt;dp[cnt][n]&lt;&lt;\".\"&lt;&lt;endl; return 0;&#125; 一维的DP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define ll long long#define ull unsigned long long#define ms(a,b) memset(a,b,sizeof(a))#define INF 0x7f7f7f7fconst int maxn=1e6+10;const int mod=1e9+7;using namespace std;char ch[maxn];// dp[i]表示以第i个单词作为一行的结尾的最小难看程度// dp[i]=min(dp[i]+cost(j,i))// cost(j,i)表示j+1到i在同一行的最小难看程度// 当空格在一行内平分的时候难看程度最小int dp[maxn];int len[maxn];inline int calc(int l,int r,int n)&#123; if(l==r) &#123; if(len[r]-len[l-1]==n) return 0; return 500; &#125; // 一行内的空格数 int res=n-(len[r]-len[l-1]); // 一行内至少要有r-l个空格】 if(res&lt;r-l) return INF; // 将空格平分 int space=res/(r-l); // 多余的空格往之前的空格段中平分,每段至多一个 int more=res%(r-l); space-=1; return space*space*(r-l)+more*(space*2+1);&#125;int main(int argc, char const *argv[])&#123; ios::sync_with_stdio(false); cin.tie(0); int n; int cnt=0; cin&gt;&gt;n; while(cin&gt;&gt;ch) len[++cnt]=len[cnt-1]+strlen(ch); ms(dp,INF); dp[0]=0; for(int i=1;i&lt;=cnt;i++) for(int j=1;j&lt;=i;j++) dp[i]=min(dp[i],dp[j-1]+calc(j,i,n)); cout&lt;&lt;\"Minimal badness is \"&lt;&lt;dp[cnt]&lt;&lt;\".\"&lt;&lt;endl; return 0;&#125;","categories":[{"name":"solve","slug":"solve","permalink":"https://blog.wzy1999.wang/categories/solve/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://blog.wzy1999.wang/tags/DP/"}]},{"title":"《机器学习实战》kNN算法及约会网站代码详解","slug":"ml-2","date":"2019-02-10T07:25:52.000Z","updated":"2019-02-10T07:27:25.775Z","comments":true,"path":"learn/ml-2/","link":"","permalink":"https://blog.wzy1999.wang/learn/ml-2/","excerpt":"使用kNN算法进行分类的原理是：从训练集中选出离待分类点最近的$k$个点，在这$k$个点中所占比重最大的分类即为该点所在的分类。通常$k$不超过$20$","text":"使用kNN算法进行分类的原理是：从训练集中选出离待分类点最近的$k$个点，在这$k$个点中所占比重最大的分类即为该点所在的分类。通常$k$不超过$20$ kNN算法步骤： 计算数据集中的点与待分类点之间的距离 按照距离升序排序 选出距离最小的$k$个点 计算这$k$个点所在类别出现的频率（次数） 返回出现频率最高的点的类别 代码的实现：首先导入numpy模块和operator模块，建立一个数据集 12345678from numpy import *import operatordef createDataSet(): group = array([[1.0, 1.1], [1.0, 1.0], [0, 0], [0, 0.1]]) labels = ['A', 'A', 'B', 'B'] return group, labels kNN算法的核心代码 123456789101112131415161718192021222324252627# inX-用于分类的输入向量；dataSet-训练样本集；labels-标签向量；k-选择最近邻居的个数# 实现kNN算法def classify0(inX, dataSet, labels, k): # shape返回各个维度的维数，shape[0]表示最外围的数组的维数，shape[1]表示次外围的数组的维数，数字不断增大，维数由外到内。 # 例如：二维数组中，shape[0]表示行数，shape[1]表示列数 dataSetSize = dataSet.shape[0] # tile([n1,n2](a,b))表示在行的方向上重复[n1,n2]a次，在列的方向上重复b次 # 两个矩阵大小相同的矩阵相减 diffMat = tile(inX, (dataSetSize, 1)) - dataSet # 对应位置的元素直接相乘 # 如果需要矩阵乘法，使用dot(a,b) sqDiffMat = diffMat ** 2 # sum(axis=1)表示按行（第二维度）相加，axis=0表示按列（第一维度）相加 # 此处得到inX到dataSet各点的距离的平方 sqDistances = sqDiffMat.sum(axis=1) distances = sqDistances ** 0.5 # 升序排序后返回其下标 sortedDistIndicies = distances.argsort() classCound = &#123;&#125; for i in range(k): # 当前点的标签 voteIlabel = labels[sortedDistIndicies[i]] # 将点的标签数+1 classCound[voteIlabel] = classCound.get(voteIlabel, 0) + 1 # 将字典分解成元组列表，并按照第二个元素进行降序排序 sortedClassCount = sorted(classCound.items(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0] 使用K-近邻算法改进约会网站的配对效果数据集的处理首先我们需要处理数据集，将其转换成训练样本矩阵和类标签向量 约会网站的数据集对应的文件名是datingTestSet2.txt，每列对应的标签分别是：每年获得的飞行常客里程数；玩视频游戏所耗时间百分比；每周消费的冰淇淋公升数；属于哪一类型的人 12345678910111213141516171819# 将文本记录转换成Numpy的解析程序def file2matrix(filename): fr = open(filename) arrar0Lines = fr.readlines() # 获得文件行数 number0fLines = len(arrar0Lines) # 创建一个number0fLines行3列的全是0的矩阵 retrunMat = zeros((number0fLines, 3)) classLabelVector = [] index = 0 for line in arrar0Lines: line = line.strip() listFromLine = line.split('\\t') # 选取每行的前三个元素放入returnMat中 retrunMat[index, :] = listFromLine[0:3] # 将所属类别放入classLabelVector classLabelVector.append(int(listFromLine[-1])) index += 1 return retrunMat, classLabelVector 使用Matplotlib创建散点图在命令行环境中，输入： 1234567891011121314import kNNfrom numpy import *import matplotlibimport matplotlib.pyplot as pltdatingDataMat,datingLabels=kNN.file2matrix('datingTestSet2.txt')# 创建一个画布fig=plt.figure()# 111的含义是将画布分割成1行1列，画像在从左到右，从上到下第一块ax=fig.add_subplot(111)# 以第二列和第三列为x,y轴画出散列点，给予不同的颜色和大小# scatter（x,y,s=1,c=\"g\",marker=\"s\",linewidths=0）# s:散列点的大小,c:散列点的颜色，marker：形状，linewidths：边框宽度ax.scatter(datingDataMat[:,1],datingDataMat[:,2],15.0*array(datingLabels),15.0*array(datingLabels))plt.show() 此时，可以得到数据集的散点图：（横坐标是玩视频游戏所耗时间百分比，纵坐标是每周消费的冰淇淋公升数） 归一化数据 可以看出，在计算点的距离时，里程数对于距离的影响特别大，为了减小这个影响，需要将所有的数据范围处理到$0$到$1$或$-1$到$1$之间，利用下面的公式，可以实现将特征值转化为$[0,1]$区间内的值： newValue=(oldValue-min)/(max-min)代码如下： 1234567891011121314# 归一化特征值def autoNorm(dataSet) # 按列查找最大值和最小值 minVals = dataSet.min(0) maxVals = dataSet.max(0) ranges = maxVals - minVals # 创建一个和dataSet大小相同的全是0的数组 normDataSet = zeros(shape(dataSet)) m = dataSet.shape[0] # 获得值为oldValue-min的数组 normDataSet = dataSet - tile(minVals, (m, 1)) # 归一化的数组 normDataSet = normDataSet / tile(ranges, (m, 1)) return normDataSet, ranges, minVals 分类器针对约会网站的测试代码使用数据集中的$10\\%$的数据作为测试数据，剩余的$90\\%$作为数据集 12345678910111213141516# 对于数据的测试# 选出10%作为测试数据，剩余90%作为数据集def datingClassTest(): hoRatio = 0.10 datingDataMat, datingLabels = file2matrix('datingTestSet2.txt') normMat, ranges, minVals = autoNorm(datingDataMat) m = normMat.shape[0] # 获得测试数据的组数 numTestVecs = int(m * hoRatio) errorCount = 0.0 for i in range(numTestVecs): classifierResult = classify0(normMat[i, :], normMat[numTestVecs:m, :], datingLabels[numTestVecs:m], 3) print(\"the classifier came back with: %d, the real answer is: %d\" % (classifierResult, datingLabels[i])) if (classifierResult != datingLabels[i]): errorCount += 1.0 print(\"the total error rate is: %f\" % (errorCount / float(numTestVecs))) 约会网站预测函数12345678910def classifyPerson(): resultList = ['not at all', 'in small doses', 'in large doses'] percentTats = float(input(\"percentage of time spent palying video games?\")) ffMiles = float(input(\"fregunt flier miles earned per year?\")) iceCream = float(input(\"liters of ice cream consumed per year?\")) datingDataMat, datingLabels = file2matrix('datingTestSet2.txt') normMat, ranges, minVals = autoNorm(datingDataMat) inArr = array([ffMiles, percentTats, iceCream]) classifierResult = classify0((inArr - minVals) / ranges, normMat, datingLabels, 3) print(\"You will probably like this person: \", resultList[classifierResult - 1])","categories":[{"name":"learn","slug":"learn","permalink":"https://blog.wzy1999.wang/categories/learn/"}],"tags":[{"name":"ml_learn","slug":"ml-learn","permalink":"https://blog.wzy1999.wang/tags/ml-learn/"}]},{"title":"牛客练习赛39 B：选点（二叉树遍历+LIS）","slug":"niuke368B","date":"2019-02-08T14:04:55.000Z","updated":"2019-02-08T14:06:38.771Z","comments":true,"path":"solve/niuke368B/","link":"","permalink":"https://blog.wzy1999.wang/solve/niuke368B/","excerpt":"二叉树的后续遍历+LIS","text":"链接： https://ac.nowcoder.com/acm/contest/368/B 来源：牛客网 时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 131072K，其他语言262144K 64bit IO Format: %lld 题目描述 有一棵n个节点的二叉树，1为根节点，每个节点有一个值$w_i$。现在要选出尽量多的点。 对于任意一棵子树，都要满足： 如果选了根节点的话，在这棵子树内选的其他的点都要比根节点的值大； 如果在左子树选了一个点，在右子树中选的其他点要比它小。 输入描述:第一行一个整数n。第二行n个整数$w_i$，表示每个点的权值。接下来$n$行，每行两个整数$a,b$。第$i+2$行表示第$i$个节点的左右儿子节点。没有为$0$。$n,a,b≤10^5,−2×10^9≤w_i≤2×10^9$ 输出描述:一行一个整数表示答案。 输入123456751 5 4 2 33 24 50 00 00 0 输出13 Solve题目要求选出来的点满足：左儿子权值&gt;右儿子权值&gt;父亲权值。对二叉树进行后续遍历，可以得到左儿子-&gt;右儿子-&gt;父亲的排列，然后对遍历得到的结果反向求LIS即可 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;#define ll long long#define ull unsigned long long#define ms(a,b) memset(a,b,sizeof(a))#define INF 0x7f7f7f7fconst int maxn=1e5+10;const int mod=1e9+7;using namespace std;int w[maxn];int arr[maxn];int ar[maxn];int dp[maxn];struct wzy&#123; int l,r;&#125;p[maxn];int cnt;void get_arr(int x)&#123; if(p[x].l) get_arr(p[x].l); if(p[x].r) get_arr(p[x].r); arr[cnt++]=w[x];&#125;int main(int argc, char const *argv[])&#123; ios::sync_with_stdio(false); cin.tie(0); ms(p,0); int n,a,b; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;w[i]; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a&gt;&gt;b; p[i].l=a; p[i].r=b; &#125; get_arr(1); for(int i=0;i&lt;cnt;i++) ar[cnt-i-1]=arr[i]; int len=0; for(int i=0;i&lt;n;i++) &#123; int pos=upper_bound(dp,dp+len,ar[i])-dp; dp[pos]=ar[i]; len=max(len,pos+1); &#125; cout&lt;&lt;len&lt;&lt;endl; return 0;&#125;","categories":[{"name":"solve","slug":"solve","permalink":"https://blog.wzy1999.wang/categories/solve/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://blog.wzy1999.wang/tags/DP/"}]},{"title":"luogu1439——【模板】最长公共子序列（DP，LIS？）","slug":"luogu1439","date":"2019-02-08T08:49:11.000Z","updated":"2019-02-08T08:50:03.569Z","comments":true,"path":"solve/luogu1439/","link":"","permalink":"https://blog.wzy1999.wang/solve/luogu1439/","excerpt":"题目描述给出1-n的两个排列P1和P2，求它们的最长公共子序列。","text":"题目描述给出1-n的两个排列P1和P2，求它们的最长公共子序列。 输入输出格式输入格式： 第一行是一个数n， 接下来两行，每行为n个数，为自然数1-n的一个排列。 输出格式： 一个数，即最长公共子序列的长度 输入输出样例输入样例#1： 1235 3 2 1 4 51 2 3 4 5 输出样例#1： 13 说明【数据规模】 对于50%的数据，n≤1000 对于100%的数据，n≤100000 Solve首先，来看一下$N^2$的算法： dp[i][j]=\\left\\{ \\begin{array}{rcl} max(dp[i][j],dp[i-1][j-1]+1) & & {a[i]==b[j]}\\\\ max(dp[i][j-1],dp[i-1][j]) & & {a[i]!=b[j]} \\end{array} \\right.$dp[i][j]$代表$a$数组的前$i$位与$b$数组的前$j$位的最长公共子序列的长度 $dp[0][0]=(a[0]==b[0])$ 用这个方法来写，对于$10^5$的数据来说，时间和空间都是不够用的 题中已经说明了：两个数组均是1-n的排列，即：两个数组的元素是相同的，只是元素所在的位置不同。那么，两个数组的公共子序列中的元素在两个数组中的相对位置是一样的 如果按照下标给第一个数组的元素赋予新的值（按照升序）， 例如：$a=\\{3,1,2,4,5\\};b=\\{1,3,2,4,5\\}$ old 3 1 2 4 5 new 0 1 2 3 4 对$a$进行处理后的数组为$\\{0,1,2,3,4\\}$ 用在$a$中创建的映射关系，将$b$中的元素替换： old 1 3 2 4 5 new 1 0 2 3 4 得到的新的$b$数组为：$\\{1,0,2,3,4\\}$ 我们可以发现：新的$b$数组的最长上升子序列即为原两个数组的最长公共子序列 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445/************************************************************************* &gt; Author: WZY &gt; School: HPU &gt; Created Time: 2019-02-08 15:20:18 ************************************************************************/#include &lt;bits/stdc++.h&gt;#define ll long long#define ull unsigned long long#define ms(a,b) memset(a,b,sizeof(a))#define INF 0x7f7f7f7fconst int maxn=1e6+10;const int mod=1e9+7;using namespace std;int a[maxn];int b[maxn],b1[maxn];int vis[maxn];int dp[maxn];int main(int argc, char const *argv[])&#123; ios::sync_with_stdio(false); cin.tie(0); int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; vis[a[i]]=i; &#125; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;b[i]; b1[i]=vis[b[i]]; &#125; int ans=0; for(int i=0;i&lt;n;i++) &#123; int pos=lower_bound(dp,dp+ans,b1[i])-dp; dp[pos]=b1[i]; ans=max(ans,pos+1); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;","categories":[{"name":"solve","slug":"solve","permalink":"https://blog.wzy1999.wang/categories/solve/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://blog.wzy1999.wang/tags/DP/"}]},{"title":"hdu1024——Max Sum Plus Plus（DP）","slug":"hdu1024","date":"2019-02-07T13:43:38.000Z","updated":"2019-02-07T13:45:35.343Z","comments":true,"path":"solve/hdu1024/","link":"","permalink":"https://blog.wzy1999.wang/solve/hdu1024/","excerpt":"将一个长度为$n$的数组分成不相交的$m$段，求这$m$段的和的最大值","text":"Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 39886 Accepted Submission(s): 14338 Problem DescriptionNow I think you have got an AC in Ignatius.L’s “Max Sum” problem. To be a brave ACMer, we always challenge ourselves to more difficult problems. Now you are faced with a more difficult problem. Given a consecutive number sequence $S_1, S_2, S_3, S_4 … S_x, … S_n (1 ≤ x ≤ n ≤ 1,000,000, -32768 ≤ S_x ≤ 32767)$. We define a function $sum(i, j) = S_i + … + S_j (1 ≤ i ≤ j ≤ n)$. Now given an integer $m (m &gt; 0)$, your task is to find m pairs of i and j which make $sum(i_1, j_1) + sum(i_2, j_2) + sum(i_3, j_3) + … + sum(i_m, j_m)$ maximal ($i_x ≤ i_y ≤ j_x$ or $i_x≤ j_y ≤ j_x$ is not allowed). But I`m lazy, I don’t want to write a special-judge module, so you don’t have to output m pairs of $i$ and $j$, just output the maximal summation of $sum(i_x, j_x)(1 ≤ x ≤ m)$ instead. InputEach test case will begin with two integers $m$ and $n$, followed by $n$ integers $S_1, S_2, S_3 … S_n$.Process to the end of file. OutputOutput the maximal summation described above in one line. Sample Input121 3 1 2 32 6 -1 4 -2 3 -2 3 Sample Output1268 题意将一个长度为$n$的数组分成不相交的$m$段，求这$m$段的和的最大值 思路状态：$dp[i][j]$表示在前$j$个数中取出$i$段的最大和 状态转移方程：$dp[i][j]=max(dp[i-1][k],dp[i][j-1])+num[j] (i-1\\leq k \\leq j-1)$ 由于$m$范围未知，$n\\leq 10^6$，所以二维的dp方程无论是在时间上还是在空间上都是不允许的。 那么我们就需要对这个方程进行优化： 不难发现当前状态只与两个状态有关： 第$j$个数和前$j-1$个数在一段里 第$j$个数和前$j-1$个数不在一段里。 根据这一点，我们把状态降成一维的数组，$dp[j]$表示前$j$个数分$i$段时的最大和，然后用$sum[j-1]$来表示状态一的前$j-1$个数在前$i-1$段的最大和，$dp[j-1]$表示状态二的前$j-1$个数在前$i$段的最大和。 当前状态的转移方程为：$dp[j]=max(dp[j-1],sum[j-1])+num[j]$，持续更新dp与sum数组的值 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;limits.h&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;time.h&gt;#define ll long long#define ull unsigned long long#define ms(a,b) memset(a,b,sizeof(a))#define pi acos(-1.0)#define INF 0x7f7f7f7f#define lson o&lt;&lt;1#define rson o&lt;&lt;1|1#define bug cout&lt;&lt;\"-------------\"&lt;&lt;endl#define debug(...) cerr&lt;&lt;\"[\"&lt;&lt;#__VA_ARGS__\":\"&lt;&lt;(__VA_ARGS__)&lt;&lt;\"]\"&lt;&lt;\"\\n\"const double E=exp(1);const int maxn=1e6+10;const int mod=1e9+7;using namespace std;int a[maxn];int dp[maxn];int sum[maxn];int main(int argc, char const *argv[])&#123; ios::sync_with_stdio(false); cin.tie(0); #ifndef ONLINE_JUDGE freopen(\"in.txt\", \"r\", stdin); freopen(\"out.txt\", \"w\", stdout); double _begin_time = clock(); #endif int k,n; while(cin&gt;&gt;k&gt;&gt;n) &#123; int res; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; ms(dp,0); ms(sum,0); for(int i=1;i&lt;=k;i++) &#123; res=-INF; for(int j=i;j&lt;=n;j++) &#123; dp[j]=max(sum[j-1],dp[j-1])+a[j]; sum[j-1]=res; res=max(res,dp[j]); &#125; &#125; cout&lt;&lt;res&lt;&lt;endl; &#125; #ifndef ONLINE_JUDGE long _end_time = clock(); printf(\"time = %lf ms.\", _end_time - _begin_time); #endif return 0;&#125;","categories":[{"name":"solve","slug":"solve","permalink":"https://blog.wzy1999.wang/categories/solve/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://blog.wzy1999.wang/tags/DP/"}]},{"title":"luogu1434——[SHOI2002]滑雪（DP，记忆化搜索）","slug":"luogu1434","date":"2019-02-06T14:00:31.000Z","updated":"2019-02-06T14:02:28.872Z","comments":true,"path":"solve/luogu1434/","link":"","permalink":"https://blog.wzy1999.wang/solve/luogu1434/","excerpt":"题目描述Michael喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：","text":"题目描述Michael喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子： 123451 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9 一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可行的滑坡为$24－17－16－1$（从$24$开始，在$1$结束）。当然$25－24－23－…－3－2－1$更长。事实上，这是最长的一条。 输入输出格式输入格式： 输入的第一行为表示区域的二维数组的行数$R$和列数$C$（$1≤R$，$C≤100$）。下面是$R$行，每行有$C$个数，代表高度(两个数字之间用1个空格间隔)。 输出格式： 输出区域中最长滑坡的长度。 输入输出样例输入样例#1： 1234565 51 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9 输出样例#1： 125 思路可以轻易地推出状态转移方程为： dp[i][j]=max(dp[i-1][j]+1,dp[i][j]\\ \\ (if\\ dp[i][j]>dp[i-1][j]) dp[i][j]=max(dp[i+1][j]+1,dp[i][j]\\ \\ (if\\ dp[i][j]>dp[i+1][j]) dp[i][j]=max(dp[i][j-1]+1,dp[i][j]\\ \\ (if\\ dp[i][j]>dp[i][j-1]) dp[i][j]=max(dp[i][j+1]+1,dp[i][j]\\ \\ (if\\ dp[i][j]>dp[i][j+1])但是$dp[i-1][j],dp[i+1][j],dp[i][j-1],dp[i][j+1]$的值不能通过普通的线性dp来求的，所以需要进行记忆化搜索来遍历所有的状态，并进行记忆化，这样就可以获得上述四个状态的值了，然后进行dp即可 也可以将二维的地图进行降维，然后进行线性dp，具体方法请看dalao博客：https://sparky.blog.luogu.org/solution-p1434 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/************************************************************************* &gt; Author: WZY &gt; School: HPU &gt; Created Time: 2019-02-06 20:45:27 ************************************************************************/#include &lt;bits/stdc++.h&gt;#define ll long long#define ull unsigned long long#define ms(a,b) memset(a,b,sizeof(a))#define INF 0x7f7f7f7fconst int maxn=1e3+10;const int mod=1e9+7;using namespace std;int a[maxn][maxn];int dp[maxn][maxn];int dir[4][2]=&#123;1,0,-1,0,0,1,0,-1&#125;;int n,m;int dfs(int x,int y)&#123; if(dp[x][y]) return dp[x][y]; int _=0; for(int i=0;i&lt;4;i++) &#123; int dx=x+dir[i][0]; int dy=y+dir[i][1]; if(dx&lt;=n&amp;&amp;dx&gt;0&amp;&amp;dy&lt;=m&amp;&amp;dy&gt;0&amp;&amp;a[x][y]&gt;a[dx][dy]) _=max(dfs(dx,dy)+1,_); &#125; dp[x][y]=max(_,dp[x][y]); return dp[x][y];&#125;int main(int argc, char const *argv[])&#123; ios::sync_with_stdio(false); cin.tie(0); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) cin&gt;&gt;a[i][j]; ms(dp,0); int ans=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) ans=max(ans,dfs(i,j)); cout&lt;&lt;ans+1&lt;&lt;endl; return 0;&#125;","categories":[{"name":"solve","slug":"solve","permalink":"https://blog.wzy1999.wang/categories/solve/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://blog.wzy1999.wang/tags/DP/"},{"name":"search","slug":"search","permalink":"https://blog.wzy1999.wang/tags/search/"}]},{"title":"菜鸡的2018年度总结","slug":"One","date":"2019-02-05T09:00:49.000Z","updated":"2019-02-05T12:13:59.579Z","comments":true,"path":"essay/One/","link":"","permalink":"https://blog.wzy1999.wang/essay/One/","excerpt":"公元$2018$年已经正式过去了。 过去的一年，发生了很多事情，也经历了很多，得到了很多。在这里写一下总结流水账，并为$2019$定一些小目标吧~","text":"公元$2018$年已经正式过去了。 过去的一年，发生了很多事情，也经历了很多，得到了很多。在这里写一下总结流水账，并为$2019$定一些小目标吧~ 四月一日，在新乡河南科技学院参加了蓝桥杯省赛，ACM生涯的第一场校级以上的比赛，并拿到了二等奖 五月二十日、二十一日，在西北工业大学和LF、THJ参加了区域赛邀请赛，第一次参加与全国性质的ACM比赛，虽然是邀请赛，虽然打了铁，但是我学到了很多 五月二十六日、二十七日，在信阳师范学院依旧是和LF、THJ一起参加ACM省赛，并在帆神的带领下顺利拿到了铜奖如果不是我演了几发的话可能会银也说不定23333333。然后在接下来的的考试周里成功的三门考试成绩加起来没考到100分 七月十八日，返校进行暑期培训，在学校度过了愉快的一个月，在场场积分赛打的极其差的情况下苟到了所谓的三队，与sdx，gyh组了新的队伍 八月二十六日，在校培训的最后一次比赛，也是新队伍第一次比赛，拿到了第三名的“喜人”成绩，并得到了第一个奖品 奖品是U盘，不是键盘 十月二十六日~二十八日，在徐州中国矿业大学参加亚洲区域赛，并在人品爆棚+赛前20年单身flag的作用下拿到了银牌一题银到铁真鸡儿刺激 不得不说矿大的小姐姐真漂亮 银牌必须要给一个原尺寸大小 十一月二十四、二十五，亚洲区域赛焦作赛区顺利举办，并因为餐券可以买牛奶而获得广大JBer的好评。作为志愿者，学到了很多，也看清了很多 工作牌和河南特色的马甲 赛前、赛中、赛后划水时偷拍后台的气球和奖牌其实还有奖牌，就不放出来了 十二月十五日、十六日，EC-final依旧是西工大，依旧是铁牌。本来还幻想着能够继续运气爆棚一次拿个铜，结果死于计算几何，死因 为菜西安的泡馍真的好吃，虽然很贵；发的衣服和书包也不错，唯一的遗憾是没有拿到牌子 流水账到此结束 2018真的是值得纪念的一年，在这一年中，有成功，也有失败。收获了很多也失去了很多。这一年，我因为ACM膨胀过，迷茫过，伤心过，但是从来没有后悔过 希望在2019年，我能够做的更好，能够变得稍微更强一些 最后，给我的2019年定下一些小目标： 蓝桥杯省赛一等奖+国赛三等奖以上 天梯赛进入一队 省赛银牌及以上 如果省赛后不退役的话，希望区域赛能够拿块铜牌 不挂科，拿奖学金 脱单 拿到驾照（大雾） 就写这么多吧，好久没有写过这么长的东西了，写的太烂了QAQ","categories":[{"name":"essay","slug":"essay","permalink":"https://blog.wzy1999.wang/categories/essay/"}],"tags":[]},{"title":"洛谷1052——过河（DP+状态压缩）","slug":"luogu1052","date":"2019-02-03T10:44:46.000Z","updated":"2019-02-03T12:00:03.810Z","comments":true,"path":"solve/luogu1052/","link":"","permalink":"https://blog.wzy1999.wang/solve/luogu1052/","excerpt":"题目描述在河上有一座独木桥，一只青蛙想沿着独木桥从河的一侧跳到另一侧。在桥上有一些石子，青蛙很讨厌踩在这些石子上。由于桥的长度和青蛙一次跳过的距离都是正整数，我们可以把独木桥上青蛙可能到达的点看成数轴上的一串整点：$0,1,…,L$（其中$L$是桥的长度）。坐标为$0$的点表示桥的起点，坐标为$L$的点表示桥的终点。青蛙从桥的起点开始，不停的向终点方向跳跃。一次跳跃的距离是$S$到$T$之间的任意正整数（包括$S,T$）。当青蛙跳到或跳过坐标为$L$的点时，就算青蛙已经跳出了独木桥。","text":"题目描述在河上有一座独木桥，一只青蛙想沿着独木桥从河的一侧跳到另一侧。在桥上有一些石子，青蛙很讨厌踩在这些石子上。由于桥的长度和青蛙一次跳过的距离都是正整数，我们可以把独木桥上青蛙可能到达的点看成数轴上的一串整点：$0,1,…,L$（其中$L$是桥的长度）。坐标为$0$的点表示桥的起点，坐标为$L$的点表示桥的终点。青蛙从桥的起点开始，不停的向终点方向跳跃。一次跳跃的距离是$S$到$T$之间的任意正整数（包括$S,T$）。当青蛙跳到或跳过坐标为$L$的点时，就算青蛙已经跳出了独木桥。 题目给出独木桥的长度$L$，青蛙跳跃的距离范围$S,T$，桥上石子的位置。你的任务是确定青蛙要想过河，最少需要踩到的石子数。 输入输出格式输入格式： 第一行有$1$个正整数$L(1 \\le L \\le 10^9)$，表示独木桥的长度。 第二行有$3$个正整数$S,T,M$，分别表示青蛙一次跳跃的最小距离，最大距离及桥上石子的个数，其中$1 \\le S \\le T \\le 10$,$1 \\le M \\le 100​$。 第三行有$M$个不同的正整数分别表示这$M$个石子在数轴上的位置（数据保证桥的起点和终点处没有石子）。所有相邻的整数之间用一个空格隔开。 输出格式： 一个整数，表示青蛙过河最少需要踩到的石子数。 输入输出样例输入样例#1： 123102 3 52 3 5 6 7 输出样例#1： 12 说明对于30%的数据，$L \\le 10000$； 对于全部的数据，$L \\le 10^9$。 2005提高组第二题 思路如果不考虑数据范围的话，可以很快得出递推关系式：$dp[i]=min(dp[i+k]+a[i]) (S\\leq k \\leq T)​$（$a[i]​$为$i​$点的石头数$dp[i]​$表示到达$i​$点踩到的最少石头数） 然鹅看了数据范围后，时间和空间都是过不去的。所以需要选择别的方法： 当$S=T$的时候，可以很容易得到：所有在$S$倍数位置上的点，都会走到，所以对该种情况进行特判 我们可以发现石子在桥上放置的是非常稀疏的，而且当点的位置超过一定范围，点都是可以跳到的。所以可以将石子所在的位置压缩到这个范围里去。将压缩后位置储存起来作为新的石头的位置，按照这个位置进行dp即可 假设每次走$p$或者$p+1$步.我们知道$gcd(p,p+1)=1$.由扩展欧几里得可知，对于二元一次方程组：$px+(p+1)y=gcd(p,p+1)$是有整数解的，即可得：$px+(p+1)y=s$是一定有整数解的。设$px+(p+1)y=s$的解为：$x=x_0+(p+1)t,y=y_0−pt$。令$0\\leq x\\leq p$(通过增减$t$个$p+1$来实现)，$s&gt;p\\times (p+1)−1$，则有：$y=\\dfrac {s-px}{p+1}\\geq \\dfrac {s-p^{2}}{p+1} &gt;\\dfrac {p\\left( p+1\\right) -1-px}{p+1}\\geq 0$即表示，当$s\\leq p\\times (p+1)$时，$px+(p+1)y=s$有两个非负整数解，每次走$p$步或者$p+1$步，$p\\times (p+1)$之后的地方均能够到达。如果两个石子之间的距离大于$p\\times (p+1)$，那么就可以直接将他们之间的距离更改为$p \\times (p+1)$。综上，得到压缩路径的方法：若两个石子之间的距离大于$t\\times(t−1)$，则将他们的距离更改为$t\\times (t−1)$。 因$为t\\leq10$，因此我们可以直接将大于$10\\times9$的距离直接化为$90​$. 关于路径压缩常数的选择，证明过程详见：https://blog.csdn.net/qq_34940287/article/details/77494073 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/************************************************************************* &gt; Author: WZY &gt; School: HPU &gt; Created Time: 2019-02-03 15:55:49 ************************************************************************/#include &lt;bits/stdc++.h&gt;#define ll long long#define ull unsigned long long#define ms(a,b) memset(a,b,sizeof(a))#define INF 0x7f7f7f7fconst int maxn=1e6+10;const int mod=1e9+7;using namespace std;int a[maxn];int dp[maxn];int vis[maxn];int main(int argc, char const *argv[])&#123; ios::sync_with_stdio(false); cin.tie(0); int L; int ans=0; int s,t,m; cin&gt;&gt;L; cin&gt;&gt;s&gt;&gt;t&gt;&gt;m; for(int i=1;i&lt;=m;i++) cin&gt;&gt;a[i]; if(s==t) &#123; for(int i=1;i&lt;=m;i++) &#123; if(a[i]%s==0) ans++; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0; &#125; sort(a+1,a+1+m); int _=90; int res=a[1]%_; vis[res]=1; // 缩点 for(int i=2;i&lt;=m;i++) &#123; res+=(a[i]-a[i-1])%_; vis[res]=1; &#125; for(int i=res;i&gt;=0;i--) &#123; dp[i]=INF; for(int j=s;j&lt;=t;j++) dp[i]=min(dp[i],dp[i+j]+vis[i]); &#125; cout&lt;&lt;dp[0]&lt;&lt;endl; return 0;&#125;","categories":[{"name":"solve","slug":"solve","permalink":"https://blog.wzy1999.wang/categories/solve/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://blog.wzy1999.wang/tags/DP/"}]},{"title":"codevs1148——传球游戏（DP）","slug":"codevs1148","date":"2019-02-03T07:37:46.000Z","updated":"2019-02-03T07:48:21.517Z","comments":true,"path":"solve/codevs1148/","link":"","permalink":"https://blog.wzy1999.wang/solve/codevs1148/","excerpt":"题目链接 上体育课的时候，小蛮的老师经常带着同学们一起做游戏。这次，老师带着同学们一起做传球游戏。 游戏规则是这样的：n个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，传球停止，此时，拿着球没传出去的那个同学就是败者，要给大家表演一个节目。","text":"题目链接 上体育课的时候，小蛮的老师经常带着同学们一起做游戏。这次，老师带着同学们一起做传球游戏。 游戏规则是这样的：n个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，传球停止，此时，拿着球没传出去的那个同学就是败者，要给大家表演一个节目。聪明的小蛮提出一个有趣的问题：有多少种不同的传球方法可以使得从小蛮手里开始传的球，传了m次以后，又回到小蛮手里。两种传球的方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有3个同学1号、2号、3号，并假设小蛮为1号，球传了3次回到小蛮手里的方式有1-&gt;2-&gt;3-&gt;1和1-&gt;3-&gt;2-&gt;1，共2种。 输入描述共一行，有两个用空格隔开的整数$n，m（3\\leq n\\leq 30，1\\leq m\\leq30）$。 输出描述共一行，有一个整数，表示符合题意的方法数。 样例输入13 3 样例输出12 数据范围及提示$40\\%$的数据满足：$3\\leq n\\leq 30，1\\leq m\\leq 20$ $100\\%$的数据满足：$3\\leq n\\leq 30$，$1\\leq m\\leq30$ 思路$dp[i][j]$表示第$i$次传球后在第$j$个人手上的方案数 那么$dp[i][j]$将由第$i$次传球的两个状态转移而来——$dp[i-1][j-1]$和$dp[i-1][j+1]$ 转移方程为：$dp[i][j]=dp[i-1][j-1]+dp[i-1][j+1]$ 要注意$n$个同学站成了一个圈，所以需要注意第$n$个人和第$1$个人旁边的两个人的编号 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/************************************************************************* &gt; Author: WZY &gt; School: HPU &gt; Date: 2019-02-03 15:18:55 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;limits.h&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;time.h&gt;#define ll long long#define ull unsigned long long#define ms(a,b) memset(a,b,sizeof(a))#define pi acos(-1.0)#define INF 0x7f7f7f7f#define lson o&lt;&lt;1#define rson o&lt;&lt;1|1#define bug cout&lt;&lt;\"-------------\"&lt;&lt;endl#define debug(...) cerr&lt;&lt;\"[\"&lt;&lt;#__VA_ARGS__\":\"&lt;&lt;(__VA_ARGS__)&lt;&lt;\"]\"&lt;&lt;\"\\n\"const double E=exp(1);const int maxn=1e3+10;const int mod=1e9+7;using namespace std;int dp[maxn][maxn];int main(int argc, char const *argv[])&#123; ios::sync_with_stdio(false); int n,m; cin&gt;&gt;n&gt;&gt;m; dp[1][n]=dp[1][2]=1; for(int i=2;i&lt;=m;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; // a表示左边，b表示右边 int a,b; if(j==1) a=dp[i-1][n]; else a=dp[i-1][j-1]; if(j==n) b=dp[i-1][1]; else b=dp[i-1][j+1]; dp[i][j]=a+b; &#125; &#125; cout&lt;&lt;dp[m][1]&lt;&lt;endl; return 0;&#125;","categories":[{"name":"solve","slug":"solve","permalink":"https://blog.wzy1999.wang/categories/solve/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://blog.wzy1999.wang/tags/DP/"}]},{"title":"codevs1010——过河卒（DP||DFS）","slug":"codevs1010","date":"2019-02-03T06:56:07.000Z","updated":"2019-02-03T07:38:58.340Z","comments":true,"path":"solve/codevs1010/","link":"","permalink":"https://blog.wzy1999.wang/solve/codevs1010/","excerpt":"题目链接 ​ 如图，A 点有一个过河卒，需要走到目标 B 点。卒行走规则：可以向下、或者向右。同时在棋盘上的任一点有一个对方的马（如上图的C点），该马所在的点和所有跳跃一步可达的点称为对方马的控制点。例如上图 C 点上的马可以控制 9 个点（图中的P1，P2 … P8 和 C）。卒不能通过对方马的控制点。","text":"题目链接 ​ 如图，A 点有一个过河卒，需要走到目标 B 点。卒行走规则：可以向下、或者向右。同时在棋盘上的任一点有一个对方的马（如上图的C点），该马所在的点和所有跳跃一步可达的点称为对方马的控制点。例如上图 C 点上的马可以控制 9 个点（图中的P1，P2 … P8 和 C）。卒不能通过对方马的控制点。 棋盘用坐标表示，A 点（0，0）、B 点（n,m）(n,m 为不超过 20 的整数，并由键盘输入)，同样马的位置坐标是需要给出的（约定: C不等于A，同时C不等于B）。现在要求你计算出卒从 A 点能够到达 B 点的路径的条数。 $1&lt;=n,m&lt;=15$ 输入描述一行四个数据，分别表示B点坐标和马的坐标。 输出描述一个数据，表示所有的路径条数。 样例输入16 6 3 2 样例输出117 思路递推写法： 首先将在马的控制范围内的九个点标记出来，在递推的时候隔开这九个点即可。 状态转移方程：$dp[i][j]=dp[i-1][j]+dp[i][j-1]​$ DFS： 同样需要标记九个点，然后就是可以转换成DFS+回溯的问题了 AC代码DP总时间耗费: 10ms总内存耗费: 364 kB 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;limits.h&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;time.h&gt;#define ll long long#define ull unsigned long long#define ms(a,b) memset(a,b,sizeof(a))#define pi acos(-1.0)#define INF 0x7f7f7f7f#define lson o&lt;&lt;1#define rson o&lt;&lt;1|1#define bug cout&lt;&lt;\"-------------\"&lt;&lt;endl#define debug(...) cerr&lt;&lt;\"[\"&lt;&lt;#__VA_ARGS__\":\"&lt;&lt;(__VA_ARGS__)&lt;&lt;\"]\"&lt;&lt;\"\\n\"const double E=exp(1);const int maxn=1e2+10;const int mod=1e9+7;using namespace std;int dp[maxn][maxn];int dir[8][2]=&#123;1,2,1,-2,2,1,2,-1,-1,2,-1,-2,-2,-1,-2,1&#125;;int main(int argc, char const *argv[])&#123; ios::sync_with_stdio(false); int n,m; int x,y; ms(dp,0); cin&gt;&gt;n&gt;&gt;m; cin&gt;&gt;x&gt;&gt;y; dp[x][y]=-1; for(int i=0;i&lt;8;i++) dp[x+dir[i][0]][y+dir[i][1]]=-1; if(dp[0][0]==-1) &#123; cout&lt;&lt;0&lt;&lt;endl; return 0; &#125; dp[0][0]=1; for(int i=0;i&lt;=n;i++) &#123; for(int j=0;j&lt;=m;j++) &#123; if(dp[i][j]!=-1) &#123; if(i&amp;&amp;dp[i-1][j]!=-1) dp[i][j]+=dp[i-1][j]; if(j&amp;&amp;dp[i][j-1]!=-1) dp[i][j]+=dp[i][j-1]; &#125; &#125; &#125; cout&lt;&lt;dp[n][m]&lt;&lt;endl; return 0;&#125; DFS总时间耗费: 934ms总内存耗费: 7 MB 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;limits.h&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;time.h&gt;#define ll long long#define ull unsigned long long#define ms(a,b) memset(a,b,sizeof(a))#define pi acos(-1.0)#define INF 0x7f7f7f7f#define lson o&lt;&lt;1#define rson o&lt;&lt;1|1#define bug cout&lt;&lt;\"-------------\"&lt;&lt;endl#define debug(...) cerr&lt;&lt;\"[\"&lt;&lt;#__VA_ARGS__\":\"&lt;&lt;(__VA_ARGS__)&lt;&lt;\"]\"&lt;&lt;\"\\n\"const double E=exp(1);const int maxn=1e3+10;const int mod=1e9+7;using namespace std;int dir[8][2]=&#123;1,2,1,-2,2,1,2,-1,-1,2,-1,-2,-2,1,-2,-1&#125;;int dir1[2][2]=&#123;1,0,0,1&#125;;int n,m;int ans;int _map[maxn][maxn];int vis[maxn][maxn];void dfs(int x,int y)&#123; if(vis[x][y]==-1||x&lt;0||x&gt;n||y&lt;0||y&gt;m) return ; if(x==n&amp;&amp;y==m) &#123; ans++; return ; &#125; vis[x][y]=1; for(int i=0;i&lt;2;i++) &#123; int dx=x+dir1[i][0]; int dy=y+dir1[i][1]; if(!vis[dx][dy]&amp;&amp;dx&gt;=0&amp;&amp;dx&lt;=n&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;=m&amp;&amp;_map[dx][dy]!=-1) &#123; dfs(dx,dy); vis[dx][dy]=0; &#125; &#125;&#125;int main(int argc, char const *argv[])&#123; ios::sync_with_stdio(false); int x,y; cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y; ms(_map,0); ms(vis,0); _map[x][y]=-1; for(int i=0;i&lt;8;i++) _map[x+dir[i][0]][y+dir[i][1]]=-1; dfs(0,0); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;","categories":[{"name":"solve","slug":"solve","permalink":"https://blog.wzy1999.wang/categories/solve/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://blog.wzy1999.wang/tags/DP/"},{"name":"search","slug":"search","permalink":"https://blog.wzy1999.wang/tags/search/"}]},{"title":"POJ 3126：Prime Path（素数+BFS）","slug":"POJ3126","date":"2019-02-01T05:18:40.000Z","updated":"2019-02-03T07:39:14.493Z","comments":true,"path":"solve/POJ3126/","link":"","permalink":"https://blog.wzy1999.wang/solve/POJ3126/","excerpt":"Prime PathThe ministers of the cabinet were quite upset by the message from the Chief of Security stating that they would all have to change the four-digit room numbers on their offices.— It is a matter of security to change such things every now and then, to keep the enemy in the dark.— But look, I have chosen my number $1033$ for good reasons. I am the Prime minister, you know!— I know, so therefore your new number $8179$ is also a prime. You will just have to paste four new digits over the four old ones on your office door. — No, it’s not that simple. Suppose that I change the first digit to an $8$, then the number will read 8033 which is not a prime!— I see, being the prime minister you cannot stand having a non-prime number on your door even for a few seconds.— Correct! So I must invent a scheme for going from $1033$ to $8179$ by a path of prime numbers where only one digit is changed from one prime to the next prime.","text":"Prime PathThe ministers of the cabinet were quite upset by the message from the Chief of Security stating that they would all have to change the four-digit room numbers on their offices.— It is a matter of security to change such things every now and then, to keep the enemy in the dark.— But look, I have chosen my number $1033$ for good reasons. I am the Prime minister, you know!— I know, so therefore your new number $8179$ is also a prime. You will just have to paste four new digits over the four old ones on your office door. — No, it’s not that simple. Suppose that I change the first digit to an $8$, then the number will read 8033 which is not a prime!— I see, being the prime minister you cannot stand having a non-prime number on your door even for a few seconds.— Correct! So I must invent a scheme for going from $1033$ to $8179$ by a path of prime numbers where only one digit is changed from one prime to the next prime. Now, the minister of finance, who had been eavesdropping, intervened. — No unnecessary expenditure, please! I happen to know that the price of a digit is one pound. — Hmm, in that case I need a computer program to minimize the cost. You don’t know some very cheap software gurus, do you? — In fact, I do. You see, there is this programming contest going on… Help the prime minister to find the cheapest prime path between any two given four-digit primes! The first digit must be nonzero, of course. Here is a solution in the case above. 1033173337333739377987798179 The cost of this solution is $6$ pounds. Note that the digit $1$ which got pasted over in step $2$ can not be reused in the last step – a new $1$ must be purchased. InputOne line with a positive number: the number of test cases (at most $100$). Then for each test case, one line with two numbers separated by a blank. Both numbers are four-digit primes (without leading zeros). OutputOne line for each case, either with a number stating the minimal cost or containing the word Impossible. ExamplesInput 123431033 81791373 80171033 1033 Output 123670 题意给出两个四位的素数$n,m$，要求$n$每次只能变换一位，并且变换后的数字依旧是素数。求$n$经过多少步变换能够变成$m$；如果$n$无法变成$m$，输出Impossible 思路将$n$的四位数字拆分了，每次变换一位，来判断是否符合条件，如果符合条件，将新数字加入队列，至到数字和$m$相等，或队列为空 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;limits.h&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;time.h&gt;#define ll long long#define ull unsigned long long#define ms(a,b) memset(a,b,sizeof(a))#define pi acos(-1.0)#define INF 0x7f7f7f7f#define lson o&lt;&lt;1#define rson o&lt;&lt;1|1#define bug cout&lt;&lt;\"-------------\"&lt;&lt;endl#define debug(...) cerr&lt;&lt;\"[\"&lt;&lt;#__VA_ARGS__\":\"&lt;&lt;(__VA_ARGS__)&lt;&lt;\"]\"&lt;&lt;\"\\n\"const int maxn=1e4+10;const int mod=1e9+7;using namespace std;int vis[maxn];int _vis[maxn];int cnt;struct node&#123; int num; int step;&#125;;int bfs(int n,int m)&#123; ms(_vis,0); int newnum; node p,q; queue&lt;node&gt;que; p.num=n; p.step=0; que.push(p); _vis[n]=1; while(!que.empty()) &#123; q=que.front(); que.pop(); if(q.num==m) return q.step; int get[4]; int N=q.num; int _=0; while(N) &#123; get[_++]=N%10; N/=10; &#125; for(int i=0;i&lt;4;i++) &#123; int __=get[i]; for(int j=0;j&lt;=9;j++) &#123; if(get[i]!=j) &#123; get[i]=j; newnum=get[0]+get[1]*10+get[2]*100+get[3]*1000; &#125; if(!vis[newnum]&amp;&amp;newnum&gt;=1000&amp;&amp;newnum&lt;10000&amp;&amp;!_vis[newnum]) &#123; p.num=newnum; p.step=q.step+1; _vis[newnum]=1; que.push(p); &#125; &#125; get[i]=__; &#125; &#125; return -1;&#125;void init()&#123; vis[0]=vis[1]=1; for(int i=2;i&lt;maxn;i++) &#123; if(!vis[i]) &#123; for(int j=2;j*i&lt;maxn;j++) vis[i*j]=1; &#125; &#125;&#125;int main(int argc, char const *argv[])&#123; ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(\"in.txt\", \"r\", stdin); freopen(\"out.txt\", \"w\", stdout); double _begin_time = clock(); #endif init(); int t; cin&gt;&gt;t; while(t--) &#123; int n,m; cin&gt;&gt;n&gt;&gt;m; int ans=bfs(n,m); if(ans==-1) cout&lt;&lt;\"Impossible\"&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; &#125; #ifndef ONLINE_JUDGE long _end_time = clock(); printf(\"time = %lf ms.\", _end_time - _begin_time); #endif return 0;&#125;","categories":[{"name":"solve","slug":"solve","permalink":"https://blog.wzy1999.wang/categories/solve/"}],"tags":[{"name":"search","slug":"search","permalink":"https://blog.wzy1999.wang/tags/search/"},{"name":"math","slug":"math","permalink":"https://blog.wzy1999.wang/tags/math/"}]},{"title":"字符串操作","slug":"pyl-4","date":"2019-01-27T05:07:37.000Z","updated":"2019-02-10T08:04:07.947Z","comments":true,"path":"learn/pyl-4/","link":"","permalink":"https://blog.wzy1999.wang/learn/pyl-4/","excerpt":"第六章——字符串操作 字符串以单（双）引号开始，单（双）引号结束 在字符串开始的引号之前加上r，可以将字符串称为原始字符串，打印出字符串中所有的\\之类的转义字符","text":"第六章——字符串操作 字符串以单（双）引号开始，单（双）引号结束 在字符串开始的引号之前加上r，可以将字符串称为原始字符串，打印出字符串中所有的\\之类的转义字符 1234&gt;&gt;&gt; print('he\\tllo')he llo&gt;&gt;&gt; print(r'he\\tllo')he\\tllo 多行字符串以三个单（双）引号开始，三个单（双）引号结束。 1234print('''hellothe \\nworld''') 输出为： 1234hellothe world 用in和not in可以判断一个字符串是否在另一个字符串中 1234&gt;&gt;&gt; 'bcd' in 'abcde'True&gt;&gt;&gt; 'ad' not in 'abcd'True 字符串的一些方法upper()将字符串中的字母全变为大写；lower()将字符串中的字母全变为小写；isupper()判断字符串中的所有字母是否是大写；islower()判断字符串中的所有字母是否是小写 12345678&gt;&gt;&gt; '12AbcD'.lower()'12abcd'&gt;&gt;&gt; '12AbcD'.upper()'12ABCD'&gt;&gt;&gt; '12AbcD'.isupper()False&gt;&gt;&gt; '12ABCD'.isupper()True isX方法 isalpha()返回True，如果字符串只包含字母，并且非空； isalnum()返回True，如果字符串只包含字母和数字，并且非空： isdecimal()返回True，如果字符串只包含数字字符，并且非空： ispace()返回True，如果字符串只包含空格、制表符和换行，并且非空； istitle()返回True，如果字符串仅包含以大写字母开头、后面都是小写字母的单词。 startswith()和endswith返回值为布尔类型，用来判断调用的字符串是否以该方法传入的字符串开始或结束 1234&gt;&gt;&gt; 'abcde'.startswith('ab')True&gt;&gt;&gt; 'abcde'.endswith('cde')True join()和split()join()是将一个字符串列表连接成单独的字符串，split()是将单独的字符串分割成一个字符串列表 join()针对一个字符串调用，传入一个列表值；split()相反 1234&gt;&gt;&gt; '-'.join(['a','b','c'])'a-b-c'&gt;&gt;&gt; 'a-b-c'.split('-')['a', 'b', 'c'] rjust()、ljust()、center()这三种方法用来对齐字符串 rjust()、ljust()和center()分别用来右对齐、左对齐、中间对齐字符串；有两个参数：第一个参数是一个整数，代表字符串的长度；第二个参数是一个字符，表示除原字符串之外的部分用该字符补齐。 第二个参数默认为空格 123456&gt;&gt;&gt; 'abc'.rjust(10,'*')'*******abc'&gt;&gt;&gt; 'abc'.ljust(10,'*')'abc*******'&gt;&gt;&gt; 'abc'.center(10,'*')'***abc****' strip()、rstrip()、lstrip()这三种方法用来删除空白字符 分别表示删除两边字符、删除右边、删除左边。有一个参数，代表需要删除的字符，默认为空格 参数可以是一个字符串，但同样是看成字符的形式，删除时和字符的顺序无关 123456&gt;&gt;&gt; 'abccbacab123456cabcba'.lstrip('abc')'123456cabcba'&gt;&gt;&gt; 'abccbacab123456cabcba'.rstrip('abc')'abccbacab123456'&gt;&gt;&gt; 'abccbacab123456cabcba'.strip('abc')'123456' pyperclip模块里的copy()和paste()函数可以向计算机的剪切板发送和接受文本。pyperclip模块需要安装","categories":[{"name":"learn","slug":"learn","permalink":"https://blog.wzy1999.wang/categories/learn/"}],"tags":[{"name":"py_learn","slug":"py-learn","permalink":"https://blog.wzy1999.wang/tags/py-learn/"}]},{"title":"字典和结构化数据","slug":"pyl-3","date":"2019-01-25T09:10:42.000Z","updated":"2019-02-10T08:03:55.512Z","comments":true,"path":"learn/pyl-3/","link":"","permalink":"https://blog.wzy1999.wang/learn/pyl-3/","excerpt":"第五章——字典和结构化数据字典 字典的索引被称为键，键及其关联的值称为键-值。字典输入的时候要带花括号{}，在使用的时候和列表一样使用中括号[]","text":"第五章——字典和结构化数据字典 字典的索引被称为键，键及其关联的值称为键-值。字典输入的时候要带花括号{}，在使用的时候和列表一样使用中括号[] 123&gt;&gt;&gt; myCat=&#123;'size':'fat','color':'gray'&#125;&gt;&gt;&gt; myCat['size']'fat' 判断两个列表相同，要看两个列表中的对应位置的元素是否相同；判断两个字典是否相同，只需看两个字典的键-值是否相同即可 12345678&gt;&gt;&gt; List=['a','b','c']&gt;&gt;&gt; List1=['b','a','c']&gt;&gt;&gt; List==List1False&gt;&gt;&gt; dic=&#123;1:'a',2:'b',3:'c'&#125;&gt;&gt;&gt; dic1=&#123;2:'b',1:'a',3:'c'&#125;&gt;&gt;&gt; dic==dic1True 如果访问字典中不存在的键，则会导致KeyError 字典中的一些方法keys() values() items()这三种方法分别对应字典的键、值、键-值对。返回的值是类似列表的值，不是真正的列表，不能被修改 1234567&gt;&gt;&gt; spam=&#123;'color':'red','age':18&#125;&gt;&gt;&gt; spam.values()dict_values(['red', 18])&gt;&gt;&gt; spam.keys()dict_keys(['color', 'age'])&gt;&gt;&gt; spam.items()dict_items([('color', 'red'), ('age', 18)]) 如果想要得到一个列表，可以用list()进行转换 使用in和not in依旧可以检查值是否在字典中，查询时如果不声明，默认按照keys()进行查询 123456789&gt;&gt;&gt; dic=&#123;1:'a',2:'b',3:'c'&#125;&gt;&gt;&gt; 1 in dic.keys()True&gt;&gt;&gt; 'a' in dic.values()True&gt;&gt;&gt; 1 in dicTrue&gt;&gt;&gt; (1,'a') in dic.items()True get()方法get()有两个参数：要取得该值的键和一个备用的返回值。如果查询的键不在字典中，返回备用的值；否则返回该键对应的值。get()的默认返回值为$0$，如果不适用get()方法，在查询失败的时候会返回KeyError setdefault()方法setdefault()方法存在两个参数。相当于提供了一个if语句：如果字典中存在查找的键（第一个参数），返回键对应的值；否则将第一个参数作为键，第二个参数作为第一个参数对应的值加入到字典中 12dic=&#123;1:'a',2:'b',3:'c'&#125;dic.setdefault(4,'d') 相当于： 123dic=&#123;1:'a',2:'b',3:'c'&#125;if 4 not in dic: dic[4]='d' 输出dic会发现输出均为： 1&#123;1: 'a', 2: 'b', 3: 'c', 4: 'd'&#125; 使用setdefault()可以确保一个键的存在 可以利用setdefault()对字符串中出现的字符进行计数： 123456s='qwertyuioplkjhgfdsazxcvbnm'count=&#123;&#125;for ch in s: count.setdefault(ch,0) count[ch]+=1print(count) 输出结果为： 1&#123;'q': 1, 'w': 1, 'e': 1, 'r': 1, 't': 1, 'y': 1, 'u': 1, 'i': 1, 'o': 1, 'p': 1, 'l': 1, 'k': 1, 'j': 1, 'h': 1, 'g': 1, 'f': 1, 'd': 1, 's': 1, 'a': 1, 'z': 1, 'x': 1, 'c': 1, 'v': 1, 'b': 1, 'n': 1, 'm': 1&#125; pprint模块的简单应用将上述代码导入pprint模块之后，使用pprint()输出： 1234567import pprints='qwertyuioplkjhgfdsazxcvbnm'count=&#123;&#125;for ch in s: count.setdefault(ch,0) count[ch]+=1pprint.pprint(count) 输出结果为： 1234567891011121314151617181920212223242526&#123;&apos;a&apos;: 1, &apos;b&apos;: 1, &apos;c&apos;: 1, &apos;d&apos;: 1, &apos;e&apos;: 1, &apos;f&apos;: 1, &apos;g&apos;: 1, &apos;h&apos;: 1, &apos;i&apos;: 1, &apos;j&apos;: 1, &apos;k&apos;: 1, &apos;l&apos;: 1, &apos;m&apos;: 1, &apos;n&apos;: 1, &apos;o&apos;: 1, &apos;p&apos;: 1, &apos;q&apos;: 1, &apos;r&apos;: 1, &apos;s&apos;: 1, &apos;t&apos;: 1, &apos;u&apos;: 1, &apos;v&apos;: 1, &apos;w&apos;: 1, &apos;x&apos;: 1, &apos;y&apos;: 1, &apos;z&apos;: 1&#125; pprint()对于包含列表等的字典特别有用 使用pformat()可以将pprint()输出的字典当做字符串来储存。以下两行代码是等效的： 12pprint.pprint(count)print(pprint.pformat((count)))","categories":[{"name":"learn","slug":"learn","permalink":"https://blog.wzy1999.wang/categories/learn/"}],"tags":[{"name":"py_learn","slug":"py-learn","permalink":"https://blog.wzy1999.wang/tags/py-learn/"}]},{"title":"NumPy函数库基础","slug":"ml-1","date":"2019-01-23T06:34:28.000Z","updated":"2019-02-10T08:02:25.985Z","comments":true,"path":"learn/ml-1/","link":"","permalink":"https://blog.wzy1999.wang/learn/ml-1/","excerpt":"from numpy import*导入numpy模块 random.rand()用来生成一个随机数组","text":"from numpy import*导入numpy模块 random.rand()用来生成一个随机数组 例如：random.rand(4,4)，生成一个$4\\times 4$的随机二维数组 12345&gt;&gt;&gt; random.rand(4,4)array([[0.5889423 , 0.38768404, 0.46706706, 0.88201106], [0.03742084, 0.30163653, 0.40948962, 0.22092582], [0.84407563, 0.42206233, 0.26600708, 0.8114246 ], [0.39277872, 0.88407207, 0.59209405, 0.19366928]]) 用mat()函数可以将数组转换成矩阵 12345&gt;&gt;&gt; mat(random.rand(4,4))matrix([[0.27334161, 0.3052977 , 0.68240247, 0.65456973], [0.09794511, 0.74127397, 0.11178214, 0.18242132], [0.15790548, 0.99141967, 0.57665171, 0.90780008], [0.7987583 , 0.06336807, 0.94360913, 0.18242104]]) .I操作符实现了矩阵的求逆运算 矩阵求逆，即求矩阵的逆矩阵。设$A$是数域上的一个$n$阶方阵，若在相同数域上存在另一个$n$阶矩$B$，使得： $A\\times B=B\\times A=E$。 则我们称$B$是$A$的逆矩阵，而A则被称为可逆矩阵。其中，$E$为单位矩阵。 123456789101112&gt;&gt;&gt; randmat=mat(random.rand(4,4))&gt;&gt;&gt; invmat=randmat.I&gt;&gt;&gt; randmatmatrix([[0.48117984, 0.29220134, 0.34585956, 0.30547942], [0.42158584, 0.12684831, 0.56184421, 0.93906936], [0.25070707, 0.0770531 , 0.46094489, 0.18799276], [0.1206866 , 0.5818652 , 0.75019166, 0.69006769]])&gt;&gt;&gt; invmatmatrix([[ 2.23619026, 0.10754838, 0.07245331, -1.15601151], [ 1.7848114 , -1.14762783, -2.14901481, 1.35708167], [-1.33183128, -0.45568243, 3.15370035, 0.35053317], [-0.44817218, 1.44425573, -1.62909657, 0.12594335]]) 如果执行矩阵乘法，将两个矩阵直接相乘即可： 123456789&gt;&gt;&gt; randmat*invmatmatrix([[ 1.00000000e+00, 0.00000000e+00, 5.55111512e-17, 2.77555756e-17], [ 1.11022302e-16, 1.00000000e+00, 0.00000000e+00, 8.32667268e-17], [-2.77555756e-16, -5.55111512e-17, 1.00000000e+00, 9.02056208e-17], [-1.66533454e-16, 2.22044605e-16, 4.44089210e-16, 1.00000000e+00]]) eye(4)用来创建$4\\times 4$的单位矩阵，可以用来检测误差值 12345&gt;&gt;&gt; eye(4)array([[1., 0., 0., 0.], [0., 1., 0., 0.], [0., 0., 1., 0.], [0., 0., 0., 1.]]) 12345678910&gt;&gt;&gt; deviation=randmat*invmat&gt;&gt;&gt; deviation-eye(4)matrix([[ 0.00000000e+00, 0.00000000e+00, 5.55111512e-17, 2.77555756e-17], [ 1.11022302e-16, -2.22044605e-16, 0.00000000e+00, 8.32667268e-17], [-2.77555756e-16, -5.55111512e-17, 0.00000000e+00, 9.02056208e-17], [-1.66533454e-16, 2.22044605e-16, 4.44089210e-16, 0.00000000e+00]])","categories":[{"name":"learn","slug":"learn","permalink":"https://blog.wzy1999.wang/categories/learn/"}],"tags":[{"name":"ml_learn","slug":"ml-learn","permalink":"https://blog.wzy1999.wang/tags/ml-learn/"}]},{"title":"函数、列表","slug":"pyl-2","date":"2019-01-23T06:28:06.000Z","updated":"2019-02-10T08:03:37.954Z","comments":true,"path":"learn/pyl-2/","link":"","permalink":"https://blog.wzy1999.wang/learn/pyl-2/","excerpt":"第三章——函数 None表示没有值，是NoneType数据类型的唯一值。print的返回值就是None print()函数有可选的变元end和sep，分别指定在参数末尾打印什么，在参数之间打印什么来隔开它们","text":"第三章——函数 None表示没有值，是NoneType数据类型的唯一值。print的返回值就是None print()函数有可选的变元end和sep，分别指定在参数末尾打印什么，在参数之间打印什么来隔开它们 例如： end 12print('hello')print('word') 12print('hello',end=' ')print('word') 输出分别为： 12helloword 1hello word sep 1234&gt;&gt;&gt; print('a','b','c')a b c&gt;&gt;&gt; print('a','b','c',sep=',')a,b,c 全局作用域中的代码不能使用局部变量，局部作用域可以访问全局变量 在不同的作用域中，可以用相同的名字命名不同的变量 global在局部作用域中修改全局变量 例如： 1234567def spam(): global eggs eggs='spam'eggs='global'print(eggs)spam()print(eggs) 在第一次输出的时候，由于eggs未被修改，所以输出global，第二次输出的时候，因为经过了spam，eggs变成了spam，所以输出为spam 异常处理出现的错误可以用try...except来处理。将可能出错的语句放在try子句中，如果错误发生，程序执行转到接下来的except子句开始处 第四章——列表 列表的负数下标表示列表中的倒数第几个元素，如：num[-1]表示num列表中的最后一个元素 用len()获取列表的长度，方法和字符串相同，返回值为列表中值的个数 例如： 123&gt;&gt;&gt; arr=['acb','d','e']&gt;&gt;&gt; len(arr)3 改变列表中元素的值时，直接找到对应的下标，进行赋值即可 切片切片得到的是一个新的列表，而不是一个值。 在一个切片中，第一个整数表示切片开始出的下标，第二个整数表示结束的下标 第一个整数默认为$0$，第二个整数默认为列表中最后一个元素的下标 例如： 123456789&gt;&gt;&gt; arr=['a','b','c','d','e']&gt;&gt;&gt; arr[:]['a', 'b', 'c', 'd', 'e']&gt;&gt;&gt; arr[3:]['d', 'e']&gt;&gt;&gt; arr[:3]['a', 'b', 'c']&gt;&gt;&gt; arr[1:3]['b', 'c'] 列表的连接和复制+运算符可以连接两个列表；*运算符可以实现列表的复制 例如： 1234&gt;&gt;&gt; [1,2,3]+['a','b','c'][1, 2, 3, 'a', 'b', 'c']&gt;&gt;&gt; [1,2,3,4]*2[1, 2, 3, 4, 1, 2, 3, 4] 列表的使用 for i in []表示i从列表的第一个元素开始遍历数组，i对应的值为当前元素的值 例如： 12for i in [1,4,2]:print(i) 输出结果为： 123142 如果想要根据获得当前遍历元素的下标，可以先用len()获得列表的长度，然后用range()来遍历下标，arr[i]来访问元素 利用in和not in可以快速确定元素是否在列表中，返回值为bool类型 例如： 1234&gt;&gt;&gt; 'd' in ['a','b','c']False&gt;&gt;&gt; 'c' in ['a','b','c']True 列表中的一些方法 index()用来查找某个元素是否在列表中，如果在列表中，返回该元素在列表中第一次出现的下标，否则，会报ValueError 例如： 1234567&gt;&gt;&gt; arr=['a','a','b']&gt;&gt;&gt; arr.index('a')0&gt;&gt;&gt; arr.index('d')Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;ValueError: 'd' is not in list append()和insert()都可以向列表中加入元素，append()只能把元素加入到列表的尾部，insert()则可以向列表中的任意位置加入元素，insert()的第一个整数表示下标，如果该值超过当前列表的长度，那么元素将会被加到列表的末尾 12345678910&gt;&gt;&gt; arr=['a','b']&gt;&gt;&gt; arr.append('c')&gt;&gt;&gt; arr['a', 'b', 'c']&gt;&gt;&gt; arr.insert(2,'d')&gt;&gt;&gt; arr['a', 'b', 'd', 'c']&gt;&gt;&gt; arr.insert(10,'e')&gt;&gt;&gt; arr['a', 'b', 'd', 'c', 'e'] remove()用来删除列表中第一次出现的元素，如果该元素不在列表中，则会ValueError 12345678&gt;&gt;&gt; arr=['a','b']&gt;&gt;&gt; arr.remove('a')&gt;&gt;&gt; arr['b']&gt;&gt;&gt; arr.remove('a')Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;ValueError: list.remove(x): x not in list sort()用来对列表进行排序，默认为按ASCII码升序排序，sort(reverse=True)可以将排序改为降序，sort(key=str.lower)将排序按照普通字典序排序 1234567891011121314&gt;&gt;&gt; arr=['a','A','b']&gt;&gt;&gt; arr.sort()&gt;&gt;&gt; arr['A', 'a', 'b']&gt;&gt;&gt; arr=['a','A','b','B']&gt;&gt;&gt; arr.sort()&gt;&gt;&gt; arr['A', 'B', 'a', 'b']&gt;&gt;&gt; arr.sort(reverse=True)&gt;&gt;&gt; arr['b', 'a', 'B', 'A']&gt;&gt;&gt; arr.sort(key=str.lower)&gt;&gt;&gt; arr['a', 'A', 'b', 'B'] 字符串和元组 字符串和元组都是不可改变的 字符串和元组访问元素的方式和列表一样，注意：元组输入要用()而不是[] 如果元组中只有一个元素，在该元素后面加一个,来告诉程序这是一个元组 例如： 1234&gt;&gt;&gt; type((123,))&lt;class 'tuple'&gt;&gt;&gt;&gt; type((123))&lt;class 'int'&gt; 字符串、列表、元组可以相互转换 123456&gt;&gt;&gt; tuple(['a','b','c'])('a', 'b', 'c')&gt;&gt;&gt; list(('a','b','c'))['a', 'b', 'c']&gt;&gt;&gt; list('abc')['a', 'b', 'c'] 如果将列表直接赋值给另一个列表，那么改变这两个列表中的其中一个，这两个列表均会被改变。原因是在对列表进行赋值的时候，只是将列表中的元素给了另一个列表，而不是列表本身。两个列表均指向同一个列表，所以当一个列表被修改时，指向的列表会被改变，从而两个列表的元素均会变化。 使用copy模块里的copy()和deepcopy()函数可以实现对列表本身的复制， 12345678&gt;&gt;&gt; import copy&gt;&gt;&gt; arr1=['a','b','c']&gt;&gt;&gt; arr2=copy.copy(arr1)&gt;&gt;&gt; arr2[1]='d'&gt;&gt;&gt; arr2['a', 'd', 'c']&gt;&gt;&gt; arr1['a', 'b', 'c']","categories":[{"name":"learn","slug":"learn","permalink":"https://blog.wzy1999.wang/categories/learn/"}],"tags":[{"name":"py_learn","slug":"py-learn","permalink":"https://blog.wzy1999.wang/tags/py-learn/"}]},{"title":"Python基础、控制流","slug":"pyl-1","date":"2019-01-22T10:27:47.000Z","updated":"2019-02-10T08:03:22.700Z","comments":true,"path":"learn/pyl-1/","link":"","permalink":"https://blog.wzy1999.wang/learn/pyl-1/","excerpt":"第一章——Python基础 操作符 操作 例子 求值为 ** 指数 $2**3$ $8$ % 取模 $22\\%8$ $6$ // 整除 $22//8$ $2$ / 除法 $22/8$ $2.75$","text":"第一章——Python基础 操作符 操作 例子 求值为 ** 指数 $2**3$ $8$ % 取模 $22\\%8$ $6$ // 整除 $22//8$ $2$ / 除法 $22/8$ $2.75$ input()默认输入字符串，如果想要别的类型，需要强制转换 print(&#39;str1&#39;+&#39;str2&#39;)表示将两个字符串连接起来，输出为str1str2 print(&#39;str&#39;*int)表示将str输出int次 print()中的+只能用来连接两个整数或字符串 len(&#39;str&#39;)表示返回当前字符串str的长度。比如：len(&#39;abc&#39;)，返回值为3 关于int()的转换问题如果int()内的是一个字符串，那么字符串一定要是一个表示整数数字的字符，否则会报错，报错信息如下：1234&gt;&gt;&gt; int(&apos;1000.0&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: invalid literal for int() with base 10: &apos;1000.0&apos; 12&gt;&gt;&gt; int(&apos;1000&apos;)1000 如果括号中的是一个浮点型数字，相当于把该数字向下取整，例如：12&gt;&gt;&gt; int(1.9)1 第二章——控制流布尔值True和False均是首字母大写，如果多个值进行比较（可以使字符串、整型、浮点型），如果相等，返回True，否则返回False。0、0.0、&#39;&#39;被认为是False!=和==可以用于所有数据类型，&gt;、&gt;=、&lt;、&lt;=只能用于整型和浮点型布尔操作符：and、or、not根据代码行的缩进，来判定代码块的开始和结束 for循环和range()函数for语句包括： for关键字 一个变量名 in关键字 调用range()方法，最多三个参数 冒号 for子句 range()中的三个参数 一个参数：for i in range(num)表示循环从$i=0$运行到$i=num-1$，$i$每次增加$1$ 12for i in range(2): print(i) 输出结果为：1201 两个参数：for i in range(num1,num2)表示循环从$i=num1$运行到$i=num2-1$，$i$每次增加$1$ 12for i in range(0,2): print(i) 输出结果为： 1201 三个参数：for i in range(num1,num2,step)表示循环从$i=num1$运行到$i=num2-1$，$i$每次增加$step$ 12for i in range(0,4,2): print(i) 输出结果为： 1202 导入模块用import来导入模块 用import+模块名称，在引用函数的时候需要加前缀：模块名称. 用from+模块名称+import*，引用的时候不需要加前缀，只需要写函数名即可 例如： 123456# import random# for i in range(5):# print(random.randint(1,10))from random import*for i in range(5): print(randint(1,10)) 注释内和注释外的代码均表示生成五个$[1,10]$间的随机数 用sys.exit()提前结束程序exit是sys模块里的函数，用来让程序终止或退出 例如： 1234567import syswhile True: print('Type exit to exit.') response=input() if response=='exit': sys.exit() print('You tryed '+response+'.') 当输入exit的时候程序停止，否则将一直循环下去 与OJ刷题相关 判断文件结束符EOF 对于只输入一个字符串或数字，可以用sys.stdin： 12345import sys for line in sys.stdin: a=int(line) if a!=0: print(a) 对于需要输入多个，可以用try...except： 1234567try: while True: s = input() print(s)except EOFError:# 或者excepr: pass","categories":[{"name":"learn","slug":"learn","permalink":"https://blog.wzy1999.wang/categories/learn/"}],"tags":[{"name":"py_learn","slug":"py-learn","permalink":"https://blog.wzy1999.wang/tags/py-learn/"}]},{"title":"vimrc","slug":"vimrc","date":"2019-01-21T09:50:31.439Z","updated":"2019-01-21T12:26:14.200Z","comments":true,"path":"Configuration/vimrc/","link":"","permalink":"https://blog.wzy1999.wang/Configuration/vimrc/","excerpt":"vim的配置文件","text":"vim的配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 显示相关 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;set shortmess=atI &quot; 启动的时候不显示那个援助乌干达儿童的提示 &quot;winpos 5 5 &quot; 设定窗口位置 &quot;set lines=40 columns=155 &quot; 设定窗口大小 &quot;set nu &quot; 显示行号 set go= &quot; 不要图形按钮 &quot;color asmanian2 &quot; 设置背景主题 set guifont=Courier_New:h10:cANSI &quot; 设置字体 &quot;syntax on &quot; 语法高亮 autocmd InsertLeave * se nocul &quot; 用浅色高亮当前行 autocmd InsertEnter * se cul &quot; 用浅色高亮当前行 &quot;set ruler &quot; 显示标尺 set showcmd &quot; 输入的命令显示出来，看的清楚些 &quot;set cmdheight=1 &quot; 命令行（在状态行下）的高度，设置为1 &quot;set whichwrap+=&lt;,&gt;,h,l &quot; 允许backspace和光标键跨越行边界(不建议) &quot;set scrolloff=3 &quot; 光标移动到buffer的顶部和底部时保持3行距离 set novisualbell &quot; 不要闪烁(不明白) set statusline=%F%m%r%h%w\\ [FORMAT=%&#123;&amp;ff&#125;]\\ [TYPE=%Y]\\ [POS=%l,%v][%p%%]\\ %&#123;strftime(\\&quot;%d/%m/%y\\ -\\ %H:%M\\&quot;)&#125; &quot;状态行显示的内容 set laststatus=1 &quot; 启动显示状态行(1),总是显示状态行(2) set foldenable &quot; 允许折叠 set foldmethod=manual &quot; 手动折叠 &quot;set background=dark &quot;背景使用黑色 set nocompatible &quot;去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限 &quot; 显示中文帮助if version &gt;= 603 set helplang=cn set encoding=utf-8endif&quot; 设置配色方案&quot;colorscheme murphy&quot;字体 &quot;if (has(&quot;gui_running&quot;)) &quot; set guifont=Bitstream\\ Vera\\ Sans\\ Mono\\ 10 &quot;endif set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936set termencoding=utf-8set encoding=utf-8set fileencodings=ucs-bom,utf-8,cp936set fileencoding=utf-8&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;新文件标题&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;新建.c,.h,.sh,.java文件，自动插入文件头 autocmd BufNewFile *.cpp,*.[ch],*.sh,*.java exec &quot;:call SetTitle()&quot; &quot;&quot;定义函数SetTitle，自动插入文件头 func SetTitle() &quot;如果文件类型为.sh文件 if &amp;filetype == &apos;sh&apos; call setline(1,&quot;\\#########################################################################&quot;) call append(line(&quot;.&quot;), &quot;\\# File Name: &quot;.expand(&quot;%&quot;)) call append(line(&quot;.&quot;)+1, &quot;\\# Author: WZY&quot;) call append(line(&quot;.&quot;)+2, &quot;\\# School: HPU&quot;) call append(line(&quot;.&quot;)+3, &quot;\\# Created Time: &quot;.strftime(&quot;%c&quot;)) call append(line(&quot;.&quot;)+4, &quot;\\#########################################################################&quot;) call append(line(&quot;.&quot;)+5, &quot;\\#!/bin/bash&quot;) call append(line(&quot;.&quot;)+6, &quot;&quot;) else call setline(1, &quot;/*************************************************************************&quot;) call append(line(&quot;.&quot;), &quot; &gt; File Name: &quot;.expand(&quot;%&quot;)) call append(line(&quot;.&quot;)+1, &quot; &gt; Author: WZY&quot;) call append(line(&quot;.&quot;)+2, &quot; &gt; School: HPU &quot;) call append(line(&quot;.&quot;)+3, &quot; &gt; Created Time: &quot;.strftime(&quot;%c&quot;)) call append(line(&quot;.&quot;)+4, &quot; ************************************************************************/&quot;) call append(line(&quot;.&quot;)+5, &quot;&quot;) endif if &amp;filetype == &apos;cpp&apos; call append(line(&quot;.&quot;)+6, &quot;#include&lt;bits/stdc++.h&gt;&quot;) call append(line(&quot;.&quot;)+7, &quot;#define ll long long&quot;) call append(line(&quot;.&quot;)+8, &quot;#define ull unsigned long long&quot;) call append(line(&quot;.&quot;)+9, &quot;#define ms(a,b) memset(a,b,sizeof(a))&quot;) call append(line(&quot;.&quot;)+10, &quot;#define pi acos(-1.0)&quot;) call append(line(&quot;.&quot;)+11, &quot;#define INF 0x7f7f7f7f&quot;) call append(line(&quot;.&quot;)+12, &quot;const double E=exp(1);&quot;) call append(line(&quot;.&quot;)+13, &quot;const int maxn=1e6+10;&quot;) call append(line(&quot;.&quot;)+14, &quot;const int mod=1e9+7;&quot;) call append(line(&quot;.&quot;)+15, &quot;using namespace std;&quot;) call append(line(&quot;.&quot;)+16, &quot;int main(int argc, char const *argv[])&quot;) call append(line(&quot;.&quot;)+17, &quot;&#123;&quot;) call append(line(&quot;.&quot;)+18, &quot;\\tios::sync_with_stdio(false);&quot;) call append(line(&quot;.&quot;)+19, &quot;\\t&quot;) call append(line(&quot;.&quot;)+20, &quot;\\treturn 0;&quot;) call append(line(&quot;.&quot;)+21, &quot;&#125;&quot;) endif if &amp;filetype == &apos;c&apos; call append(line(&quot;.&quot;)+6, &quot;#include&lt;stdio.h&gt;&quot;) call append(line(&quot;.&quot;)+7, &quot;&quot;) endif &quot;新建文件后，自动定位到文件末尾 autocmd BufNewFile * normal Gendfunc &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;键盘命令&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;nmap &lt;leader&gt;w :w!&lt;cr&gt;nmap &lt;leader&gt;f :find&lt;cr&gt;&quot; 映射全选+复制 ctrl+amap &lt;C-A&gt; ggVGYmap! &lt;C-A&gt; &lt;Esc&gt;ggVGYmap &lt;F12&gt; gg=G&quot; 选中状态下 Ctrl+c 复制vmap &lt;C-c&gt; &quot;+y&quot;去空行 nnoremap &lt;F2&gt; :g/^\\s*$/d&lt;CR&gt; &quot;比较文件 nnoremap &lt;C-F2&gt; :vert diffsplit &quot;新建标签 map &lt;M-F2&gt; :tabnew&lt;CR&gt; &quot;列出当前目录文件 map &lt;F3&gt; :tabnew .&lt;CR&gt; &quot;打开树状文件目录 map &lt;C-F3&gt; \\be &quot;C，C++ 按F5编译运行map &lt;F5&gt; :call CompileRunGcc()&lt;CR&gt;func! CompileRunGcc() exec &quot;w&quot; if &amp;filetype == &apos;c&apos; exec &quot;!g++ % -o %&lt;&quot; exec &quot;! ./%&lt;&quot; elseif &amp;filetype == &apos;cpp&apos; exec &quot;!g++ % -o %&lt;&quot; exec &quot;! ./%&lt;&quot; elseif &amp;filetype == &apos;java&apos; exec &quot;!javac %&quot; exec &quot;!java %&lt;&quot; elseif &amp;filetype == &apos;sh&apos; :!./% endifendfunc&quot;C,C++的调试map &lt;F8&gt; :call Rungdb()&lt;CR&gt;func! Rungdb() exec &quot;w&quot; exec &quot;!g++ % -g -o %&lt;&quot; exec &quot;!gdb ./%&lt;&quot;endfunc&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;实用设置&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 设置当文件被改动时自动载入set autoread&quot; quickfix模式autocmd FileType c,cpp map &lt;buffer&gt; &lt;leader&gt;&lt;space&gt; :w&lt;cr&gt;:make&lt;cr&gt;&quot;代码补全 set completeopt=preview,menu &quot;允许插件 filetype plugin on&quot;共享剪贴板 set clipboard+=unnamed &quot;从不备份 set nobackup&quot;make 运行:set makeprg=g++\\ -Wall\\ \\ %&quot;自动保存set autowriteset ruler &quot; 打开状态栏标尺set cursorline &quot; 突出显示当前行set magic &quot; 设置魔术set guioptions-=T &quot; 隐藏工具栏set guioptions-=m &quot; 隐藏菜单栏&quot;set statusline=\\ %&lt;%F[%1*%M%*%n%R%H]%=\\ %y\\ %0(%&#123;&amp;fileformat&#125;\\ %&#123;&amp;encoding&#125;\\ %c:%l/%L%)\\&quot; 设置在状态行显示的信息set foldcolumn=0set foldmethod=indent set foldlevel=3 set foldenable &quot; 开始折叠&quot; 不要使用vi的键盘模式，而是vim自己的set nocompatible&quot; 语法高亮set syntax=on&quot; 去掉输入错误的提示声音set noeb&quot; 在处理未保存或只读文件的时候，弹出确认set confirm&quot; 自动缩进set autoindentset cindent&quot; Tab键的宽度set tabstop=4&quot; 统一缩进为4set softtabstop=4set shiftwidth=4&quot; 不要用空格代替制表符set noexpandtab&quot; 在行和段开始处使用制表符set smarttab&quot; 显示行号set number&quot; 历史记录数set history=1000&quot;禁止生成临时文件set nobackupset noswapfile&quot;搜索忽略大小写set ignorecase&quot;搜索逐字符高亮set hlsearchset incsearch&quot;行内替换set gdefault&quot;编码设置set enc=utf-8set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936&quot;语言设置set langmenu=zh_CN.UTF-8set helplang=cn&quot; 我的状态行显示的内容（包括文件类型和解码）&quot;set statusline=%F%m%r%h%w\\ [FORMAT=%&#123;&amp;ff&#125;]\\ [TYPE=%Y]\\ [POS=%l,%v][%p%%]\\ %&#123;strftime(\\&quot;%d/%m/%y\\ -\\ %H:%M\\&quot;)&#125;&quot;set statusline=[%F]%y%r%m%*%=[Line:%l/%L,Column:%c][%p%%]&quot; 总是显示状态行set laststatus=2&quot; 命令行（在状态行下）的高度，默认为1，这里是2set cmdheight=2&quot; 侦测文件类型filetype on&quot; 载入文件类型插件filetype plugin on&quot; 为特定文件类型载入相关缩进文件filetype indent on&quot; 保存全局变量set viminfo+=!&quot; 带有如下符号的单词不要被换行分割set iskeyword+=_,$,@,%,#,-&quot; 字符间插入的像素行数目set linespace=0&quot; 增强模式中的命令行自动完成操作set wildmenu&quot; 使回格键（backspace）正常处理indent, eol, start等set backspace=2&quot; 允许backspace和光标键跨越行边界set whichwrap+=&lt;,&gt;,h,l&quot; 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位）set mouse=aset selection=exclusiveset selectmode=mouse,key&quot; 通过使用: commands命令，告诉我们文件的哪一行被改变过set report=0&quot; 在被分割的窗口间显示空白，便于阅读set fillchars=vert:\\ ,stl:\\ ,stlnc:\\&quot; 高亮显示匹配的括号set showmatch&quot; 匹配括号高亮的时间（单位是十分之一秒）set matchtime=1&quot; 光标移动到buffer的顶部和底部时保持3行距离set scrolloff=3&quot; 为C程序提供自动缩进set smartindent&quot; 高亮显示普通txt文件（需要txt.vim脚本）au BufRead,BufNewFile * setfiletype txt&quot;自动补全:inoremap ( ()&lt;ESC&gt;i:inoremap ) &lt;c-r&gt;=ClosePair(&apos;)&apos;)&lt;CR&gt;:inoremap &#123; &#123;&lt;CR&gt;&#125;&lt;ESC&gt;O:inoremap &#125; &lt;c-r&gt;=ClosePair(&apos;&#125;&apos;)&lt;CR&gt;:inoremap [ []&lt;ESC&gt;i:inoremap ] &lt;c-r&gt;=ClosePair(&apos;]&apos;)&lt;CR&gt;:inoremap &quot; &quot;&quot;&lt;ESC&gt;i:inoremap &apos; &apos;&apos;&lt;ESC&gt;ifunction! ClosePair(char) if getline(&apos;.&apos;)[col(&apos;.&apos;) - 1] == a:char return &quot;\\&lt;Right&gt;&quot; else return a:char endifendfunctionfiletype plugin indent on &quot;打开文件类型检测, 加了这句才可以用智能补全set completeopt=longest,menu&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; CTags的设定 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;let Tlist_Sort_Type = &quot;name&quot; &quot; 按照名称排序 let Tlist_Use_Right_Window = 1 &quot; 在右侧显示窗口 let Tlist_Compart_Format = 1 &quot; 压缩方式 let Tlist_Exist_OnlyWindow = 1 &quot; 如果只有一个buffer，kill窗口也kill掉buffer let Tlist_File_Fold_Auto_Close = 0 &quot; 不要关闭其他文件的tags let Tlist_Enable_Fold_Column = 0 &quot; 不要显示折叠树 autocmd FileType java set tags+=D:\\tools\\java\\tags &quot;autocmd FileType h,cpp,cc,c set tags+=D:\\tools\\cpp\\tags &quot;let Tlist_Show_One_File=1 &quot;不同时显示多个文件的tag，只显示当前文件的&quot;设置tags set tags=tags &quot;set autochdir &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;其他东东&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;默认打开Taglist let Tlist_Auto_Open=1 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; &quot; Tag list (ctags) &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; let Tlist_Ctags_Cmd = &apos;/usr/bin/ctags&apos; let Tlist_Show_One_File = 1 &quot;不同时显示多个文件的tag，只显示当前文件的 let Tlist_Exit_OnlyWindow = 1 &quot;如果taglist窗口是最后一个窗口，则退出vim let Tlist_Use_Right_Window = 1 &quot;在右侧窗口中显示taglist窗口&quot; minibufexpl插件的一般设置let g:miniBufExplMapWindowNavVim = 1let g:miniBufExplMapWindowNavArrows = 1let g:miniBufExplMapCTabSwitchBufs = 1let g:miniBufExplModSelTarget = 1","categories":[{"name":"Configuration","slug":"Configuration","permalink":"https://blog.wzy1999.wang/categories/Configuration/"}],"tags":[]},{"title":"数论模板","slug":"数论","date":"2019-01-18T12:41:00.286Z","updated":"2019-01-21T12:28:21.666Z","comments":true,"path":"template/数论/","link":"","permalink":"https://blog.wzy1999.wang/template/数论/","excerpt":"快速幂相关快速幂（二分幂）时间复杂度：$O(logn)$ 1234567891011int Pow(int a,int b,int c)&#123; int res=1; while(b&gt;0) &#123; if(b&amp;1) res=res*a%c; a=a*a%c; b&gt;&gt;=1; &#125; return res;&#125;//复杂度O(logn)","text":"快速幂相关快速幂（二分幂）时间复杂度：$O(logn)$ 1234567891011int Pow(int a,int b,int c)&#123; int res=1; while(b&gt;0) &#123; if(b&amp;1) res=res*a%c; a=a*a%c; b&gt;&gt;=1; &#125; return res;&#125;//复杂度O(logn) 二分乘法时间复杂度：$O(logn)$ 用途：用来解决乘法的结果远超long long范围，但需要的结果有取余的乘法运算 1234567891011121314151617ll qmul(ll a,ll b,ll m)&#123; ll ans=0; ll k=a; ll f=1;//f是用来存负号的 if(k&lt;0) &#123;f=-1;k=-k;&#125; if(b&lt;0) &#123;f*=-1;b=-b;&#125; while(b)&#123; if(b&amp;1) ans=(ans+k)%m; k=(k+k)%m; b&gt;&gt;=1; &#125; return ans*f;&#125; 快速乘和二分乘法用途一样，时间复杂度为$O(1)$ 1234ll modmul(ll A,ll B,ll Mod)&#123; return (A*B-(ll)((long double)A*B/Mod)*Mod+Mod)%Mod;&#125; 矩阵快速幂其实矩阵快速幂的思想是和快速幂一样的，矩阵快速幂是用于快速求出一个矩阵的 n 次方的方法。 首先，我们要知道，两个矩阵能不能相乘是有一定条件的：假设有两个矩阵 A, B。如果矩阵 A 的列数等于矩阵 B 的行数，那么这两个矩阵才可以进行相乘，否则这两个矩阵是不能相乘的。 矩阵乘法：设$A=(a_{ij})​$是一个$ms​$的矩阵，$B=(b_{ij})​$是一个$sn​$的矩阵，那么规定矩阵A与矩阵B的乘积是一个$m*n​$的矩阵$C=(c_{ij})​$，其中$C_{ij}=a_{i_1}b_{1_j}+a_{i_2}b_{2_j}+…+a_{i_s}b_{s_j}=\\sum _{k=1}^{s}a_{i_k}b_{k_j}(i=1,2…m;j=1,2,…n)​$ 计算矩阵A（规模$ns$）与矩阵B（规模$sm$）相乘后得到$n*m$的矩阵res 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;int a[100][100],b[100][100];int res[100][100];void Matrix_mult(int n,int m,int s)&#123; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) for(int k=0;k&lt;s;k++) res[i][j]+=a[i][k]*b[k][j];&#125;int main(int argc, char const *argv[])&#123; int n,m,s; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;s;j++) cin&gt;&gt;a[i][j]; for(int i=0;i&lt;s;i++) for(int j=0;j&lt;m;j++) cin&gt;&gt;b[i][j]; Matrix_mult(n,m,s); for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) cout&lt;&lt;res[i][j]&lt;&lt;\"\\t\"; cout&lt;&lt;endl; &#125; return 0;&#125; 矩阵快速幂 时间复杂度：$O(logn)$ 计算斐波那契的第N项，并对$1e9+7$取模 对于递推式$F[n]=F[n-1]+F[n-2]$，可构造矩阵：$\\binom{F_{n+2}}{F_{n+1}}=\\begin{pmatrix}1 &amp;1 \\ 1 &amp;0\\end{pmatrix}\\cdot \\binom{F_{n+1}}{F_{n}}$ 对于矩阵快速幂，最主要的是构造矩阵，矩阵构造出来了，答案也就出来了 ps:对于大多数用到矩阵快速幂的题目，也可以用BM算法来解决 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#define ll long longconst int maxn=10;const int mod=1e9+7;using namespace std;struct mart&#123; ll m[100][100];&#125;unit;mart mult(mart a,mart b)&#123; mart ans; int x; for(int i=0;i&lt;4;i++) &#123; for(int j=0;j&lt;4;j++) &#123; x=0; for(int k=0;k&lt;4;k++) x=(x%mod+(a.m[i][k]%mod*b.m[k][j]%mod)%mod)%mod; ans.m[i][j]=x%mod; &#125; &#125; return ans;&#125;void init()&#123; for(int i=0;i&lt;4;i++) unit.m[i][i]=1;&#125;mart qpow(mart a,ll b)&#123; init(); mart ans=unit; while(b) &#123; if(b&amp;1) ans=mult(ans,a); a=mult(a,a); b&gt;&gt;=1; &#125; return ans;&#125;ll slove(ll n)&#123; mart a,b; a.m[0][0]=1; a.m[0][1]=1; a.m[1][0]=1; a.m[1][1]=0; b.m[0][0]=1; b.m[1][0]=0; mart c=mult(qpow(a,n-2),b); return c.m[0][0]%mod;&#125;int main(int argc, char const *argv[])&#123; ll n; cin&gt;&gt;n; if(!n) cout&lt;&lt;0&lt;&lt;endl; else cout&lt;&lt;slove(n+1)&lt;&lt;endl; return 0;&#125; GCD、LCM、EXGCD、CRT相关GCD实现原理：辗转相除法 时间复杂度：$O(log_2n)$ 1234567891011121314151617// 递归写法int gcd1(int a,int b)&#123; return b?gcd1(b,a%b):a;&#125;// 非递归int gcd2(int a,int b)&#123; int t; while(b) &#123; t=a; a=b; b=t%b; &#125; return a;&#125; LCM公式：$LCM(a,b)=a*b/GCD(a,b)$ 1234int lcm(int a,int b)&#123; return a/gcd*b;//这样写可以在一定程度上防止数据溢出&#125; EXGCD用途：一般用来求解不定方程，求解线性同余方程，求解模的逆元等 如求解二元一次方程：$ax+by=c$，（a，b均为正整数，取最小正整数解） 存在x，y，使得$gcd(a,b)=ax+by$ 注意：返回值为a和b的最大公约数，最后的x，y可以直接调用 1234567891011121314int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; // 无最大公约数 if(a==0&amp;&amp;b==0) return -1; if(b==0) &#123; x=1;y=0; return a; &#125; int d=exgcd(b,a%b,y,x); y-=a/b*x; return d;&#125; 例题：设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define LL long long #define INF 0x3f3f3f3f#define PI acos(-1.0)using namespace std;LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y)&#123; if(!b) &#123; x=1; y=0; return a; &#125; LL r=exgcd(b,a%b,x,y); LL t=y; y=x-(a/b)*y; x=t; return r;&#125;int main()&#123; LL a,b,x,y,n,m,l,k1,k2;//k2就是方程的一个x的解 cin&gt;&gt;x&gt;&gt;y&gt;&gt;m&gt;&gt;n&gt;&gt;l; LL d=x-y; a=l; b=n-m; LL c=exgcd(a,b,k1,k2);//c是最大公约数 if(d%c)//方程有解的条件 printf(\"Impossible\"); else&#123; LL s=k2*d/c; LL v=a/c;//对结果取余的最小的范围 printf(\"%lld\\n\",(s%v+v)%v); &#125; return 0;&#125; 中国剩余定理（CRT）问题：今有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？ 定理1：几个数相加，如果存在一个加数，不能被整数a整除，那么它们的和，就不能被整数a整除。 定理2：两数不能整除，若除数扩大（或缩小）了几倍，而被除数不变，则其商和余数也同时扩大（或缩小）相同的倍数（余数必小于除数）。 简单的说就是求$M\\%A=a,M\\%B=b,M\\%C=c…$的M，其中A、B、C……互质 123456789101112131415161718192021222324252627282930//chu是除数，yu是余数//注意只适用于除数两两互质#define ll long longint ex_gcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123; ll d; if(b == 0) &#123; x = 1; y = 0; return a; &#125; d = ex_gcd(b, a % b, y, x); y -= a / b * x; return d;&#125;ll chinese_remainder(ll b[], ll w[], ll len) &#123; ll i, d, x, y, m, n, ret; ret = 0; n = 1; for(i=0; i &lt; len ;i++) n *= w[i]; for(i=0; i &lt; len ;i++) &#123; m = n / w[i]; d=ex_gcd(w[i], m, x, y); ret = (ret + y*m*b[i]) % n; &#125; return (n + ret%n) % n;&#125; 中国剩余定理扩展求$M\\%A=a,M\\%B=b,M\\%C=c…$的M，其中A、B、C……不互质 1234567891011121314151617181920212223242526272829ll a[maxn],b[maxn];//a是除数，b是余数ll ex_gcd(ll a,ll b,ll &amp;x,ll &amp;y) &#123; ll d; if(b==0) &#123; x=1; y=0; return a; &#125; d=ex_gcd(b,a%b,y,x); y-=a/b*x; return d;&#125;ll ex_crt(ll *a, ll *b, int n)&#123; ll M=a[1],R=b[1],x,y; for (int i=2;i&lt;=n;i++) &#123; ll d=ex_gcd(M,a[i],x,y); if((b[i]-R)%d) return -1; x=(b[i]-R)/d*x%(a[i]/d); R+=x*M; M=M/d*a[i]; R%=M; &#125; return R&gt;0?R:R+M;&#125; 欧拉函数、元根相关欧拉定理：若$n,a$为正整数，且$n,a$互质，则：$a^{φ(n)}\\equiv1(mod n)$；即：$a^{φ(n)}$与1在模$m$下同余。 欧拉定理实际上是费马小定理的推广 欧拉函数对于正整数N,少于或等于N ([1,N]),且与N互质的正整数(包括1)的个数，记作$φ(n)$。欧拉函数公式：$φ(N)=N(1-1/P1)(1-1/P2)…(1-1/Pn)$ 直接求： 12345678910111213141516int Eular(int n)&#123; int eu=n; for (int i=2;i*i&lt;=n;i++) &#123; if(n%i==0) &#123; eu-=eu/i; while(n%i==0) n/=i; &#125; &#125; if(n&gt;1) //n本身也是个质因子 eu-=eu/n; return eu; &#125; 打表求 12345678910void Eular()&#123; euler[1]=1; for(int i=2;i&lt;maxn;i++) euler[i]=i; for(int i=2;i&lt;maxn;i++) if(euler[i]==i) for(int j=i;j&lt;maxn;j+=i) euler[j]=euler[j]/i*(i-1);//先进行除法是为了防止中间数据的溢出&#125; 原根定义：对于两个正整数$(a,m)=1$，由欧拉定理可知：存在$d\\leq m-1$。比如说欧拉函数$d=φ(m)$，即小于等于$m$的正整数与$m$互质的正整数的个数，使得$a^d\\equiv1 (mod m)$。由此，在$(a,m)=1$时，定义$a$对模$m$的指数$\\delta m(a)$为使$a^d\\equiv1(mod m)$成立的最小正整数$d$。由前知$\\delta m(a)$一定小于等于$φ(m)$，若$\\delta m(a)=φ(m)$，则称$a$为$m$的原根 应用一：求一个素数的最小的原根 m是正整数，a是正数，若$a\\%m$的阶等于$φ(m)$，则a为模m的一个元根（$φ(m)$表示m的欧拉函数） 给出一个素数p，找出p最小的元根 我的理解：找到最小的数x，使得$x^{ϕ(n)}\\%n=1$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;const int maxn=1e6+10;#define ll long longusing namespace std;int p[maxn];int k;ll Pow(ll a,ll b,ll c)&#123; ll res=1; while(b) &#123; if(b&amp;1) res=res*a%c; b&gt;&gt;=1; a=a*a%c; &#125; return res;&#125;// 查找n的素因子void getp(ll n)&#123; for(int i=2;i*i&lt;=n;i++) &#123; if(n%i==0) &#123; p[k++]=i; while(n%i==0) n/=i; &#125; &#125; if(n&gt;1) p[k++]=n;&#125;int main(int argc, char const *argv[])&#123; ios::sync_with_stdio(false); ll n; cin&gt;&gt;n; k=0; // 素数的欧拉函数值为n-1 // 对欧拉值进行分解 getp(n-1); for(int i=2;i&lt;n;i++) &#123; int flag=0; for(int j=0;j&lt;k;j++) &#123; if(Pow(i,(n-1)/p[j],n)==1) &#123; flag++; break; &#125; &#125; if(!flag) &#123; cout&lt;&lt;i&lt;&lt;endl; return 0; &#125; &#125; return 0;&#125; 应用二：求原根的个数 定理：如果$p$有原根，则它恰有$φ(φ(p))$个不同的原根，$p$为素数时，$φ(p)=p-1$,因此就有$φ(p-1)$个原根 对应题目：POJ1284 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;int Eular(int n)&#123; int eu=n; for (int i=2;i*i&lt;=n;i++) &#123; if(n%i==0) &#123; eu-=eu/i; while(n%i==0) n/=i; &#125; &#125; if(n&gt;1) //n本身也是个质因子 eu-=eu/n; return eu; &#125;int main(int argc, char const *argv[])&#123; int p; while(cin&gt;&gt;p) &#123; cout&lt;&lt;Eular(p-1)&lt;&lt;endl; &#125; return 0;&#125; 素数相关埃拉托斯特尼篩法时间复杂度：$O(nloglog(n))$，空间复杂度$O(n)$ 123456789101112// 素数标记为0，非素数标记为1inline void init()&#123; memset(vis,0,sizeof(vis)); vis[0]=vis[1]=1; for(int i=2;i&lt;maxn;i++) &#123; if(!vis[i]) for(int j=2;j*i&lt;maxn;j++) vis[j*i]=1; &#125;&#125; 欧拉筛法线性筛法，拿空间换时间 时间复杂度：$O(n)$ 1234567891011121314151617181920int vis[maxn];int prime[maxn];//用来存储素数int cnt;//素数个数inline void init()&#123; memset(vis,0,sizeof(vis)); memset(prime,0,sizeof(prime)); cnt=0; for(int i=2;i&lt;maxn;i++) &#123; if(!vis[i]) prime[cnt++]=i; for(int j=0;i*prime[j]&lt;n;j++) &#123; vis[i*prime[j]]=1; if(i%prime[j]==0) break; &#125; &#125;&#125; 筛素数+欧拉函数打表 12345678910111213141516171819202122232425262728293031323334 /* * 同时得到欧拉函数和素数表 */bool check[maxn+10];int phi[maxn+10];int prime[maxn+10];int tot; // 素数个数inline void phi_and_prime_table(int N)&#123; memset(check,false,sizeof(check)); phi[1]=1; tot=0; for(int i=2;i&lt;=N;i++) &#123; if(!check[i]) &#123; prime[tot++]=i; phi[i]=i-1; &#125; for(int j=0;j&lt;tot;j++) &#123; if(i*prime[j]&gt;N) break; check[i*prime[j]]=true; if (i%prime[j]==0) &#123; phi[i*prime[j]]=phi[i]*prime[j]; break; &#125; else phi[i*prime[j]]=phi[i]*(prime[j]-1); &#125; &#125;&#125; 唯一分解定理定义：每个大于1的自然数，若不是本身就是质数，就是可写为2个以上的质数的积，而且这些质因子按大小排列之后，写法仅有一种方式 唯一分解定理具有：唯一性（分配方式的唯一性）；存在性 例如：$6936=2^3\\times3\\times17^3$，$1200=2^4\\times3\\times5^2$ 即：对于任一大于$1$的正整数$n$，都可以唯一分解成有限个质数的乘积：$n=p^{a_{1}}_{1}p^{a_{2}}_{2}\\ldots p^{a}_{k}=\\prod ^{k}_{i=1}p^{a_{i}}_{i}$（这里$p_i$为素数，其对应的指数$a_i$为正整数） 求质因子及其个数描述：给出一个数字n，求它的质因子及其个数，写成形如：n=p1^a1 + p2^a2…..的形式 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6+10;int a[maxn];int an[maxn];int num;void Prime_num(int n)&#123; memset(a,0,sizeof(a)); memset(an,0,sizeof(an)); num=0; for(int i=2;i*i&lt;=n;i++) &#123; if(n%i==0) &#123; while(n%i==0) &#123; a[num]=i; n/=i; an[num]++; &#125; num++; &#125; &#125; if(n!=1) &#123; a[num]=n; an[num++]++; &#125;&#125;int main()&#123; int n; while(scanf(\"%d\",&amp;n)!=EOF) &#123; Prime_num(n); printf(\"%d的质因子的个数有%d个\\n\",n,num); printf(\"%d=\",n); for(int i=0;i&lt;num-1;i++) printf(\"%d^%d * \",a[i],an[i]); printf(\"%d^%d\\n\",a[num-1],an[num-1]); &#125; return 0;&#125; 约数个数定理根据唯一分解定理：$n=\\prod ^{k}_{i=1}p^{a_{i}}_{i}$，可知n的正约数个数为：$f\\left( n\\right) =\\prod ^{k}_{i=1}\\left( a_{i}+1\\right)$ 例如：求278000的约数个数 首先对278000进行质因数分解：$278000=2^4\\times3^3\\times5^3\\times7^1$ 然后可以计算出278000的约数个数共有$(4+1)\\times(3+1)\\times(1+1)=40$个 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;int prime[maxn],nprime; int vis[maxn]; void getprime()&#123; nprime = 0; memset(vis,0,sizeof(vis)); for(int i = 2; i &lt;= maxn; i++) &#123; int t = maxn/i; for(int j = 2; j &lt;=t; j++) vis[i*j] = 1; &#125; for(int i = 2; i &lt;= maxn; i++) if(!vis[i]) prime[nprime++] = i; &#125; int factor_count(int n)&#123; int ans = 1,sum; int k = sqrt(n*1.0); for(int i = 0; prime[i] &lt; k; i++) &#123; if(n % prime[i] == 0) &#123; sum = 0; while(n % prime[i] == 0) &#123; sum++; n /= prime[i]; &#125; ans *= (sum+1); //ans为n的约数的个数 &#125; &#125; if(n &gt; 1) ans *= 2; return ans; &#125;int main(int argc, char const *argv[])&#123; int n; cin&gt;&gt;n; getprime(); printf(\"%d的约数一共有%d个\\n\",n,factor_count(n)); return 0;&#125; 给出$x,y$，求$x^y$的因子个数对10007取模的结果 公式：$x^y=(p_1^{e_1}p_2^{e_2}…p_k^{e_k})^y=p_1^{ye_1}p_2^{ye_2}…p_k^{ye_k}$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define LL long longusing namespace std;const int MAX = 1e6+10;const int INF = 0x3fffffff;int a[MAX];int an[MAX];int num;void Prime_num(int n)&#123; memset(a,0,sizeof(a)); memset(an,0,sizeof(an)); num=0; for(int i=2;i*i&lt;=n;i++) &#123; if(n%i==0)&#123; while(n%i==0) &#123; a[num] = i; n/=i; an[num]++; &#125; num++; &#125; &#125; if(n!=1) &#123; a[num] = n; an[num++] ++; &#125;&#125;int main()&#123; int n,b; while(scanf(\"%d%d\",&amp;n,&amp;b)!=EOF) &#123; Prime_num(n); printf(\"%d的质因数个数有%d个\\n\",n,num); printf(\"%d = \",n); for(int i=0;i&lt;num-1;i++) printf(\"%d^%d * \",a[i],an[i]); printf(\"%d^%d\\n\",a[num-1],an[num-1]); for(int i=0;i&lt;num;i++) an[i] *= b; LL ans =1; for(int i=0;i&lt;num;i++) ans *= (an[i]+1); printf(\"%d^%d的约数个数对10007取模后的结果为：%lld\\n\",n,b,ans); &#125; return 0;&#125; 约数和定理对于一个大于1正整数n可以分解质因数：$n=p_1^{a_1}\\times p_2^{a_2}\\times p_3^{a_3}\\times …\\times p_k^{a_k}$,则由约数个数定理可知n的正约数有$(a_1+1)(a_2+1)(a_3+1)…(a_k+1)$个，那么n的(a₁+1)(a₂+1)(a₃+1)…(ak+1)个正约数的和为$f(n)=(p_1^0+p_1^1+p_1^2+…p_1^a1)(p_2^0+p_2^1+p_2^2+…p_2^a2)…(p_k^0+p_k^1+p_k^2+…p_k^ak)$ 123456789101112131415161718192021222324252627282930313233343536373839404142int prime[maxn],nprime;int vis[maxn];void getprime()&#123; nprime = 0; memset(vis,0,sizeof(vis)); for(int i = 2; i &lt;= 450; i++)&#123; int t = 450/i; for(int j = 2; j &lt;=t; j++) vis[i*j] = 1; &#125; for(int i = 2; i &lt;= 450; i++)&#123; if(!vis[i]) prime[nprime++] = i; &#125;&#125;int pow_mod(int a,int n,int MOD)&#123; int ans = 1; while(n)&#123; if(n&amp;1) ans = (ans*a)%MOD; n &gt;&gt;= 1; a = (a*a)%MOD; &#125; return ans;&#125;int factor_sum(int n)&#123; int ans = 1,sum; int k = sqrt(n*1.0); for(int i = 0; prime[i] &lt; k; i++)&#123; if(n % prime[i] == 0)&#123; sum = 0; while(n%prime[i] == 0)&#123; sum++; n /= prime[i]; &#125; ans *= (pow_mod(prime[i],sum+1,MOD)-1)/(prime[i]-1); &#125; &#125; if(n &gt; 1) ans *= ans(n*n-1)/(n-1); return ans;&#125; 组合数相关12345678910111213141516//求组合数 C(a, b)int C(int a,int b)&#123; int sum=1; for(int i=1;i&lt;=b;i++) sum=sum*(a+1-i)/i; return sum;&#125;//求排列数 A(a, b)int A(int a,int b)&#123; int sum=1; for(int i=0;i&lt;b;i++) sum=sum*(n-i); return sum;&#125; 卢卡斯定理求组合数表达式：$C_n^m\\%mod=C_{n/p}^{m/p}\\times C_{n\\%mod}^{m\\%mod}\\%mod$ 递推式：$(C_{n\\%mod}^{m\\%mod}\\times Lucas(n/p,m/p))\\%mod$（递归出口为$m==0$，$return 1$） 注意：mod必须为质数 123456789101112131415161718192021222324252627282930313233343536373839404142434445//求 C（r, n）% MOD//数据范围： 0 &lt;= r、n &lt;= 1e5#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e5+10;ll n,m,MOD;//题目保证了MOD为质数ll fac[maxn];ll pow(ll a,ll b)&#123; ll r=1,base=a%MOD; while(b) &#123; if(b&amp;1) r=r*base%MOD; base=base*base%MOD; b&gt;&gt;=1; &#125; return r%MOD;&#125;void init()&#123; fac[0]=1; for(ll i=1;i&lt;=maxn;i++) fac[i]=fac[i-1]*i%MOD;&#125;ll C(ll n,ll m)&#123; if(n&lt;m) return 0; return fac[n]*pow(fac[m]*fac[n-m],MOD-2)%MOD;&#125;ll Lucas(ll n,ll m)&#123; if(!m) return 1; else return Lucas(n/MOD,m/MOD)%MOD*C(n%MOD,m%MOD)%MOD;&#125;int main(int argc, char const *argv[])&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;MOD; init(); cout&lt;&lt;Lucas(n,m)&lt;&lt;endl; return 0;&#125; 拓展卢卡斯定理$1\\leq m\\leq n\\leq1e18$，$2\\leq mod\\leq1e6$，不保证$mod$是素数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll p;const int MAXN=11;ll n,m;ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(!b) &#123; x=1; y=0; return a; &#125; ll res=exgcd(b,a%b,x,y),t; t=x;x=y;y=t-a/b*y; return res;&#125;ll power(ll a,ll b,ll mod)&#123; ll sm; for(sm=1;b;b&gt;&gt;=1,a=a*a%mod) if(b&amp;1) sm=sm*a%mod; return sm;&#125;ll fac(ll n,ll pi,ll pk)&#123; if(!n) return 1; ll res=1; for(ll i=2;i&lt;=pk;++i) if(i % pi) (res*=i)%=pk; res=power(res,n/pk,pk); for(ll i=2;i&lt;=n%pk;++i) if(i%pi) (res*=i)%=pk; return res*fac(n/pi,pi,pk)%pk;&#125;ll inv(ll n,ll mod)&#123; ll x,y; exgcd(n,mod,x,y); return (x+=mod)&gt;mod?x-mod:x;&#125;ll CRT(ll b, ll mod)&#123; return b*inv(p/mod,mod)%p*(p/mod)%p;&#125;ll C(ll n,ll m,ll pi,ll pk)&#123; ll up=fac(n,pi,pk),d1=fac(m,pi,pk),d2=fac(n-m,pi,pk); ll k=0; for(ll i=n;i;i/=pi) k+=i/pi; for(ll i=m;i;i/=pi) k-=i/pi; for(ll i=n-m;i;i/=pi) k-=i/pi; return up*inv(d1,pk)%pk*inv(d2,pk)%pk*power(pi,k,pk)%pk;&#125;ll exlucus(ll n,ll m)&#123; ll res=0,tmp=p,pk; int lim=sqrt(p)+5; for(int i=2;i&lt;=lim;++i) if(tmp%i==0) &#123; pk=1; while(tmp%i==0) pk*=i,tmp/=i; (res+=CRT(C(n,m,i,pk),pk))%=p; &#125; if(tmp&gt;1) (res+=CRT(C(n,m,tmp,tmp),tmp))%=p; return res;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;p; cout&lt;&lt;exlucus(n,m)&lt;&lt;endl; return 0;&#125; 容斥定理描述：要计算几个集合并集的大小，我们要先将所有单个集合的大小计算出来，然后减去所有两个集合相交的部分，再加回所有三个集合相交的部分，再减去所有四个集合相交的部分，依此类推，一直计算到所有集合相交的部分。 公式：$\\sum _ { 1 \\leq i \\leq m } \\left| A _ { i } \\right| - \\sum _ { 1 \\leq i &lt; j \\leq m } \\left| A _ { i } \\cap A _ { j } \\right| + \\sum _ { 1 \\leq i &lt; j &lt; k \\leq m } \\left| A _ { i } \\cap A _ { j } \\cap A _ { k } \\right| - \\cdots + ( - 1 ) ^ { m - 1 } \\left| A _ { 1 } \\cap A _ { 2 } \\cap \\cdots \\cap A _ { m } \\right|$ 公式的解释：目的是求解m个集合的并集，首先将m个集合相加，减去集合间两两相交的部分，加上三三相交的部分，再减去四四相交的部分……一直到m个集合相交的部分，当m为偶数时，最后一项的符号为负数，否则为正数。 应用一： 计算$1 \\sim n$之间不能整除2,5,7的正整数有多少个 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main(int argc, char const *argv[])&#123; int n; cin&gt;&gt;n; int a=n/2; int b=n/5; int c=n/7; int d=n/(2*5); int e=n/(2*7); int f=n/(5*7); int g=n/(2*5*7); int ans=n-(a+b+c-d-e-f+g); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 应用二： 计算$1 \\sim n$之间不能整除a,b,c的正整数有多少个（应用一的升级版，对应NYOJ1160） 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll lcm(ll a,ll b)&#123; return a/__gcd(a,b)*b;&#125;int main(int argc, char const *argv[])&#123; ll n,a,b,c; while(cin&gt;&gt;n&amp;&amp;n) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; ll _a=n/a; ll _b=n/b; ll _c=n/c; ll d=n/(lcm(a,b)); ll e=n/(lcm(a,c)); ll f=n/(lcm(b,c)); ll g=n/(lcm(a,lcm(b,c))); ll ans=n-(_a+_b+_c-d-e-f+g); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 与二进制结合的容斥定理二进制枚举的模板 12345678int n; for(int i=0;i&lt;(1&lt;&lt;n);i++)&#123; // 相当于枚举所有的情况 o(2^n*n) for(int j = 0; j &lt; n ;j++) &#123; printf(\"%d \",(i&gt;&gt;j)&amp;1); &#125;&#125; 应用一：求$[a,b]$区间与$n$互质的数的个数（对应题目：HDU4135） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;#define ll long longconst int maxn=1e6+10;using namespace std;int A[maxn];ll lcm(ll a,ll b)&#123; return a/__gcd(a,b)*b;&#125;int main(int argc, char const *argv[])&#123; int t; ll a,b,n; scanf(\"%d\",&amp;t); int x=0; while(t--) &#123; ll ans1,ans; ans=ans1=0; map&lt;int,int&gt;mmp;//记录质因子 scanf(\"%lld%lld%lld\",&amp;a,&amp;b,&amp;n); ll m=n; int k=0; for(int i=2;i*i&lt;=m;i++) &#123; if(m%i==0) &#123; while(m%i==0) &#123; if(mmp[i]==0) &#123; A[k++]=i; mmp[i]=1; &#125; m/=i; &#125; &#125; &#125; if(m&gt;1) &#123; A[k++]=m; mmp[m]=1; &#125; for(int i=1;i&lt;(1&lt;&lt;k);i++) &#123; int cnt=0; ll tmp=1; for(int j=0;j&lt;k;j++) &#123; if(i&gt;&gt;j&amp;1) &#123; cnt++; tmp=lcm(tmp,A[j]); &#125; &#125; if(cnt&amp;1) &#123; ans+=(a-1)/tmp; ans1+=(b)/tmp; &#125; else &#123; ans-=(a-1)/tmp; ans1-=b/tmp; &#125; &#125; printf(\"Case #%d: %lld\\n\",++x,(b-a+1)-ans1+ans); &#125; return 0;&#125; 应用二：求$[1,n]$中与$n$互质的数的平方和 平方和公式：$\\sum ^{n}_{i=1}i^{2}=\\dfrac {n\\left( n+1\\right) \\left( 2n+1\\right) }{6}$不互质平方和为：$\\sum ^{n}_{k=1}\\left( k\\ast m\\right) ^{2}=m^{2}\\sum ^{\\dfrac {n}{m}}_{k=1}k^{2}=m^{2}\\dfrac {\\dfrac {n}{m}\\left( \\dfrac {n}{m}+1\\right) \\left( 2\\dfrac {n}{m}+1\\right) }{6}$ 把n进行质因子分解，进行容斥，结果=总和-不互质的平方和 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt; #include &lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn = 1e6 + 10;LL arr[maxn];int p;LL get(LL x, LL y) &#123; LL cnt = x / y; //这里return的是推出来的公式 return ((y * y) * (cnt * (cnt + 1) * (2 * cnt + 1) / 6));&#125;void getp(LL n) &#123; //分解质因子 p = 0; for(int i = 2; i * i &lt;= n; i++) &#123; if(n % i == 0) &#123; arr[p++] = i; while(n % i == 0) n /= i; &#125; &#125; if(n &gt; 1) arr[p++] = n;&#125;int main() &#123; LL n; while(scanf(\"%lld\", &amp;n) != EOF) &#123; if(n == 0 || n == 1) &#123; puts(\"0\"); continue; &#125; getp(n); LL sum = n * (n + 1) * (2 * n + 1) / 6; LL ans = 0; for(int i = 1; i &lt; (1 &lt;&lt; p); i++) &#123; //状压 LL res = 0, cnt = 1; for(int j = 0; j &lt; p; j++) &#123; if(i &amp; (1 &lt;&lt; j)) &#123; cnt *= arr[j]; res++; &#125; &#125; if(res &amp; 1) ans += get(n, cnt); //容斥 else ans -= get(n, cnt); &#125; printf(\"%lld\\n\", sum - ans); &#125; return 0;&#125; 鸽巢原理（抽屉原理）描述： 若有$n$个笼子和$n+1$只鸽子，所有的鸽子都被关在鸽笼里，那么至少有一个笼子有至少$2$只鸽子。 若有$n$个笼子和$kn+1$只鸽子，所有的鸽子都被关在鸽笼里，那么至少有一个笼子有至少$k+1$只鸽子。 解题关键：弄清题目中，谁是鸽子谁是巢 例题题1：证明，如果从$\\{1,2,3,….3n\\}$中选择$n+1$个整数，那么总存在两个整数，他们之间的差最多为$2$。 解：分组化简。将这$3n$个整数分组，$\\{1,2,3\\}$，$\\{4,5,6\\}$…..$\\{3n-2,3n-1,3n\\}$ 共$n$组。这样题目等价于：将$n+1$个整数放在$n$个盒子里。则根据原理，至少存在一个盒子里有两个数，这两个数之差最多为2。 题2：证明，对于任意给定的52个整数，存在其中的两个整数，要么两者的和能被100整除。要么两者的差能被100整除。 解：还是分组化简！将数这样进行分组：将所有整数的后两位尾数分组。$\\{+0,-0,+100,-100,+200,-200….\\}$，$\\{+1,-1,+99,-99,+101,-101,+199,-199,+201,-201……\\}$……$\\{+49,-49,+51,-51,+149,-149,+151,……\\}$$\\{+50,-50,+150,-150,+250,-250……\\}$ 这样。将所有的能被$100$整数的数分为$51$组（鸽子）。而从中取$52$个，（巢）。必有两个在同一组。得证。 题3：一个学生有$37$天来准备考试，她知道她需要不超过$60$小时的学习时间，她还希望每天至少学习$1$小时。证明，无论如何安排学习时间（每天都是整数小时），都存在连续的若干天，在此期间她恰好学习了$13$个小时。 证明：令$a_1$为她第一天学习的小时数，$a_2$为第二天的学习时数。这样。存在这样一个递增数列$a_1,a_2,a_3,……a_{37}$。满足：$1\\leq a_1&lt;a_2&lt;a_3……a_{37}\\leq 60$。同时，将这个数列每个数都加上13。则存在数列：$14\\leq a1+13&lt;a2+13&lt;a3+13……a37+13\\leq 73$。而这两个数列共有$37+37=74$个成员。这样。鸽子和巢终于出现^_^必然存在一个$a_i$,和一个$a_j$.使得$a_i=a_j+13$.就是说这两个数列中必然有两个差为$13$的数。得证。 题4：一个袋子装了$100$个苹果，$100$个香蕉，$100$个橘子，$100$个梨子。如果我们每分钟从袋子里取出$1$种水果，那么需要多少时间我就能肯定至少已经拿出1打相同种类的水果。 解：根据鸽巢原理加强形式：如果$q_1,q_2,,,,,q_n$为正整数，将$q_1+q_2+…..q_n-n+1$个物体放入$n$个盒子里。那么，至少存在一个盒子含有$q_n$个物体。对于此题：我们需要取$12$个水果。设已经取出了$11$个水果，还剩下一个。那么需要$11\\times4+1$分钟。 题5：证明对于任意$n+1$个整数$a_1,a_2,…..a_{n+1}$存在两个整数$a_i和a_j$，$i\\neq j$，使得$a_i-a_j$能够被$n$整除。 解：由于任一整数被n整除的余数有$0,1,2,……n-1$。 共$n$种，对于$n+1$个数，由鸽巢原理可得证。即存在$a_i,a_j$。$a_i=b_n+r,a_j=c_n+r (b&gt;c)$。$a_i-a_j=(b-c)n$。所以$n|a_i-a_j$。至少两个整数被$n$整除的余数相等。 题6：证明，边长为$2$的正方形中取$5$个点，当中存在$2$个点，这$2$点的距离至多为$\\sqrt2$ 解：将正方形分成四等分即可。 Ramsey定理（拉姆齐二染色定理）描述：在$6$个人中，总有$3$个人互相认识或互相皆不认识 应用：要找这样一个最小的数$R(k,l)=n$，使得$n$个人中必定有$k$个人相识或$l$个人互不相识 一些非平凡Ramsey数： R(3, 3) = 6R(3, 4) = 9R(3, 5) = 14R(3, 6) = 18R(3, 7) = 23R(3, 8) = 28R(3, 9) = 3640&lt;=R(3, 10)&lt;=43R(4,4) = 18R(4,5) = 2543&lt;=R(5,5)&lt;=5 卡特兰数应用： （1）一个栈(无穷大)的进栈序列为$1，2，3，…，n$，有多少个不同的出栈序列?（2）在$n\\times n$的格子中，只在下三角行走，每次横或竖走一格，有多少中走法？（3）将一个凸$n+2$边形区域分成三角形区域的方法数？（4）圆上选择$2n$个点,将这些点成对连接起来使得所得到的$n$条线段不相交的方法数？（5）有$2n$个人排成一行进入剧场。入场费$5$元。其中只有$n$个人有一张5元钞票，另外$n$人只有$10$元钞票，剧院无其它钞票，问有多少中方法使得只要有$10$元的人买票，售票处就有5元的钞票找零？ 公式：$h\\left( n\\right) =\\dfrac {C^{n}_{2n}}{n+1} \\left(n= 1,2,3\\ldots \\right) $或$h\\left( n\\right) =C^{n}_{2n}-C^{n-1}_{2n} \\left(n= 1,2,3\\ldots \\right) $ 代码一：大数版本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include&lt;string.h&gt;int a[105][1000];//大数运算 int b[105]; //储存对应卡特兰数有多少位 void catalan() //求卡特兰数&#123; int i, j, len, carry, temp; a[1][0] = b[1] = 1; len = 1; for(i = 2; i &lt;= 100; i++) &#123; for(j = 0; j &lt; len; j++) //乘法 a[i][j] = a[i-1][j]*(4*(i-1)+2); carry = 0; for(j = 0; j &lt; len; j++) //处理相乘结果 &#123; temp = a[i][j] + carry; a[i][j] = temp % 10; carry = temp / 10; &#125; while(carry) //进位处理 &#123; a[i][len++] = carry % 10; carry /= 10; &#125; carry = 0; for(j = len-1; j &gt;= 0; j--) //除法 &#123; temp = carry*10 + a[i][j]; a[i][j] = temp/(i+1); carry = temp%(i+1); &#125; while(!a[i][len-1]) //高位零处理 len --; b[i] = len; &#125;&#125; int main() &#123; catalan(); for(int i=1;i&lt;=100;i++) &#123; for(int j=b[i]-1;j&gt;=0;j--) &#123; printf(\"%d\",a[i][j]); &#125; printf(\"\\n\"); &#125;&#125; 代码二：正常取模版本 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define ll long long#define ms(a) memset(a,0,sizeof(a))const int N=1e4+10;const ll Mod=19260817;using namespace std;ll fat[N];ll inv[N];ll finv[N];ll n;void Init()&#123; ll i; for(i=2,inv[1]=1;i&lt;N;i++) inv[i]=((Mod - Mod/i)*1ll*inv[Mod%i])%Mod; for(i=1,fat[0]=1,finv[0]=1;i&lt;N;i++) &#123; fat[i]=(fat[i-1]*i)%Mod; finv[i]=(finv[i-1]*inv[i])%Mod; &#125;&#125;ll C(ll n,ll m)&#123; ll res=1; res=res*fat[n]%Mod; res=(res*finv[m]%Mod*finv[n-m]%Mod); return res;&#125;ll Ctl(ll n)&#123; return (C(2*n,n)-C(2*n,n-1)+Mod)%Mod;&#125;int main(int argc, char const *argv[])&#123; ios::sync_with_stdio(false); Init(); while(cin&gt;&gt;n) cout&lt;&lt;Ctl(n)&lt;&lt;endl; return 0;&#125; 环涂色问题题目描述：如下图，有$m(m\\geq2)$个区域，如果给你$n(n\\geq3)$种颜色，给这$m$个区域涂色，要求相邻的区域颜色不能一样，问一共有几种涂法 公式：$f(m)=(-1)^m\\times (n-1)+(n-1)^m$ 阶乘问题大数阶乘代码一： 计算$1e6$以内的数的阶乘即位数 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;int main() &#123; int carry; //进位 int n,j; int a[40001]; //保存结算结果的数组 int digit; //结果的最高位 int temp,i; while(scanf(\"%d\",&amp;n)!=EOF) &#123; a[0]=1;digit=1; for(i=2; i&lt;=n; i++) &#123; for(carry=0,j=1; j&lt;=digit; ++j) &#123; temp=a[j-1]*i+carry; //计算结果 a[j-1]=temp%10; //计算结果 carry=temp/10; //计算进位 &#125; while(carry) &#123; a[++digit-1]=carry%10; //取当前位 carry/=10; //计算进位 &#125; &#125; for(int k=digit; k&gt;=1; --k) printf(\"%d\",a[k-1]); printf(\"\\n\"); printf(\"length=%d\\n\",digit); &#125; return 0;&#125; 代码二： 计算$1e4$以内的数的阶乘 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll l=1e14;const int maxn=20000;ll f[maxn+1];int main()&#123; ll n,c; ll d=1; scanf(\"%lld\",&amp;n); memset(f,0,sizeof(f)); f[0]=1; for(int i=1;i&lt;=n;i++) &#123; c=0; for(int j=0;j&lt;d;j++) &#123; ll s=f[j]*i+c; f[j]=s%l; c=s/l; &#125; if(c) f[d++]=c; &#125; printf(\"%lld\",f[d-1]); for(int j=d-2;j&gt;=0;j--) printf(\"%014lld\",f[j]); printf(\"\\n\"); return 0;&#125; 斯特林公式应用：用来求$n!$的近似值 公式为：$\\lim _{n\\rightarrow \\infty }\\left( \\dfrac {n}{\\pi }\\right) ^{n}\\sqrt {\\dfrac {2\\pi n}{n!}}=1$，可以得出：$n!\\approx \\sqrt {2\\pi n}\\left( \\dfrac {n}{e}\\right) ^{n}$ 计算$n!$的长度公式：$len=\\dfrac {\\lg 2\\pi n}{2}+n\\lg \\dfrac {n}{e}+1$（$len$向下取整） 代码： 12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;#define pi acos(-1.0) const double E=exp(1);int main()&#123; int t; int n; cin&gt;&gt;n; long long ans=1+0.5*log10(2*pi*n)+n*log10(n/E); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 阶乘最后非$0$位复杂度：$O(nlogn)$ 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define maxn 10000int lastdigit(char buf[])&#123; const int mod[20]=&#123;1,1,2,6,4,2,2,4,2,8,4,4,8,4,6,8,8,6,8,2&#125;; int len=strlen(buf),a[maxn],i,c,ret=1; if(len==1) return mod[buf[0]-'0']; for(i=0;i&lt;len;i++) a[i]=buf[len-1-i]-'0'; for(;len;len-=!a[len-1]) &#123; ret=ret*mod[a[1]%2*10+a[0]]%5; for(c=0,i=len-1;i&gt;=0;i--) c=c*10+a[i],a[i]=c/5,c%=5; &#125; return ret+ret%2*5;&#125;int main()&#123; char n[maxn]; int a; while(scanf(\"%s\",n)!=EOF) &#123; a=lastdigit(n); printf(\"%d\\n\",a); &#125; return 0;&#125; 阶乘末尾$0$的个数12345678910int find(int n)&#123; int count=0; while(n&gt;0) &#123; count+=n/5; n=n/5; &#125; return count;&#125; 计算逆元逆元的定义：对于正整数$a$和$m$，如果$ax\\equiv 1(mod m)$，那么把这个同余方程中$x$的最小正整数叫做$a$模$m$的逆元 EXGCD计算逆元1234567891011//要求a和m互质// ax = 1(mod m)int mod_reverse(int a,int m)&#123; int x,y; int d=exgcd(a,m,x,y); if(d==1) return (x%m+m)%m; else return -1;&#125; 递归写法注意：只能计算$a&lt;m$的情况，并且要保证a和m互质 1234567//求 ax = 1( mod m) 的 x 值，就是逆元 (0&lt;a&lt;m)int inv(int a,int m)&#123; if(a==1) return 1; return inv(m%a,m)*(m-m/a)%m;&#125; 利用欧拉函数求逆元x和m互质（m可以使非素数）；时间复杂度：$O({\\sqrt{(n)}})$ 123456789101112131415161718192021//求欧拉函数值int eurler_phi(int n)&#123; int res = n; for(int i = 2; i * i &lt;= n; i++) &#123; if(n % i == 0) &#123; res = res / i * (i - 1); while(n % i == 0) n /= i; &#125; &#125; if(n != 1) res = res / n * (n - 1); return res;&#125;//求逆元int inv(int a,int m)&#123; return Pow(a,eurler_phi(m)-1,m);&#125; 快速幂求逆元要求m为素数，a与m互质 公式：$inv=a^{m-1}\\%m$ 推导：$a^{m-1}\\equiv1(mod m)\\Rightarrow a\\cdot a^{m-2}\\equiv1(mod m)\\Rightarrow a^{m-2}\\equiv\\dfrac {1}{a}(mod m)$ 12345// a和m互质，m为素数int inv(int a,int m)&#123; return Pow(a,m-2,m);&#125; 线性时间求逆元时间复杂度：$O(n)$ 12345// 逆元打表int inv[maxn];inv[1] = 1;for(int i=2;i&lt;maxn;i++) inv[i]=(mod-mod/ i)*inv[mod%i]%mod;","categories":[{"name":"template","slug":"template","permalink":"https://blog.wzy1999.wang/categories/template/"}],"tags":[]},{"title":"模板（未完成）","slug":"模板2","date":"2018-09-21T12:50:11.939Z","updated":"2019-01-21T12:27:18.436Z","comments":true,"path":"template/模板2/","link":"","permalink":"https://blog.wzy1999.wang/template/模板2/","excerpt":"数论","text":"数论 素数素数筛法1.线性筛选法——欧拉筛法欧拉筛法通过红色标记部分保证每个合数只会被它的最小质因数筛去，时间复杂度降低到O(n)。代码实现： 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXN 100000#define MAXL 1000000int prime[MAXN];_Bool check[MAXL]; int main(void)&#123; int n, count; while (~scanf(&quot;%d&quot;, &amp;n)) &#123; memset(check, 0, sizeof(check)); count = 0; for (int i = 2; i &lt;= n; i++) &#123; if (!check[i]) prime[count++] = i; for (int j = 0; j &lt; count; j++) &#123; if (i*prime[j] &gt; MAXL) break; // 过大的时候跳出 check[i*prime[j]] = 1; if ((i%prime[j]) == 0) // 如果i是一个合数，而且i % prime[j] == 0 break; &#125; &#125; for (int i = 0; i &lt; count; i++) printf(&quot;%d\\n&quot;, prime[i]); &#125; return 0;&#125; 2.小应用：求n的阶乘的因子数，题目n的范围（1000）；数论的原理，n的阶乘的因子个数等于n的素因子个数的幂的乘积；代码实现： 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int k[1005]; const LL mod=1e9+7;int main()&#123; int n; cin&gt;&gt;n; for(int i=2;i&lt;=n;i++) &#123; int l=i; for(int j=2;j&lt;=l;j++) &#123; while(l%j==0) &#123; k[j]++; l/=j; &#125; &#125; if(l) k[l]++; &#125; LL sum=1; for(int i=2;i&lt;=n;i++) &#123; if(k[i]) &#123; sum*=(k[i]+1); sum=sum%mod; &#125; &#125; printf(&quot;%lld\\n&quot;,sum%mod); return 0;&#125; 3.查找出小于等于MAXN的素数（生成连续素数表）123456789101112131415161718192021222324252627/* * 素数筛选，查找出小于等于MAXN的素数 * prime[0]存素数的个数 */const int MAXN = 100000;int prime[MAXN + 1];void getPrime()&#123; memset(prime, 0, sizeof(prime)); for (int i = 2; i &lt;= MAXN; i++) &#123; if (!prime[i]) &#123; prime[++prime[0]] = i; &#125; for (int j = 1; j &lt;= prime[0] &amp;&amp; prime[j] &lt;= MAXN / i; j++) &#123; prime[prime[j] * i] = 1; if (i % prime[j] == 0) &#123; break; &#125; &#125; &#125;&#125; 4.同时得到欧拉函数表和素数表（线性筛）123456789101112131415161718192021222324252627282930313233343536373839404142 /* * 同时得到欧拉函数和素数表 */const int MAXN = 10000000;bool check[MAXN + 10];int phi[MAXN + 10];int prime[MAXN + 10];int tot; // 素数个数void phi_and_prime_table(int N)&#123; memset(check, false, sizeof(check)); phi[1] = 1; tot = 0; for (int i = 2; i &lt;= N; i++) &#123; if (!check[i]) &#123; prime[tot++] = i; phi[i] = i - 1; &#125; for (int j = 0; j &lt; tot; j++) &#123; if (i * prime[j] &gt; N) &#123; break; &#125; check[i * prime[j]] = true; if (i % prime[j] == 0) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; else &#123; phi[i * prime[j]] = phi[i] * (prime[j] - 1); &#125; &#125; &#125; return ;&#125; 二、GCD &amp;&amp; exgcd1.GCD: 公式：gcd(a,b) = gcd(b, a%b)求a,b 最大公约数代码实现: 123456ll gcd(ll a, ll b)&#123; if(b == 0) return a; return gcd(b, a % b);&#125; 2.EXGCD: 公式： ax+by=c; 功能：用来解二元一次方程组； 注意事项：a,b均为正数; 取最小正整数解： 例题：。设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define LL long long #define INF 0x3f3f3f3f#define PI acos(-1.0)using namespace std;LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y)&#123; if(!b) &#123; x=1; y=0; return a; &#125; LL r=exgcd(b,a%b,x,y); LL t=y; y=x-(a/b)*y; x=t; return r;&#125;int main()&#123; LL a,b,x,y,n,m,l,k1,k2;//k2就是方程的一个x的解 cin&gt;&gt;x&gt;&gt;y&gt;&gt;m&gt;&gt;n&gt;&gt;l; LL d=x-y; a=l; b=n-m; LL c=exgcd(a,b,k1,k2);//c是最大公约数 if(d%c)//方程有解的条件 printf(&quot;Impossible&quot;); else&#123; LL s=k2*d/c; LL v=a/c;//对结果取余的最小的范围 printf(&quot;%lld\\n&quot;,(s%v+v)%v); &#125; return 0;&#125; 三、唯一分解定理 任何大于１的自然数，都可以唯一分解成有限个质数的乘积 例如对于大于1的自然数n，这里Pi均为质数，其指数ai是正整数。这样的分解称为的标准分解式。1.找出一个数n的所有素因子 1234567891011121314typedef long long ll;ll fac[10050], num;//素因数,素因数的个数void init(ll n) &#123;//唯一分解定理 num = 0; ll cpy = n; int m = (int)sqrt(n + 0.5); for (int i = 2; i &lt;= m; ++i) &#123; if (cpy % i == 0) &#123; fac[num++] = i; while (cpy % i == 0) cpy /= i; &#125; &#125; if (cpy &gt; 1) fac[num++] = cpy;&#125; 2.约数和定理&amp;&amp;约数个数定理(1) 约数个数定理约数个数定理可以计算出一个数约数的个数根据唯一分解定理：则n的正约数的个数就是将378000分解质因数378000=2^ 4×3^ 3×5^ 3×7^1由约数个数定理可知378000共有正约数(4+1)×(3+1)×(3+1)×(1+1)=160个。代码实现 12345678910111213141516171819202122232425262728293031323334int prime[maxn],nprime; int vis[maxn]; void getprime()&#123; nprime = 0; memset(vis,0,sizeof(vis)); for(int i = 2; i &lt;= 450; i++)&#123; int t = 450/i; for(int j = 2; j &lt;=t; j++) vis[i*j] = 1; &#125; for(int i = 2; i &lt;= 450; i++)&#123; if(!vis[i]) prime[nprime++] = i; &#125; &#125; int factor_count(int n)&#123; int ans = 1,sum; int k = sqrt(n*1.0); for(int i = 0; prime[i] &lt; k; i++)&#123; if(n % prime[i] == 0)&#123; sum = 0; while(n % prime[i] == 0)&#123; sum++; n /= prime[i]; &#125; ans *= (a+1); //ans为n的约数的个数 &#125; &#125; if(n &gt; 1) ans *= 2; return ans; &#125; (2)约数和定理n的(a₁+1)(a₂+1)(a₃+1)…(ak+1)个正约数的和为f(n)=(p1 ^ 0+p1 ^ 1+p1 ^ 2+…p1^ a1)(p2 ^ 0+p2 ^ 1+p2 ^ +…p2 ^ a2)…(pk ^ 0+pk^1+pk ^ 2+…pk ^ ak）代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445int prime[maxn],nprime;int vis[maxn]; void getprime()&#123; nprime = 0; memset(vis,0,sizeof(vis)); for(int i = 2; i &lt;= 450; i++)&#123; int t = 450/i; for(int j = 2; j &lt;=t; j++) vis[i*j] = 1; &#125; for(int i = 2; i &lt;= 450; i++)&#123; if(!vis[i]) prime[nprime++] = i; &#125;&#125; int pow_mod(int a,int n,int MOD)&#123; int ans = 1; while(n)&#123; if(n&amp;1) ans = (ans*a)%MOD; n &gt;&gt;= 1; a = (a*a)%MOD; &#125; return ans;&#125; int factor_sum(int n)&#123; int ans = 1,sum; int k = sqrt(n*1.0); for(int i = 0; prime[i] &lt; k; i++)&#123; if(n % prime[i] == 0)&#123; sum = 0; while(n%prime[i] == 0)&#123; sum++; n /= prime[i]; &#125; ans *= (pow_mod(prime[i],sum+1,MOD)-1)/(prime[i]-1); &#125; &#125; if(n &gt; 1) ans *= ans(n*n-1)/(n-1); return ans;&#125; 杜教筛: 有些时候也有一些奇形怪状的函数比如 ，其中是pi质数，ai&gt;0且。接着，出题人给了你一个挺大的n，n一般来说都有10^10左右。最后，他想让你输出的值（可能会对一个大数取模）。杜教筛差不多就是拿来解决这类问题哒..它给出了一个比较通用的技巧使得可以在或者的时间复杂度内求的答案。例如：f(i,j)是一个积性函数，求前缀和，可以用杜教筛 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include &lt;tr1/unordered_map&gt;typedef long long ll;using namespace std;using namespace std::tr1; const int P=1000000007;const int inv2=(P+1)/2;const int inv3=(P+1)/3;const int maxn=1000000; int prime[2000000],num;int miu[maxn+5];ll sumd[maxn+5],t1[maxn+5],t2[maxn+5]; int d[maxn+5]; inline void Pre()&#123; miu[1]=1; sumd[1]=1; for (int i=2;i&lt;=maxn;i++)&#123; if (!d[i]) d[i]=prime[++num]=i,sumd[i]=1+i,t1[i]=1+i,t2[i]=i,miu[i]=-1; for (int j=1;j&lt;=num &amp;&amp; (ll)i*prime[j]&lt;=maxn;j++)&#123; d[i*prime[j]]=prime[j]; int k=i*prime[j]; if (i%prime[j]==0)&#123; miu[k]=0; t2[k]=t2[i]*prime[j],t1[k]=t1[i]+t2[k],sumd[k]=sumd[i]/t1[i]*t1[k]; break; &#125; miu[i*prime[j]]=miu[i]*miu[prime[j]]; sumd[k]=sumd[i]*sumd[prime[j]],t1[k]=1+prime[j],t2[k]=prime[j]; &#125; &#125; for (int i=1;i&lt;=maxn;i++) miu[i]=((ll)i*((P+miu[i])%P)%P+miu[i-1])%P,(sumd[i]+=sumd[i-1])%=P;&#125; unordered_map&lt;ll,int&gt; S; inline void add(int &amp;x,int y)&#123; x+=y; if (x&gt;=P) x-=P;&#125; inline int sum1(ll n)&#123; return (n+1)%P*(n%P)%P*inv2%P;&#125;inline int sum1(ll l,ll r)&#123; return (l+r)%P*((r-l+1)%P)%P*inv2%P; &#125; inline int Sum(ll n)&#123; if (n&lt;=maxn) return miu[n]; if (S.find(n)!=S.end()) return S[n]; int tem=1; ll l,r; for (l=2;l*l&lt;=n;l++) add(tem,P-l*Sum(n/l)%P); for (ll t=n/l;l&lt;=n;l=r+1,t--) r=n/t,add(tem,P-(ll)sum1(l,r)*Sum(t)%P); return S[n]=tem;&#125;/*inline int F(ll n)&#123; int t1=0,t2=0; ll l,r; for (l=1;l*l&lt;=n;l++) add(t1,l%P*(n/l)%P),add(t2,sum1(n/l)%P); for (ll t=n/l;l&lt;=n;l=r+1,t--) r=n/t,add(t1,(ll)sum1(l,r)*(n/l)%P),add(t2,(r-l+1)%P*sum1(n/l)%P); return (ll)t1*t2%P;&#125;*/ inline int F(ll n)&#123; if (n&lt;=maxn) return (ll)sumd[n]*sumd[n]%P; int t1=0; ll l,r; for (l=1;l*l&lt;=n;l++) add(t1,l%P*(n/l)%P); for (ll t=n/l;l&lt;=n;l=r+1,t--) r=n/t,add(t1,(ll)sum1(l,r)*(n/l)%P); return (ll)t1*t1%P;&#125; int main()&#123; ll n,l,r; int Ans=0; freopen(&quot;t.in&quot;,&quot;r&quot;,stdin); freopen(&quot;t.out&quot;,&quot;w&quot;,stdout); Pre(); scanf(&quot;%lld&quot;,&amp;n); for (l=1;l*l&lt;=n;l++) add(Ans,(ll)(Sum(l)+P-Sum(l-1))%P*F(n/l)%P); for (ll t=n/l;l&lt;=n;l=r+1,t--) r=n/t,add(Ans,(ll)(Sum(r)+P-Sum(l-1))%P*F(n/l)%P); printf(&quot;%d\\n&quot;,Ans); return 0;&#125; 黑科技之BM 线性递推式，给出前几项自动可得出n项的值；前面的不用动 ，只需更改main函数中的 初值 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cassert&gt;#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define all(x) (x).begin(),(x).end()#define fi first#define se second#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;typedef long long ll;typedef pair&lt;int,int&gt; PII;const ll mod=1e9+7;ll powmod(ll a,ll b) &#123;ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125;// headint _,n;namespace linear_seq &#123; const int N=10010; ll res[N],base[N],_c[N],_md[N]; vector&lt;int&gt; Md; void mul(ll *a,ll *b,int k) &#123; rep(i,0,k+k) _c[i]=0; rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod; for (int i=k+k-1;i&gt;=k;i--) if (_c[i]) rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod; rep(i,0,k) a[i]=_c[i]; &#125; int solve(ll n,VI a,VI b) &#123; // a 系数 b 初值 b[n+1]=a[0]*b[n]+...// printf(&quot;%d\\n&quot;,SZ(b)); ll ans=0,pnt=0; int k=SZ(a); assert(SZ(a)==SZ(b)); rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1; Md.clear(); rep(i,0,k) if (_md[i]!=0) Md.push_back(i); rep(i,0,k) res[i]=base[i]=0; res[0]=1; while ((1ll&lt;&lt;pnt)&lt;=n) pnt++; for (int p=pnt;p&gt;=0;p--) &#123; mul(res,res,k); if ((n&gt;&gt;p)&amp;1) &#123; for (int i=k-1;i&gt;=0;i--) res[i+1]=res[i];res[0]=0; rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod; &#125; &#125; rep(i,0,k) ans=(ans+res[i]*b[i])%mod; if (ans&lt;0) ans+=mod; return ans; &#125; VI BM(VI s) &#123; VI C(1,1),B(1,1); int L=0,m=1,b=1; rep(n,0,SZ(s)) &#123; ll d=0; rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod; if (d==0) ++m; else if (2*L&lt;=n) &#123; VI T=C; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; L=n+1-L; B=T; b=d; m=1; &#125; else &#123; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; ++m; &#125; &#125; return C; &#125; int gao(VI a,ll n) &#123; VI c=BM(a); c.erase(c.begin()); rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod; return solve(n,c,VI(a.begin(),a.begin()+SZ(c))); &#125;&#125;;int main()&#123; int T; scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; vector&lt;int&gt;v; v.push_back(3); v.push_back(9); v.push_back(20); v.push_back(46); v.push_back(106); v.push_back(244); v.push_back(560); v.push_back(1286); v.push_back(2956); v.push_back(6794); v.push_back(15610); v.push_back(35866); //VI&#123;1,2,4,7,13,24&#125; ll n; scanf(&quot;%lld&quot;,&amp;n); printf(&quot;%lld\\n&quot;,linear_seq::gao(v,n-1)); &#125;&#125; 斯特林近似公式： 12345678910111213141516171819#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define PI 3.1415926 ll n,t; void solve() &#123; ll a=(ll) ((0.5 * log ( 2 * PI * n) + n * log(n) - n-0.0005) / log(10)); printf(&quot;%lld\\n&quot;,a+1); //是2 不是22，上传时貌似出问题了 &#125; int main() &#123; scanf(&quot;%lld&quot;,&amp;t); while(t--)&#123; scanf(&quot;%lld&quot;,&amp;n); solve(); &#125; return 0; &#125;//n! = sqrt((2 * n * PI) * (n / e ) ^ n) 卡特兰数 1.求n对括号合法的匹配的方式 C（n,2n）-C（n+1,2n） 2.卡特兰数公式 令h(0)=1,h(1)=1，catalan数满足递推式：h(n)= h(0)h(n-1)+h(1)h(n-2) + … +h(n-1)*h(0) (n&gt;=2) 另类递推式[2]：h(n)=h(n-1)(4n-2)/(n+1); 递推关系的解为：h(n)=C(2n,n)/(n+1) (n=0,1,2,…) 递推关系的另类解为：h(n)=c(2n,n)-c(2n,n-1)(n=0,1,2,…)3.可以利用卡特兰数解决的常见问题： 一个栈(无穷大)的进栈序列为1，2，3，…，n，有多少个不同的出栈序列? 在n*n的格子中，只在下三角行走，每次横或竖走一格，有多少中走法？ 将一个凸n+2边形区域分成三角形区域的方法数？ 圆上选择2n个点,将这些点成对连接起来使得所得到的n条线段不相交的方法数？ 有2n个人排成一行进入剧场。入场费5元。其中只有n个人有一张5元钞票，另外n人只有10元钞票，剧院无其它钞票，问有多少中方法使得只要有10元的人买票，售票处就有5元的钞票找零？代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include&lt;string.h&gt;int a[105][1000];//大数运算 int b[105]; //储存对应卡特兰数有多少位 void catalan() //求卡特兰数&#123; int i, j, len, carry, temp; a[1][0] = b[1] = 1; len = 1; for(i = 2; i &lt;= 100; i++) &#123; for(j = 0; j &lt; len; j++) //乘法 a[i][j] = a[i-1][j]*(4*(i-1)+2); carry = 0; for(j = 0; j &lt; len; j++) //处理相乘结果 &#123; temp = a[i][j] + carry; a[i][j] = temp % 10; carry = temp / 10; &#125; while(carry) //进位处理 &#123; a[i][len++] = carry % 10; carry /= 10; &#125; carry = 0; for(j = len-1; j &gt;= 0; j--) //除法 &#123; temp = carry*10 + a[i][j]; a[i][j] = temp/(i+1); carry = temp%(i+1); &#125; while(!a[i][len-1]) //高位零处理 len --; b[i] = len; &#125;&#125; int main() &#123; catalan(); for(int i=1;i&lt;=100;i++) &#123; for(int j=b[i]-1;j&gt;=0;j--) &#123; printf(&quot;%d&quot;,a[i][j]); &#125; printf(&quot;\\n&quot;); &#125;&#125;","categories":[{"name":"template","slug":"template","permalink":"https://blog.wzy1999.wang/categories/template/"}],"tags":[]},{"title":"模板整理（未完成）","slug":"模板1","date":"2018-09-20T04:29:38.625Z","updated":"2019-01-21T12:27:06.687Z","comments":true,"path":"template/模板1/","link":"","permalink":"https://blog.wzy1999.wang/template/模板1/","excerpt":"DP01背包（每种物品只有一个）1234567891011//n 物品数量，v 背包容量 //size 单个物品体积，value 单个物品价值void bag01()&#123; for(int i=0;i&lt;n;i++) for(int j=v;j&gt;=size[i];j--) &#123; dp[j]=max(dp[j],dp[j-size[i]]+value[i]); &#125; cout&lt;&lt;dp[v]&lt;&lt;endl;&#125;","text":"DP01背包（每种物品只有一个）1234567891011//n 物品数量，v 背包容量 //size 单个物品体积，value 单个物品价值void bag01()&#123; for(int i=0;i&lt;n;i++) for(int j=v;j&gt;=size[i];j--) &#123; dp[j]=max(dp[j],dp[j-size[i]]+value[i]); &#125; cout&lt;&lt;dp[v]&lt;&lt;endl;&#125; 完全背包（每种物品有无穷多）123456789void complete()&#123; for(int i=0;i&lt;n;i++) for(int j=size[i];j&lt;=v;j++) &#123; dp[j]=max(dp[j],dp[j-size[i]]+value[i]); &#125; cout&lt;&lt;dp[v]&lt;&lt;endl;&#125; 多重背包（每种物品数量有限）1234567891011121314151617181920//n 物品数量，v 背包容量 //size 单个物品体积，value 单个物品价值，num 该物品的数量 void multiply()&#123; for(int i=0;i&lt;n;i++) &#123; int d1=1,d2=num[i]; while(d1&lt;d2) &#123; for(int j=v;j&gt;=d1*size[i];j--) &#123; dp[j]=max(dp[j],dp[j-d1*size[i]]+value[i]*d1); &#125; d2-=d1; d1*=2; &#125; for(int j=v;j&gt;=d2*size[i];j--) dp[j]=max(dp[j],dp[j-d2*size[i]]+value[i]*d2); &#125; cout&lt;&lt;dp[v]&lt;&lt;endl;&#125; LIS（最长上升子序列）123456789101112131415161718192021222324252627//这个是计算连续的上升序列 如：1，2，3,4这种void lis(int n)//n是数组元素的个数&#123; for(int i=1;i&lt;=n;i++) &#123; b[a[i]]=b[a[i]-1]+1; ans=std::max(ans,b[a[i]]); &#125;&#125; //这个计算的是递增的（不需要连续递增）如：1,3,5,7这种int a[maxn];int dp[maxn];int n;void longest()&#123; dp[0]=a[0]; int pos; int L=1; for(int i=0;i&lt;n;i++) &#123; pos=lower_bound(dp,dp+L,a[i])-dp; dp[pos]=a[i]; L=max(L,pos+1); &#125; cout&lt;&lt;L&lt;&lt;endl;&#125; LCS（最长公共子序列）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//状态转移方程：// if( s[i]==t[j] ) // dp[i+1][j+1] = dp[i][j] + 1; // else // dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1]); int dp[maxn][maxn];char a[maxn],b[maxn];int vis[maxn][maxn];//只求长度的时候可以去掉// 如果要输出公共子序列，把int改成void，并把return去掉int LCS()&#123; int len1,len2,i,j; len1=strlen(a); len2=strlen(b); memset(dp,0,sizeof(dp)); for(i=1;i&lt;=len1;i++) for(j=1;j&lt;=len2;j++) &#123; if(a[i-1]==b[j-1]) dp[i][j]=dp[i-1][j-1]+1; else if(dp[i-1][j]&gt;=dp[i][j-1]) &#123; dp[i][j]=dp[i-1][j]; vis[i][j]=1; &#125; else &#123; dp[i][j]=dp[i][j-1]; vis[i][j]=-1; &#125; &#125; return dp[len1][len2];&#125;// 这个函数可以将LCS打印出来void Print(int i, int j)//i，j分别代表a，b字符串的长度&#123; if(i==0||j==0) return; if(!vis[i][j])//如果a[i]和b[j]子母相同，输出 &#123; Print(i-1,j-1); printf(&quot;%c&quot;,a[i-1]); &#125; else if(vis[i][j]==1)//如果dp[i-1][j]&gt;dp[i][j-1] Print(i-1,j); else//如果dp[i][j-1]&gt;=dp[i-1][j] Print(i,j-1);&#125; 数论素数素数筛法1.线性筛选法——欧拉筛法欧拉筛法通过红色标记部分保证每个合数只会被它的最小质因数筛去，时间复杂度降低到O(n)。代码实现： 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXN 100000#define MAXL 1000000int prime[MAXN];_Bool check[MAXL]; int main(void)&#123; int n, count; while (~scanf(&quot;%d&quot;, &amp;n)) &#123; memset(check, 0, sizeof(check)); count = 0; for (int i = 2; i &lt;= n; i++) &#123; if (!check[i]) prime[count++] = i; for (int j = 0; j &lt; count; j++) &#123; if (i*prime[j] &gt; MAXL) break; // 过大的时候跳出 check[i*prime[j]] = 1; if ((i%prime[j]) == 0) // 如果i是一个合数，而且i % prime[j] == 0 break; &#125; &#125; for (int i = 0; i &lt; count; i++) printf(&quot;%d\\n&quot;, prime[i]); &#125; return 0;&#125; 2.小应用：求n的阶乘的因子数，题目n的范围（1000）；数论的原理，n的阶乘的因子个数等于n的素因子个数的幂的乘积；代码实现： 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int k[1005]; const LL mod=1e9+7;int main()&#123; int n; cin&gt;&gt;n; for(int i=2;i&lt;=n;i++) &#123; int l=i; for(int j=2;j&lt;=l;j++) &#123; while(l%j==0) &#123; k[j]++; l/=j; &#125; &#125; if(l) k[l]++; &#125; LL sum=1; for(int i=2;i&lt;=n;i++) &#123; if(k[i]) &#123; sum*=(k[i]+1); sum=sum%mod; &#125; &#125; printf(&quot;%lld\\n&quot;,sum%mod); return 0;&#125; 3.查找出小于等于MAXN的素数（生成连续素数表）123456789101112131415161718192021222324252627/* * 素数筛选，查找出小于等于MAXN的素数 * prime[0]存素数的个数 */const int MAXN = 100000;int prime[MAXN + 1];void getPrime()&#123; memset(prime, 0, sizeof(prime)); for (int i = 2; i &lt;= MAXN; i++) &#123; if (!prime[i]) &#123; prime[++prime[0]] = i; &#125; for (int j = 1; j &lt;= prime[0] &amp;&amp; prime[j] &lt;= MAXN / i; j++) &#123; prime[prime[j] * i] = 1; if (i % prime[j] == 0) &#123; break; &#125; &#125; &#125;&#125; 同时得到欧拉函数表和素数表（线性筛）123456789101112131415161718192021222324252627282930313233343536373839404142 /* * 同时得到欧拉函数和素数表 */const int MAXN = 10000000;bool check[MAXN + 10];int phi[MAXN + 10];int prime[MAXN + 10];int tot; // 素数个数void phi_and_prime_table(int N)&#123; memset(check, false, sizeof(check)); phi[1] = 1; tot = 0; for (int i = 2; i &lt;= N; i++) &#123; if (!check[i]) &#123; prime[tot++] = i; phi[i] = i - 1; &#125; for (int j = 0; j &lt; tot; j++) &#123; if (i * prime[j] &gt; N) &#123; break; &#125; check[i * prime[j]] = true; if (i % prime[j] == 0) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; else &#123; phi[i * prime[j]] = phi[i] * (prime[j] - 1); &#125; &#125; &#125; return ;&#125; GCD1234int gcd(int a,int b)&#123; return b==0?a:gcd(b,a%b);&#125; LCM1234int lcm(int a,int b)&#123; return a/gcd(a,b)*b;//如果先运算a*b，很可能超数据范围&#125; EX_GCD一般用来求解不定方程，求解线性同余方程，求解模的逆元等公式： ax+by=c; 功能：用来解二元一次方程组； 注意事项：a,b均为正数;取最小正整数解引理：存在 x , y 使得 gcd(a,b)=ax+by 1234567891011121314int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; // 无最大公约数 if(a==0&amp;&amp;b==0) return -1; if(b==0) &#123; x=1;y=0; return a; &#125; int d=exgcd(b,a%b,y,x); y-=a/b*x; return d;&#125; 例题：。设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define LL long long #define INF 0x3f3f3f3f#define PI acos(-1.0)using namespace std;LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y)&#123; if(!b) &#123; x=1; y=0; return a; &#125; LL r=exgcd(b,a%b,x,y); LL t=y; y=x-(a/b)*y; x=t; return r;&#125;int main()&#123; LL a,b,x,y,n,m,l,k1,k2;//k2就是方程的一个x的解 cin&gt;&gt;x&gt;&gt;y&gt;&gt;m&gt;&gt;n&gt;&gt;l; LL d=x-y; a=l; b=n-m; LL c=exgcd(a,b,k1,k2);//c是最大公约数 if(d%c)//方程有解的条件 printf(&quot;Impossible&quot;); else&#123; LL s=k2*d/c; LL v=a/c;//对结果取余的最小的范围 printf(&quot;%lld\\n&quot;,(s%v+v)%v); &#125; return 0;&#125; 快速幂时间复杂度O(log(n)) 1234567891011int Pow(int a,int b,int c)&#123; int res=1; while(b&gt;0) &#123; if(b&amp;1) res=res*a%c; a=a*a%c; b&gt;&gt;=1; &#125; return res;&#125; 中国剩余定理（CRT）求M%A=a,M%B=b,…中的M，其中A,B,C…互质123456789101112131415161718192021222324252627282930//chu是除数，yu是余数//注意只适用于除数两两互质#define ll long longint ex_gcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123; ll d; if(b == 0) &#123; x = 1; y = 0; return a; &#125; d = ex_gcd(b, a % b, y, x); y -= a / b * x; return d;&#125;ll chinese_remainder(ll b[], ll w[], ll len) &#123; ll i, d, x, y, m, n, ret; ret = 0; n = 1; for(i=0; i &lt; len ;i++) n *= w[i]; for(i=0; i &lt; len ;i++) &#123; m = n / w[i]; d=ex_gcd(w[i], m, x, y); ret = (ret + y*m*b[i]) % n; &#125; return (n + ret%n) % n;&#125; 中国剩余定理扩展求M%A=a,M%B=b,…中的M，其中A,B,C…不互质 1234567891011121314151617181920212223242526272829ll a[maxn],b[maxn];//a是除数，b是余数ll ex_gcd(ll a,ll b,ll &amp;x,ll &amp;y) &#123; ll d; if(b==0) &#123; x=1; y=0; return a; &#125; d=ex_gcd(b,a%b,y,x); y-=a/b*x; return d;&#125;ll ex_crt(ll *a, ll *b, int n)&#123; ll M=a[1],R=b[1],x,y; for (int i=2;i&lt;=n;i++) &#123; ll d=ex_gcd(M,a[i],x,y); if((b[i]-R)%d) return -1; x=(b[i]-R)/d*x%(a[i]/d); R+=x*M; M=M/d*a[i]; R%=M; &#125; return R&gt;0?R:R+M;&#125; 求逆元EX_GCD求逆元1234567891011//要求a和m互质// ax = 1(mod m)int mod_reverse(int a,int m)&#123; int x,y; int d=exgcd(a,m,x,y); if(d==1) return (x%m+m)%m; else return -1;&#125; 简洁写法注意：这个只能求a&lt;m的情况，而且必须保证a和m互质 1234567//求 ax = 1( mod m) 的 x 值，就是逆元 (0&lt;a&lt;m)int inv(int a,int m)&#123; if(a==1) return 1; return inv(m%a,m)*(m-m/a)%m;&#125; 利用欧拉函数求逆元x和m互质（m可以不是素数）；时间复杂度O(sqrt(n)) 123456789101112131415161718192021//求欧拉函数值int eurler_phi(int n)&#123; int res = n; for(int i = 2; i * i &lt;= n; i++) &#123; if(n % i == 0) &#123; res = res / i * (i - 1); while(n % i == 0) n /= i; &#125; &#125; if(n != 1) res = res / n * (n - 1); return res;&#125;//求逆元int inv(int a,int m)&#123; return Pow(a,eurler_phi(m)-1,m);&#125; 线性时间求逆元时间复杂度O(n)12345// 逆元打表int inv[maxn];inv[1] = 1;for(int i=2;i&lt;maxn;i++) inv[i]=(mod-mod/ i)*inv[mod%i]%mod; 快速幂求逆元原理是费马小定理，要求m为素数12345// a和m互质，m为素数int inv(int a,int m)&#123; return Pow(a,m-2,m);&#125; 二分乘法（快速乘）用来解决乘法的结果远超int范围，但需要的结果有取余的乘法运算1234567891011121314151617ll qmul(ll a,ll b,ll m)&#123; ll ans=0; ll k=a; ll f=1;//f是用来存负号的 if(k&lt;0) &#123;f=-1;k=-k;&#125; if(b&lt;0) &#123;f*=-1;b=-b;&#125; while(b)&#123; if(b&amp;1) ans=(ans+k)%m; k=(k+k)%m; b&gt;&gt;=1; &#125; return ans*f;&#125; 欧拉函数对于正整数N,少于或等于N ([1,N]),且与N互质的正整数(包括1)的个数，记作φ(n)。欧拉函数公式：φ(N)=N(1-1/P1)(1-1/P2)…(1-1/Pn) 直接求12345678910111213141516int Eular(int n)&#123; int eu = n; for (int i = 2 ; i * i &lt;= n ; i++) &#123; if (n % i == 0) &#123; eu -= eu / i; while (n % i == 0) n /= i; &#125; &#125; if (n &gt; 1) //n本身也是个质因子 eu -= eu / n; return eu; &#125; 打表求12345678910void Eular()&#123; euler[1]=1; for(int i=2;i&lt;maxn;i++) euler[i]=i; for(int i=2;i&lt;maxn;i++) if(euler[i]==i) for(int j=i;j&lt;maxn;j+=i) euler[j]=euler[j]/i*(i-1);//先进行除法是为了防止中间数据的溢出&#125; 唯一分解定理任何大于１的自然数，都可以唯一分解成有限个质数的乘积 n=p^{a_{1}}_{1}p^{a_{2}}_{2}\\ldots p^{a}_{k}=\\prod ^{k}_{i=1}p^{a_{i}}_{i}这里pi均为素数，其指数ai是正整数 找到数n的所有质因子123456789101112131415161718// pri记录质因子，k记录质因子个数int pri[maxn],k;void resolve(int n)&#123; k=0; int N=n; for(int i=2;i*i&lt;=n;i++) &#123; if(N%i==0) &#123; pri[k++]=i; while(N%i==0) N/=i; &#125; &#125; if(N&gt;1) num[k++]=N;&#125; 约数个数定理计算一个数约数的个数 根据唯一分解定理： n=\\prod ^{k}_{i=1}p^{a_{i}}_{i}则n的正约数个数为： f\\left( n\\right) =\\prod ^{k}_{i=1}\\left( a_{i}+1\\right)如：将278000分解质因数 278000=2^{4}\\times 3^{3}\\times 5^{3}\\times 7^{1}可以计算出278000的正约数共有 \\left( 4+1\\right) \\times \\left( 3+1\\right) \\times \\left( 1+1\\right)=40个1234567891011121314151617181920212223242526272829303132int prime[maxn],nprime; int vis[maxn]; void getprime()&#123; nprime = 0; memset(vis,0,sizeof(vis)); for(int i = 2; i &lt;= 450; i++)&#123; int t = 450/i; for(int j = 2; j &lt;=t; j++) vis[i*j] = 1; &#125; for(int i = 2; i &lt;= 450; i++)&#123; if(!vis[i]) prime[nprime++] = i; &#125; &#125; int factor_count(int n)&#123; int ans = 1,sum; int k = sqrt(n*1.0); for(int i = 0; prime[i] &lt; k; i++)&#123; if(n % prime[i] == 0)&#123; sum = 0; while(n % prime[i] == 0)&#123; sum++; n /= prime[i]; &#125; ans *= (a+1); //ans为n的约数的个数 &#125; &#125; if(n &gt; 1) ans *= 2; return ans; &#125; 约数和定理正整数n的所有正约数的和为 f(n)=(p1^0 + p1^1 + p1^2 +…+ p1^a1)(p2^0 + p2^1 + p2^2 +…+ p2^a2)…(pk^0 + pk^1 + pk^2 +…+ pk^ak) 123456789101112131415161718192021222324252627282930313233343536373839404142int prime[maxn],nprime;int vis[maxn];void getprime()&#123; nprime = 0; memset(vis,0,sizeof(vis)); for(int i = 2; i &lt;= 450; i++)&#123; int t = 450/i; for(int j = 2; j &lt;=t; j++) vis[i*j] = 1; &#125; for(int i = 2; i &lt;= 450; i++)&#123; if(!vis[i]) prime[nprime++] = i; &#125;&#125;int pow_mod(int a,int n,int MOD)&#123; int ans = 1; while(n)&#123; if(n&amp;1) ans = (ans*a)%MOD; n &gt;&gt;= 1; a = (a*a)%MOD; &#125; return ans;&#125;int factor_sum(int n)&#123; int ans = 1,sum; int k = sqrt(n*1.0); for(int i = 0; prime[i] &lt; k; i++)&#123; if(n % prime[i] == 0)&#123; sum = 0; while(n%prime[i] == 0)&#123; sum++; n /= prime[i]; &#125; ans *= (pow_mod(prime[i],sum+1,MOD)-1)/(prime[i]-1); &#125; &#125; if(n &gt; 1) ans *= ans(n*n-1)/(n-1); return ans;&#125; 元根m是正整数，a是正数，若a mod m的阶等于φ(m)，则a为模m的一个元根（φ(m)表示m的欧拉函数） 给出一个素数p，找出p最小的元根 我的理解：找到最小的数x，使得 x^{\\phi \\left( n\\right) }\\% n=11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;int p[maxn];int k;ll Pow(ll a,ll b,ll c)&#123; ll res=1; while(b) &#123; if(b&amp;1) res=res*a%c; b&gt;&gt;=1; a=a*a%c; &#125; return res;&#125;// 查找n的素因子void getp(ll n)&#123; for(int i=2;i*i&lt;=n;i++) &#123; if(n%i==0) &#123; p[k++]=i; while(n%i==0) n/=i; &#125; &#125; if(n&gt;1) p[k++]=n;&#125;int main(int argc, char const *argv[])&#123; ios::sync_with_stdio(false); ll n; cin&gt;&gt;n; k=0; // 素数的欧拉函数值为n-1 // 对欧拉值进行分解 getp(n-1); for(int i=2;i&lt;n;i++) &#123; int flag=0; for(int j=0;j&lt;k;j++) &#123; if(Pow(i,(n-1)/p[j],n)==1) &#123; flag++; break; &#125; &#125; if(!flag) &#123; cout&lt;&lt;i&lt;&lt;endl; return 0; &#125; &#125; return 0;&#125; 容斥原理（二进制状态枚举）1234567891011121314151617181920212223242526int n; for(int i=0;i&lt;(1&lt;&lt;n);i++)&#123; // 相当于枚举所有的情况 o(2^n*n) for(int j = 0; j &lt; n ;j++) &#123; printf(&quot;%d &quot;,(i&gt;&gt;j)&amp;1); &#125;&#125; /**********应用*************/// 二进制枚举计算[1,n]区间内有多少和数组a互质/不互质的数ll ans = 0; for(int i = 1; i &lt; (1 &lt;&lt; n); i++)&#123; // 相当于枚举所有的情况 o(2^n*n) int cnt = 0; ll tmp = 1; for(int j = 0; j &lt; n ;j++) &#123; // a[j] if(i &gt;&gt; j &amp; 1) &#123; cnt ++; tmp = lcm(tmp, a[j]); &#125; &#125; if(cnt &amp; 1) ans += n / tmp; else ans -= n / tmp; &#125; 与1~n中与n互质的数的平方和平方和公式： \\sum ^{n}_{i=1}i^{2}=\\dfrac {n\\left( n+1\\right) \\left( 2n+1\\right) }{6}把n进行质因子分解，进行容斥，结果=总和-不互质的平方和不互质平方和为： \\sum ^{n}_{k=1}\\left( k\\ast m\\right) ^{2}=m^{2}\\sum ^{\\dfrac {n}{m}}_{k=1}k^{2}=m^{2}\\dfrac {\\dfrac {n}{m}\\left( \\dfrac {n}{m}+1\\right) \\left( 2\\dfrac {n}{m}+1\\right) }{6}把n进行质因子分解，进行容斥，结果=总和-不互质的平方和不互质平方和为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt; #include &lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn = 1e6 + 10;LL arr[maxn];int p;LL get(LL x, LL y) &#123; LL cnt = x / y; //这里return的是推出来的公式 return ((y * y) * (cnt * (cnt + 1) * (2 * cnt + 1) / 6));&#125;void getp(LL n) &#123; //分解质因子 p = 0; for(int i = 2; i * i &lt;= n; i++) &#123; if(n % i == 0) &#123; arr[p++] = i; while(n % i == 0) n /= i; &#125; &#125; if(n &gt; 1) arr[p++] = n;&#125;int main() &#123; LL n; while(scanf(&quot;%lld&quot;, &amp;n) != EOF) &#123; if(n == 0 || n == 1) &#123; puts(&quot;0&quot;); continue; &#125; getp(n); LL sum = n * (n + 1) * (2 * n + 1) / 6; LL ans = 0; for(int i = 1; i &lt; (1 &lt;&lt; p); i++) &#123; //状压 LL res = 0, cnt = 1; for(int j = 0; j &lt; p; j++) &#123; if(i &amp; (1 &lt;&lt; j)) &#123; cnt *= arr[j]; res++; &#125; &#125; if(res &amp; 1) ans += get(n, cnt); //容斥 else ans -= get(n, cnt); &#125; printf(&quot;%lld\\n&quot;, sum - ans); &#125; return 0;&#125; DLS模板杜教筛有些时候也有一些奇形怪状的函数比如 f\\left( n\\right) =\\prod \\left( p^{a_{i}}_{i}+1\\right)其中pi为质数，ai&gt;0且 n=\\prod p^{a_{i}}_{i}接着出题人给了一个挺大的n（一般在10^10左右）。最后要求输出这个式子的值（可能会对一个大数进行取模）杜教筛差不对就是拿来解决这类问题的它给出了一个比较通用的技巧，使得可以在O(n^(2/3))或者O(n^(3/4))的时间复杂度内求得结果例如： f\\left( ij\\right) =\\sum ^{a}_{i=1}\\sum ^{b}_{j=1}\\dfrac {aj}{b}\\left[ \\left( a,b\\right) =1\\right]f(i,j)是一个积性函数，求前缀和12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include &lt;tr1/unordered_map&gt;typedef long long ll;using namespace std;using namespace std::tr1; const int P=1000000007;const int inv2=(P+1)/2;const int inv3=(P+1)/3;const int maxn=1000000; int prime[2000000],num;int miu[maxn+5];ll sumd[maxn+5],t1[maxn+5],t2[maxn+5]; int d[maxn+5]; inline void Pre()&#123; miu[1]=1; sumd[1]=1; for (int i=2;i&lt;=maxn;i++)&#123; if (!d[i]) d[i]=prime[++num]=i,sumd[i]=1+i,t1[i]=1+i,t2[i]=i,miu[i]=-1; for (int j=1;j&lt;=num &amp;&amp; (ll)i*prime[j]&lt;=maxn;j++)&#123; d[i*prime[j]]=prime[j]; int k=i*prime[j]; if (i%prime[j]==0)&#123; miu[k]=0; t2[k]=t2[i]*prime[j],t1[k]=t1[i]+t2[k],sumd[k]=sumd[i]/t1[i]*t1[k]; break; &#125; miu[i*prime[j]]=miu[i]*miu[prime[j]]; sumd[k]=sumd[i]*sumd[prime[j]],t1[k]=1+prime[j],t2[k]=prime[j]; &#125; &#125; for (int i=1;i&lt;=maxn;i++) miu[i]=((ll)i*((P+miu[i])%P)%P+miu[i-1])%P,(sumd[i]+=sumd[i-1])%=P;&#125; unordered_map&lt;ll,int&gt; S; inline void add(int &amp;x,int y)&#123; x+=y; if (x&gt;=P) x-=P;&#125; inline int sum1(ll n)&#123; return (n+1)%P*(n%P)%P*inv2%P;&#125;inline int sum1(ll l,ll r)&#123; return (l+r)%P*((r-l+1)%P)%P*inv2%P; &#125; inline int Sum(ll n)&#123; if (n&lt;=maxn) return miu[n]; if (S.find(n)!=S.end()) return S[n]; int tem=1; ll l,r; for (l=2;l*l&lt;=n;l++) add(tem,P-l*Sum(n/l)%P); for (ll t=n/l;l&lt;=n;l=r+1,t--) r=n/t,add(tem,P-(ll)sum1(l,r)*Sum(t)%P); return S[n]=tem;&#125;/*inline int F(ll n)&#123; int t1=0,t2=0; ll l,r; for (l=1;l*l&lt;=n;l++) add(t1,l%P*(n/l)%P),add(t2,sum1(n/l)%P); for (ll t=n/l;l&lt;=n;l=r+1,t--) r=n/t,add(t1,(ll)sum1(l,r)*(n/l)%P),add(t2,(r-l+1)%P*sum1(n/l)%P); return (ll)t1*t2%P;&#125;*/ inline int F(ll n)&#123; if (n&lt;=maxn) return (ll)sumd[n]*sumd[n]%P; int t1=0; ll l,r; for (l=1;l*l&lt;=n;l++) add(t1,l%P*(n/l)%P); for (ll t=n/l;l&lt;=n;l=r+1,t--) r=n/t,add(t1,(ll)sum1(l,r)*(n/l)%P); return (ll)t1*t1%P;&#125; int main()&#123; ll n,l,r; int Ans=0; freopen(&quot;t.in&quot;,&quot;r&quot;,stdin); freopen(&quot;t.out&quot;,&quot;w&quot;,stdout); Pre(); scanf(&quot;%lld&quot;,&amp;n); for (l=1;l*l&lt;=n;l++) add(Ans,(ll)(Sum(l)+P-Sum(l-1))%P*F(n/l)%P); for (ll t=n/l;l&lt;=n;l=r+1,t--) r=n/t,add(Ans,(ll)(Sum(r)+P-Sum(l-1))%P*F(n/l)%P); printf(&quot;%d\\n&quot;,Ans); return 0;&#125; 杜教BM模板自动计算线性递推式（例如：f[x]=2f[x-1]+f[x-2]），推出前几项，压进vector就可以直接输出结果了（有些递推式也可以用矩阵快速幂来求） 例如：计算线性递推式： a\\left[ i\\right]=2\\times a\\left[ i-1\\right]-a\\left[ i-2\\right]+3\\times a\\left[ i-3\\right]+2\\times a\\left[ i-4\\right]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cassert&gt;#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define all(x) (x).begin(),(x).end()#define fi first#define se second#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;typedef long long ll;typedef pair&lt;int,int&gt; PII;const ll mod=1e9+7;ll powmod(ll a,ll b) &#123;ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125;// headint _,n;namespace linear_seq &#123; const int N=10010; ll res[N],base[N],_c[N],_md[N]; vector&lt;int&gt; Md; void mul(ll *a,ll *b,int k) &#123; rep(i,0,k+k) _c[i]=0; rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod; for (int i=k+k-1;i&gt;=k;i--) if (_c[i]) rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod; rep(i,0,k) a[i]=_c[i]; &#125; int solve(ll n,VI a,VI b) &#123; // a 系数 b 初值 b[n+1]=a[0]*b[n]+...// printf(&quot;%d\\n&quot;,SZ(b)); ll ans=0,pnt=0; int k=SZ(a); assert(SZ(a)==SZ(b)); rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1; Md.clear(); rep(i,0,k) if (_md[i]!=0) Md.push_back(i); rep(i,0,k) res[i]=base[i]=0; res[0]=1; while ((1ll&lt;&lt;pnt)&lt;=n) pnt++; for (int p=pnt;p&gt;=0;p--) &#123; mul(res,res,k); if ((n&gt;&gt;p)&amp;1) &#123; for (int i=k-1;i&gt;=0;i--) res[i+1]=res[i];res[0]=0; rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod; &#125; &#125; rep(i,0,k) ans=(ans+res[i]*b[i])%mod; if (ans&lt;0) ans+=mod; return ans; &#125; VI BM(VI s) &#123; VI C(1,1),B(1,1); int L=0,m=1,b=1; rep(n,0,SZ(s)) &#123; ll d=0; rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod; if (d==0) ++m; else if (2*L&lt;=n) &#123; VI T=C; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; L=n+1-L; B=T; b=d; m=1; &#125; else &#123; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; ++m; &#125; &#125; return C; &#125; int gao(VI a,ll n) &#123; VI c=BM(a); c.erase(c.begin()); rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod; return solve(n,c,VI(a.begin(),a.begin()+SZ(c))); &#125;&#125;;int main()&#123; int T; scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; vector&lt;int&gt;v; /** * 下面放入推出的前几项（项数越多结果越准确） */ v.push_back(3); v.push_back(9); v.push_back(20); v.push_back(46); v.push_back(106); v.push_back(244); v.push_back(560); v.push_back(1286); v.push_back(2956); v.push_back(6794); v.push_back(15610); v.push_back(35866); //VI&#123;1,2,4,7,13,24&#125; ll n; scanf(&quot;%lld&quot;,&amp;n); printf(&quot;%lld\\n&quot;,linear_seq::gao(v,n-1)); &#125;&#125; 阶乘最后非零位1234567891011121314151617181920212223242526272829303132/* * 阶乘最后非零位 复杂度O(nlongn) * 返回改为，n以字符串方式传入 */#define MAXN 10000const int mod[20] = &#123;1, 1, 2, 6, 4, 2, 2, 4, 2, 8, 4, 4, 8, 4, 6, 8, 8, 6, 8, 2&#125;;int lastDigit(char *buf)&#123; int len = (int)strlen(buf); int a[MAXN], i, c, ret = 1; if (len == 1) &#123; return mod[buf[0] - &apos;0&apos;]; &#125; for (i = 0; i &lt; len; i++) &#123; a[i] = buf[len - 1 - i] - &apos;0&apos;; &#125; for (; len; len -= !a[len - 1]) &#123; ret = ret * mod[a[1] % 2 * 10 + a[0]] % 5; for (c = 0, i = len - 1; i &gt;= 0; i--) &#123; c = c * 10 + a[i]; a[i] = c / 5; c %= 5; &#125; &#125; return ret + ret % 2 * 5;&#125; 斯特林公式求n阶乘的近似值公式： \\lim _{n\\rightarrow \\infty }\\left( \\dfrac {n}{\\pi }\\right) ^{n}\\sqrt {\\dfrac {2\\pi n}{n!}}=1可以得出： n!\\approx \\sqrt {2\\pi n}\\left( \\dfrac {n}{e}\\right) ^{n}利用斯特林公式计算n阶乘的长度公式：(需要对len取整) len=\\dfrac {\\lg 2\\pi n}{2}+n\\lg \\dfrac {n}{e}+112345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;#define pi acos(-1.0) const double E=exp(1);int main()&#123; int t; int n; cin&gt;&gt;n; long long ans=1+0.5*log10(2*pi*n)+n*log10(n/E); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 卡特兰数求n对括号合法的匹配方式 C^{n}_{2n}-C^{n+1}_{2n}卡特兰数公式令h(0)=1,h(1)=1;catalan数满足递推式：h(n)= h(0)h(n-1)+h(1)h(n-2) + … +h(n-1)h(0) (n&gt;=2)另类递推式：h(n)=h(n-1)(4n-2)/(n+1);递推关系的解为： h\\left( n\\right) =\\dfrac {C^{n}_{2n}}{n+1} \\left(n= 1,2,3\\ldots \\right)递推关系的另类解为： h\\left( n\\right) =C^{n}_{2n}-C^{n-1}_{2n} \\left(n= 1,2,3\\ldots \\right)可以用卡特兰数解决的常见问题（1）一个栈(无穷大)的进栈序列为1，2，3，…，n，有多少个不同的出栈序列?（2）在n x n的格子中，只在下三角行走，每次横或竖走一格，有多少中走法？（3）将一个凸n+2边形区域分成三角形区域的方法数？（4）圆上选择2n个点,将这些点成对连接起来使得所得到的n条线段不相交的方法数？（5）有2n个人排成一行进入剧场。入场费5元。其中只有n个人有一张5元钞票，另外n人只有10元钞票，剧院无其它钞票，问有多少中方法使得只要有10元的人买票，售票处就有5元的钞票找零？代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include&lt;string.h&gt;int a[105][1000];//大数运算 int b[105]; //储存对应卡特兰数有多少位 void catalan() //求卡特兰数&#123; int i, j, len, carry, temp; a[1][0] = b[1] = 1; len = 1; for(i = 2; i &lt;= 100; i++) &#123; for(j = 0; j &lt; len; j++) //乘法 a[i][j] = a[i-1][j]*(4*(i-1)+2); carry = 0; for(j = 0; j &lt; len; j++) //处理相乘结果 &#123; temp = a[i][j] + carry; a[i][j] = temp % 10; carry = temp / 10; &#125; while(carry) //进位处理 &#123; a[i][len++] = carry % 10; carry /= 10; &#125; carry = 0; for(j = len-1; j &gt;= 0; j--) //除法 &#123; temp = carry*10 + a[i][j]; a[i][j] = temp/(i+1); carry = temp%(i+1); &#125; while(!a[i][len-1]) //高位零处理 len --; b[i] = len; &#125;&#125; int main() &#123; catalan(); for(int i=1;i&lt;=100;i++) &#123; for(int j=b[i]-1;j&gt;=0;j--) &#123; printf(&quot;%d&quot;,a[i][j]); &#125; printf(&quot;\\n&quot;); &#125;&#125; STLset基本操作：12345678910111213141516171819s.begin() // 返回指向第一个元素的迭代器s.clear() // 清除所有元素s.count() // 返回某个值元素的个数s.empty() // 如果集合为空，返回true(真）s.end() // 返回指向最后一个元素之后的迭代器，不是最后一个元素s.equal_range() // 返回集合中与给定值相等的上下限的两个迭代器s.erase() // 删除集合中的元素s.find() // 返回一个指向被查找到元素的迭代器s.get_allocator() // 返回集合的分配器s.insert() // 在集合中插入元素s.lower_bound() // 返回指向大于（或等于）某值的第一个元素的迭代器s.key_comp() // 返回一个用于元素间值比较的函数s.max_size() // 返回集合能容纳的元素的最大限值s.rbegin() // 返回指向集合中最后一个元素的反向迭代器s.rend() // 返回指向集合中第一个元素的反向迭代器s.size() // 集合中元素的数目s.swap() // 交换两个集合变量s.upper_bound() // 返回大于某个值元素的迭代器s.value_comp() // 返回一个用于比较元素间的值的函数 最长路有一张n个点n-1条边的无向联通图,每个点编号为1~n,每条边都有一个长度小w现在在点x上她想知道从点x出发经过每个点至少一次，最少需要走多少路 输入：第一行两个整数 n,x,代表点数,和小w所处的位置第二到第n行,每行三个整数 u,v,w,表示u和v之间有一条长为w的道路 输出：一个结果表示答案 思路：所有路径长度*2减去最长路的长度12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define ll long long#define msy(a) memset(a,-1,sizeof(a))const double E=exp(1);const int maxn=1e6+10;const int mod=1e9+7;using namespace std;vector&lt;pair&lt;int, ll&gt; &gt; G[maxn];ll dis[maxn], mmax;//计算最长路，maxx是最长路void dfs(int x)&#123; int size = G[x].size(); for(int i=0; i&lt;size; ++i) &#123; int u = G[x][i].first; if(dis[u] == -1) &#123; dis[u] = G[x][i].second + dis[x]; mmax = max(mmax, dis[u]); dfs(u); &#125; &#125;&#125;int main(int argc, char const *argv[])&#123; ios::sync_with_stdio(false); msy(dis); int n, x; cin &gt;&gt; n &gt;&gt; x; int u, v; ll w, ans = 0; for(int i=1; i&lt;n; ++i) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; G[u].push_back(make_pair(v, w)); G[v].push_back(make_pair(u, w)); ans+=w; &#125; ans*=2; dis[x] = 0; dfs(x); ans -= mmax; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 分段打表题意：计算1+1/2+1/3+……+1/n ; 思路：分段打表，将每1000的和存一下，需要计算时找出对应的1000的权值，再计算后面的部分相加即可1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;cmath&gt;double a[100005]; void init()&#123; int tm = 1; a[0] = 0; for (int i = 1; i &lt;= 100002; ++i)&#123; a[i] = a[i-1];//a[i]计算的从(i-1)*1000+1到i*1000的和 for (int j = tm; j &lt;= tm+999; ++j)&#123; a[i] += 1.0/j; &#125; tm = tm+1000; &#125;&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); init(); int Case = 1; while (t--)&#123; int n; scanf(&quot;%d&quot;,&amp;n); int r = n/1000*1000;//找出他的对应1000的位置 for (int i = r+1; i &lt;= n; ++i)&#123;//计算一下剩余的值的和 tmp += 1.0/i; &#125; double tt; tt = a[n/1000]; //printf(&quot;%lf %lf\\n&quot;,tt,tmp); double ans = tt+tmp; printf(&quot;Case %d: %.9lf\\n&quot;,Case++,ans); &#125; return 0;&#125; SG函数结论：游戏和的SG函数等于各个游戏SG函数的Nim和应用条件：当进行游戏有多种选取方式，可以打sg表或者用dfs得到 例题：有三堆石子，每堆石子的数量为n,m,k.每次每人可以拿去的石子数量为斐波那契的项的数量，1、 这是一个二人游戏;2、 一共有3堆石子，数量分别是m, n, p个；3、 两人轮流走;4、 每走一步可以选择任意一堆石子，然后取走f个；5、 f只能是菲波那契数列中的元素（即每次只能取1，2，3，5，8…等数量）；6、 最先取光所有石子的人为胜者； 123456789101112131415161718192021222324252627282930313233//f[N]:可改变当前状态的方式，N为方式的种类，f[N]要在getSG之前先预处理//SG[]:0~n的SG函数值//S[]:为x后继状态的集合#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXN 1000 + 10#define N 20int f[N],SG[MAXN],S[MAXN];void getSG(int n)&#123; int i,j; memset(SG,0,sizeof(SG)); for(i = 1; i &lt;= n; i++)&#123; memset(S,0,sizeof(S)); for(j = 0; f[j] &lt;= i &amp;&amp; j &lt;= N; j++) S[SG[i-f[j]]] = 1; for(j = 0;;j++) if(!S[j])&#123; SG[i] = j; break; &#125; &#125;&#125;int main()&#123; int n,m,k; f[0] = f[1] = 1; for(int i = 2; i &lt;= 16; i++) f[i] = f[i-1] + f[i-2]; getSG(1000); while(scanf(&quot;%d%d%d&quot;,&amp;m,&amp;n,&amp;k),m||n||k)&#123; if(SG[n]^SG[m]^SG[k]) printf(&quot;Fibo\\n&quot;); else printf(&quot;Nacci\\n&quot;); &#125; return 0;&#125;","categories":[{"name":"template","slug":"template","permalink":"https://blog.wzy1999.wang/categories/template/"}],"tags":[]}]}