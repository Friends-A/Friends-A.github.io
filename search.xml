<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python学习NO_4]]></title>
    <url>%2Flearn%2FPython%E5%AD%A6%E4%B9%A0NO_4%2F</url>
    <content type="text"><![CDATA[第六章——字符串操作 字符串以单（双）引号开始，单（双）引号结束 在字符串开始的引号之前加上r，可以将字符串称为原始字符串，打印出字符串中所有的\之类的转义字符 1234&gt;&gt;&gt; print('he\tllo')he llo&gt;&gt;&gt; print(r'he\tllo')he\tllo 多行字符串以三个单（双）引号开始，三个单（双）引号结束。 1234print('''hellothe \nworld''') 输出为： 1234hellothe world 用in和not in可以判断一个字符串是否在另一个字符串中 1234&gt;&gt;&gt; 'bcd' in 'abcde'True&gt;&gt;&gt; 'ad' not in 'abcd'True 字符串的一些方法upper()将字符串中的字母全变为大写；lower()将字符串中的字母全变为小写；isupper()判断字符串中的所有字母是否是大写；islower()判断字符串中的所有字母是否是小写 12345678&gt;&gt;&gt; '12AbcD'.lower()'12abcd'&gt;&gt;&gt; '12AbcD'.upper()'12ABCD'&gt;&gt;&gt; '12AbcD'.isupper()False&gt;&gt;&gt; '12ABCD'.isupper()True isX方法 isalpha()返回True，如果字符串只包含字母，并且非空； isalnum()返回True，如果字符串只包含字母和数字，并且非空： isdecimal()返回True，如果字符串只包含数字字符，并且非空： ispace()返回True，如果字符串只包含空格、制表符和换行，并且非空； istitle()返回True，如果字符串仅包含以大写字母开头、后面都是小写字母的单词。 startswith()和endswith返回值为布尔类型，用来判断调用的字符串是否以该方法传入的字符串开始或结束 1234&gt;&gt;&gt; 'abcde'.startswith('ab')True&gt;&gt;&gt; 'abcde'.endswith('cde')True join()和split()join()是将一个字符串列表连接成单独的字符串，split()是将单独的字符串分割成一个字符串列表 join()针对一个字符串调用，传入一个列表值；split()相反 1234&gt;&gt;&gt; '-'.join(['a','b','c'])'a-b-c'&gt;&gt;&gt; 'a-b-c'.split('-')['a', 'b', 'c'] rjust()、ljust()、center()这三种方法用来对齐字符串 rjust()、ljust()和center()分别用来右对齐、左对齐、中间对齐字符串；有两个参数：第一个参数是一个整数，代表字符串的长度；第二个参数是一个字符，表示除原字符串之外的部分用该字符补齐。 第二个参数默认为空格 123456&gt;&gt;&gt; 'abc'.rjust(10,'*')'*******abc'&gt;&gt;&gt; 'abc'.ljust(10,'*')'abc*******'&gt;&gt;&gt; 'abc'.center(10,'*')'***abc****' strip()、rstrip()、lstrip()这三种方法用来删除空白字符 分别表示删除两边字符、删除右边、删除左边。有一个参数，代表需要删除的字符，默认为空格 参数可以是一个字符串，但同样是看成字符的形式，删除时和字符的顺序无关 123456&gt;&gt;&gt; 'abccbacab123456cabcba'.lstrip('abc')'123456cabcba'&gt;&gt;&gt; 'abccbacab123456cabcba'.rstrip('abc')'abccbacab123456'&gt;&gt;&gt; 'abccbacab123456cabcba'.strip('abc')'123456' pyperclip模块里的copy()和paste()函数可以向计算机的剪切板发送和接受文本。pyperclip模块需要安装]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>py_learn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习第三天]]></title>
    <url>%2Flearn%2FPython%E5%AD%A6%E4%B9%A0NO_3%2F</url>
    <content type="text"><![CDATA[第五章——字典和结构化数据字典 字典的索引被称为键，键及其关联的值称为键-值。字典输入的时候要带花括号{}，在使用的时候和列表一样使用中括号[] 123&gt;&gt;&gt; myCat=&#123;'size':'fat','color':'gray'&#125;&gt;&gt;&gt; myCat['size']'fat' 判断两个列表相同，要看两个列表中的对应位置的元素是否相同；判断两个字典是否相同，只需看两个字典的键-值是否相同即可 12345678&gt;&gt;&gt; List=['a','b','c']&gt;&gt;&gt; List1=['b','a','c']&gt;&gt;&gt; List==List1False&gt;&gt;&gt; dic=&#123;1:'a',2:'b',3:'c'&#125;&gt;&gt;&gt; dic1=&#123;2:'b',1:'a',3:'c'&#125;&gt;&gt;&gt; dic==dic1True 如果访问字典中不存在的键，则会导致KeyError 字典中的一些方法keys() values() items()这三种方法分别对应字典的键、值、键-值对。返回的值是类似列表的值，不是真正的列表，不能被修改 1234567&gt;&gt;&gt; spam=&#123;'color':'red','age':18&#125;&gt;&gt;&gt; spam.values()dict_values(['red', 18])&gt;&gt;&gt; spam.keys()dict_keys(['color', 'age'])&gt;&gt;&gt; spam.items()dict_items([('color', 'red'), ('age', 18)]) 如果想要得到一个列表，可以用list()进行转换 使用in和not in依旧可以检查值是否在字典中，查询时如果不声明，默认按照keys()进行查询 123456789&gt;&gt;&gt; dic=&#123;1:'a',2:'b',3:'c'&#125;&gt;&gt;&gt; 1 in dic.keys()True&gt;&gt;&gt; 'a' in dic.values()True&gt;&gt;&gt; 1 in dicTrue&gt;&gt;&gt; (1,'a') in dic.items()True get()方法get()有两个参数：要取得该值的键和一个备用的返回值。如果查询的键不在字典中，返回备用的值；否则返回该键对应的值。get()的默认返回值为$0$，如果不适用get()方法，在查询失败的时候会返回KeyError setdefault()方法setdefault()方法存在两个参数。相当于提供了一个if语句：如果字典中存在查找的键（第一个参数），返回键对应的值；否则将第一个参数作为键，第二个参数作为第一个参数对应的值加入到字典中 12dic=&#123;1:'a',2:'b',3:'c'&#125;dic.setdefault(4,'d') 相当于： 123dic=&#123;1:'a',2:'b',3:'c'&#125;if 4 not in dic: dic[4]='d' 输出dic会发现输出均为： 1&#123;1: 'a', 2: 'b', 3: 'c', 4: 'd'&#125; 使用setdefault()可以确保一个键的存在 可以利用setdefault()对字符串中出现的字符进行计数： 123456s='qwertyuioplkjhgfdsazxcvbnm'count=&#123;&#125;for ch in s: count.setdefault(ch,0) count[ch]+=1print(count) 输出结果为： 1&#123;'q': 1, 'w': 1, 'e': 1, 'r': 1, 't': 1, 'y': 1, 'u': 1, 'i': 1, 'o': 1, 'p': 1, 'l': 1, 'k': 1, 'j': 1, 'h': 1, 'g': 1, 'f': 1, 'd': 1, 's': 1, 'a': 1, 'z': 1, 'x': 1, 'c': 1, 'v': 1, 'b': 1, 'n': 1, 'm': 1&#125; pprint模块的简单应用将上述代码导入pprint模块之后，使用pprint()输出： 1234567import pprints='qwertyuioplkjhgfdsazxcvbnm'count=&#123;&#125;for ch in s: count.setdefault(ch,0) count[ch]+=1pprint.pprint(count) 输出结果为： 1234567891011121314151617181920212223242526&#123;&apos;a&apos;: 1, &apos;b&apos;: 1, &apos;c&apos;: 1, &apos;d&apos;: 1, &apos;e&apos;: 1, &apos;f&apos;: 1, &apos;g&apos;: 1, &apos;h&apos;: 1, &apos;i&apos;: 1, &apos;j&apos;: 1, &apos;k&apos;: 1, &apos;l&apos;: 1, &apos;m&apos;: 1, &apos;n&apos;: 1, &apos;o&apos;: 1, &apos;p&apos;: 1, &apos;q&apos;: 1, &apos;r&apos;: 1, &apos;s&apos;: 1, &apos;t&apos;: 1, &apos;u&apos;: 1, &apos;v&apos;: 1, &apos;w&apos;: 1, &apos;x&apos;: 1, &apos;y&apos;: 1, &apos;z&apos;: 1&#125; pprint()对于包含列表等的字典特别有用 使用pformat()可以将pprint()输出的字典当做字符串来储存。以下两行代码是等效的： 12pprint.pprint(count)print(pprint.pformat((count)))]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>py_learn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习第一天]]></title>
    <url>%2Flearn%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0NO_1%2F</url>
    <content type="text"><![CDATA[NumPy函数库基础from numpy import*导入numpy模块 random.rand()用来生成一个随机数组 例如：random.rand(4,4)，生成一个$4\times 4$的随机二维数组 12345&gt;&gt;&gt; random.rand(4,4)array([[0.5889423 , 0.38768404, 0.46706706, 0.88201106], [0.03742084, 0.30163653, 0.40948962, 0.22092582], [0.84407563, 0.42206233, 0.26600708, 0.8114246 ], [0.39277872, 0.88407207, 0.59209405, 0.19366928]]) 用mat()函数可以将数组转换成矩阵 12345&gt;&gt;&gt; mat(random.rand(4,4))matrix([[0.27334161, 0.3052977 , 0.68240247, 0.65456973], [0.09794511, 0.74127397, 0.11178214, 0.18242132], [0.15790548, 0.99141967, 0.57665171, 0.90780008], [0.7987583 , 0.06336807, 0.94360913, 0.18242104]]) .I操作符实现了矩阵的求逆运算 矩阵求逆，即求矩阵的逆矩阵。设$A$是数域上的一个$n$阶方阵，若在相同数域上存在另一个$n$阶矩$B$，使得： $A\times B=B\times A=E$。 则我们称$B$是$A$的逆矩阵，而A则被称为可逆矩阵。其中，$E$为单位矩阵。 123456789101112&gt;&gt;&gt; randmat=mat(random.rand(4,4))&gt;&gt;&gt; invmat=randmat.I&gt;&gt;&gt; randmatmatrix([[0.48117984, 0.29220134, 0.34585956, 0.30547942], [0.42158584, 0.12684831, 0.56184421, 0.93906936], [0.25070707, 0.0770531 , 0.46094489, 0.18799276], [0.1206866 , 0.5818652 , 0.75019166, 0.69006769]])&gt;&gt;&gt; invmatmatrix([[ 2.23619026, 0.10754838, 0.07245331, -1.15601151], [ 1.7848114 , -1.14762783, -2.14901481, 1.35708167], [-1.33183128, -0.45568243, 3.15370035, 0.35053317], [-0.44817218, 1.44425573, -1.62909657, 0.12594335]]) 如果执行矩阵乘法，将两个矩阵直接相乘即可： 123456789&gt;&gt;&gt; randmat*invmatmatrix([[ 1.00000000e+00, 0.00000000e+00, 5.55111512e-17, 2.77555756e-17], [ 1.11022302e-16, 1.00000000e+00, 0.00000000e+00, 8.32667268e-17], [-2.77555756e-16, -5.55111512e-17, 1.00000000e+00, 9.02056208e-17], [-1.66533454e-16, 2.22044605e-16, 4.44089210e-16, 1.00000000e+00]]) eye(4)用来创建$4\times 4$的单位矩阵，可以用来检测误差值 12345&gt;&gt;&gt; eye(4)array([[1., 0., 0., 0.], [0., 1., 0., 0.], [0., 0., 1., 0.], [0., 0., 0., 1.]]) 12345678910&gt;&gt;&gt; deviation=randmat*invmat&gt;&gt;&gt; deviation-eye(4)matrix([[ 0.00000000e+00, 0.00000000e+00, 5.55111512e-17, 2.77555756e-17], [ 1.11022302e-16, -2.22044605e-16, 0.00000000e+00, 8.32667268e-17], [-2.77555756e-16, -5.55111512e-17, 0.00000000e+00, 9.02056208e-17], [-1.66533454e-16, 2.22044605e-16, 4.44089210e-16, 0.00000000e+00]])]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>ml_learn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习第二天]]></title>
    <url>%2Flearn%2FPython%E5%AD%A6%E4%B9%A0NO_2%2F</url>
    <content type="text"><![CDATA[第三章——函数 None表示没有值，是NoneType数据类型的唯一值。print的返回值就是None print()函数有可选的变元end和sep，分别指定在参数末尾打印什么，在参数之间打印什么来隔开它们 例如： end 12print('hello')print('word') 12print('hello',end=' ')print('word') 输出分别为： 12helloword 1hello word sep 1234&gt;&gt;&gt; print('a','b','c')a b c&gt;&gt;&gt; print('a','b','c',sep=',')a,b,c 全局作用域中的代码不能使用局部变量，局部作用域可以访问全局变量 在不同的作用域中，可以用相同的名字命名不同的变量 global在局部作用域中修改全局变量 例如： 1234567def spam(): global eggs eggs='spam'eggs='global'print(eggs)spam()print(eggs) 在第一次输出的时候，由于eggs未被修改，所以输出global，第二次输出的时候，因为经过了spam，eggs变成了spam，所以输出为spam 异常处理出现的错误可以用try...except来处理。将可能出错的语句放在try子句中，如果错误发生，程序执行转到接下来的except子句开始处 第四章——列表 列表的负数下标表示列表中的倒数第几个元素，如：num[-1]表示num列表中的最后一个元素 用len()获取列表的长度，方法和字符串相同，返回值为列表中值的个数 例如： 123&gt;&gt;&gt; arr=['acb','d','e']&gt;&gt;&gt; len(arr)3 改变列表中元素的值时，直接找到对应的下标，进行赋值即可 切片切片得到的是一个新的列表，而不是一个值。 在一个切片中，第一个整数表示切片开始出的下标，第二个整数表示结束的下标 第一个整数默认为$0$，第二个整数默认为列表中最后一个元素的下标 例如： 123456789&gt;&gt;&gt; arr=['a','b','c','d','e']&gt;&gt;&gt; arr[:]['a', 'b', 'c', 'd', 'e']&gt;&gt;&gt; arr[3:]['d', 'e']&gt;&gt;&gt; arr[:3]['a', 'b', 'c']&gt;&gt;&gt; arr[1:3]['b', 'c'] 列表的连接和复制+运算符可以连接两个列表；*运算符可以实现列表的复制 例如： 1234&gt;&gt;&gt; [1,2,3]+['a','b','c'][1, 2, 3, 'a', 'b', 'c']&gt;&gt;&gt; [1,2,3,4]*2[1, 2, 3, 4, 1, 2, 3, 4] 列表的使用 for i in []表示i从列表的第一个元素开始遍历数组，i对应的值为当前元素的值 例如： 12for i in [1,4,2]:print(i) 输出结果为： 123142 如果想要根据获得当前遍历元素的下标，可以先用len()获得列表的长度，然后用range()来遍历下标，arr[i]来访问元素 利用in和not in可以快速确定元素是否在列表中，返回值为bool类型 例如： 1234&gt;&gt;&gt; 'd' in ['a','b','c']False&gt;&gt;&gt; 'c' in ['a','b','c']True 列表中的一些方法 index()用来查找某个元素是否在列表中，如果在列表中，返回该元素在列表中第一次出现的下标，否则，会报ValueError 例如： 1234567&gt;&gt;&gt; arr=['a','a','b']&gt;&gt;&gt; arr.index('a')0&gt;&gt;&gt; arr.index('d')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: 'd' is not in list append()和insert()都可以向列表中加入元素，append()只能把元素加入到列表的尾部，insert()则可以向列表中的任意位置加入元素，insert()的第一个整数表示下标，如果该值超过当前列表的长度，那么元素将会被加到列表的末尾 12345678910&gt;&gt;&gt; arr=['a','b']&gt;&gt;&gt; arr.append('c')&gt;&gt;&gt; arr['a', 'b', 'c']&gt;&gt;&gt; arr.insert(2,'d')&gt;&gt;&gt; arr['a', 'b', 'd', 'c']&gt;&gt;&gt; arr.insert(10,'e')&gt;&gt;&gt; arr['a', 'b', 'd', 'c', 'e'] remove()用来删除列表中第一次出现的元素，如果该元素不在列表中，则会ValueError 12345678&gt;&gt;&gt; arr=['a','b']&gt;&gt;&gt; arr.remove('a')&gt;&gt;&gt; arr['b']&gt;&gt;&gt; arr.remove('a')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: list.remove(x): x not in list sort()用来对列表进行排序，默认为按ASCII码升序排序，sort(reverse=True)可以将排序改为降序，sort(key=str.lower)将排序按照普通字典序排序 1234567891011121314&gt;&gt;&gt; arr=['a','A','b']&gt;&gt;&gt; arr.sort()&gt;&gt;&gt; arr['A', 'a', 'b']&gt;&gt;&gt; arr=['a','A','b','B']&gt;&gt;&gt; arr.sort()&gt;&gt;&gt; arr['A', 'B', 'a', 'b']&gt;&gt;&gt; arr.sort(reverse=True)&gt;&gt;&gt; arr['b', 'a', 'B', 'A']&gt;&gt;&gt; arr.sort(key=str.lower)&gt;&gt;&gt; arr['a', 'A', 'b', 'B'] 字符串和元组 字符串和元组都是不可改变的 字符串和元组访问元素的方式和列表一样，注意：元组输入要用()而不是[] 如果元组中只有一个元素，在该元素后面加一个,来告诉程序这是一个元组 例如： 1234&gt;&gt;&gt; type((123,))&lt;class 'tuple'&gt;&gt;&gt;&gt; type((123))&lt;class 'int'&gt; 字符串、列表、元组可以相互转换 123456&gt;&gt;&gt; tuple(['a','b','c'])('a', 'b', 'c')&gt;&gt;&gt; list(('a','b','c'))['a', 'b', 'c']&gt;&gt;&gt; list('abc')['a', 'b', 'c'] 如果将列表直接赋值给另一个列表，那么改变这两个列表中的其中一个，这两个列表均会被改变。原因是在对列表进行赋值的时候，只是将列表中的元素给了另一个列表，而不是列表本身。两个列表均指向同一个列表，所以当一个列表被修改时，指向的列表会被改变，从而两个列表的元素均会变化。 使用copy模块里的copy()和deepcopy()函数可以实现对列表本身的复制， 12345678&gt;&gt;&gt; import copy&gt;&gt;&gt; arr1=['a','b','c']&gt;&gt;&gt; arr2=copy.copy(arr1)&gt;&gt;&gt; arr2[1]='d'&gt;&gt;&gt; arr2['a', 'd', 'c']&gt;&gt;&gt; arr1['a', 'b', 'c']]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>py_learn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习第一天]]></title>
    <url>%2Flearn%2FPython%E5%AD%A6%E4%B9%A0NO_1%2F</url>
    <content type="text"><![CDATA[第一章——Python基础 操作符 操作 例子 求值为 ** 指数 $2**3$ $8$ % 取模 $22\%8$ $6$ // 整除 $22//8$ $2$ / 除法 $22/8$ $2.75$ input()默认输入字符串，如果想要别的类型，需要强制转换 print(&#39;str1&#39;+&#39;str2&#39;)表示将两个字符串连接起来，输出为str1str2 print(&#39;str&#39;*int)表示将str输出int次 print()中的+只能用来连接两个整数或字符串 len(&#39;str&#39;)表示返回当前字符串str的长度。比如：len(&#39;abc&#39;)，返回值为3 关于int()的转换问题如果int()内的是一个字符串，那么字符串一定要是一个表示整数数字的字符，否则会报错，报错信息如下：1234&gt;&gt;&gt; int(&apos;1000.0&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: invalid literal for int() with base 10: &apos;1000.0&apos; 12&gt;&gt;&gt; int(&apos;1000&apos;)1000 如果括号中的是一个浮点型数字，相当于把该数字向下取整，例如：12&gt;&gt;&gt; int(1.9)1 第二章——控制流布尔值True和False均是首字母大写，如果多个值进行比较（可以使字符串、整型、浮点型），如果相等，返回True，否则返回False。0、0.0、&#39;&#39;被认为是False!=和==可以用于所有数据类型，&gt;、&gt;=、&lt;、&lt;=只能用于整型和浮点型布尔操作符：and、or、not根据代码行的缩进，来判定代码块的开始和结束 for循环和range()函数for语句包括： for关键字 一个变量名 in关键字 调用range()方法，最多三个参数 冒号 for子句 range()中的三个参数 一个参数：for i in range(num)表示循环从$i=0$运行到$i=num-1$，$i$每次增加$1$ 12for i in range(2): print(i) 输出结果为：1201 两个参数：for i in range(num1,num2)表示循环从$i=num1$运行到$i=num2-1$，$i$每次增加$1$ 12for i in range(0,2): print(i) 输出结果为： 1201 三个参数：for i in range(num1,num2,step)表示循环从$i=num1$运行到$i=num2-1$，$i$每次增加$step$ 12for i in range(0,4,2): print(i) 输出结果为： 1202 导入模块用import来导入模块 用import+模块名称，在引用函数的时候需要加前缀：模块名称. 用from+模块名称+import*，引用的时候不需要加前缀，只需要写函数名即可 例如： 123456# import random# for i in range(5):# print(random.randint(1,10))from random import*for i in range(5): print(randint(1,10)) 注释内和注释外的代码均表示生成五个$[1,10]$间的随机数 用sys.exit()提前结束程序exit是sys模块里的函数，用来让程序终止或退出 例如： 1234567import syswhile True: print('Type exit to exit.') response=input() if response=='exit': sys.exit() print('You tryed '+response+'.') 当输入exit的时候程序停止，否则将一直循环下去 与OJ刷题相关 判断文件结束符EOF 对于只输入一个字符串或数字，可以用sys.stdin： 12345import sys for line in sys.stdin: a=int(line) if a!=0: print(a) 对于需要输入多个，可以用try...except： 1234567try: while True: s = input() print(s)except EOFError:# 或者excepr: pass]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>py_learn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vimrc]]></title>
    <url>%2FConfiguration%2Fvimrc%2F</url>
    <content type="text"><![CDATA[vim的配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 显示相关 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;set shortmess=atI &quot; 启动的时候不显示那个援助乌干达儿童的提示 &quot;winpos 5 5 &quot; 设定窗口位置 &quot;set lines=40 columns=155 &quot; 设定窗口大小 &quot;set nu &quot; 显示行号 set go= &quot; 不要图形按钮 &quot;color asmanian2 &quot; 设置背景主题 set guifont=Courier_New:h10:cANSI &quot; 设置字体 &quot;syntax on &quot; 语法高亮 autocmd InsertLeave * se nocul &quot; 用浅色高亮当前行 autocmd InsertEnter * se cul &quot; 用浅色高亮当前行 &quot;set ruler &quot; 显示标尺 set showcmd &quot; 输入的命令显示出来，看的清楚些 &quot;set cmdheight=1 &quot; 命令行（在状态行下）的高度，设置为1 &quot;set whichwrap+=&lt;,&gt;,h,l &quot; 允许backspace和光标键跨越行边界(不建议) &quot;set scrolloff=3 &quot; 光标移动到buffer的顶部和底部时保持3行距离 set novisualbell &quot; 不要闪烁(不明白) set statusline=%F%m%r%h%w\ [FORMAT=%&#123;&amp;ff&#125;]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %&#123;strftime(\&quot;%d/%m/%y\ -\ %H:%M\&quot;)&#125; &quot;状态行显示的内容 set laststatus=1 &quot; 启动显示状态行(1),总是显示状态行(2) set foldenable &quot; 允许折叠 set foldmethod=manual &quot; 手动折叠 &quot;set background=dark &quot;背景使用黑色 set nocompatible &quot;去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限 &quot; 显示中文帮助if version &gt;= 603 set helplang=cn set encoding=utf-8endif&quot; 设置配色方案&quot;colorscheme murphy&quot;字体 &quot;if (has(&quot;gui_running&quot;)) &quot; set guifont=Bitstream\ Vera\ Sans\ Mono\ 10 &quot;endif set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936set termencoding=utf-8set encoding=utf-8set fileencodings=ucs-bom,utf-8,cp936set fileencoding=utf-8&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;新文件标题&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;新建.c,.h,.sh,.java文件，自动插入文件头 autocmd BufNewFile *.cpp,*.[ch],*.sh,*.java exec &quot;:call SetTitle()&quot; &quot;&quot;定义函数SetTitle，自动插入文件头 func SetTitle() &quot;如果文件类型为.sh文件 if &amp;filetype == &apos;sh&apos; call setline(1,&quot;\#########################################################################&quot;) call append(line(&quot;.&quot;), &quot;\# File Name: &quot;.expand(&quot;%&quot;)) call append(line(&quot;.&quot;)+1, &quot;\# Author: WZY&quot;) call append(line(&quot;.&quot;)+2, &quot;\# School: HPU&quot;) call append(line(&quot;.&quot;)+3, &quot;\# Created Time: &quot;.strftime(&quot;%c&quot;)) call append(line(&quot;.&quot;)+4, &quot;\#########################################################################&quot;) call append(line(&quot;.&quot;)+5, &quot;\#!/bin/bash&quot;) call append(line(&quot;.&quot;)+6, &quot;&quot;) else call setline(1, &quot;/*************************************************************************&quot;) call append(line(&quot;.&quot;), &quot; &gt; File Name: &quot;.expand(&quot;%&quot;)) call append(line(&quot;.&quot;)+1, &quot; &gt; Author: WZY&quot;) call append(line(&quot;.&quot;)+2, &quot; &gt; School: HPU &quot;) call append(line(&quot;.&quot;)+3, &quot; &gt; Created Time: &quot;.strftime(&quot;%c&quot;)) call append(line(&quot;.&quot;)+4, &quot; ************************************************************************/&quot;) call append(line(&quot;.&quot;)+5, &quot;&quot;) endif if &amp;filetype == &apos;cpp&apos; call append(line(&quot;.&quot;)+6, &quot;#include&lt;bits/stdc++.h&gt;&quot;) call append(line(&quot;.&quot;)+7, &quot;#define ll long long&quot;) call append(line(&quot;.&quot;)+8, &quot;#define ull unsigned long long&quot;) call append(line(&quot;.&quot;)+9, &quot;#define ms(a,b) memset(a,b,sizeof(a))&quot;) call append(line(&quot;.&quot;)+10, &quot;#define pi acos(-1.0)&quot;) call append(line(&quot;.&quot;)+11, &quot;#define INF 0x7f7f7f7f&quot;) call append(line(&quot;.&quot;)+12, &quot;const double E=exp(1);&quot;) call append(line(&quot;.&quot;)+13, &quot;const int maxn=1e6+10;&quot;) call append(line(&quot;.&quot;)+14, &quot;const int mod=1e9+7;&quot;) call append(line(&quot;.&quot;)+15, &quot;using namespace std;&quot;) call append(line(&quot;.&quot;)+16, &quot;int main(int argc, char const *argv[])&quot;) call append(line(&quot;.&quot;)+17, &quot;&#123;&quot;) call append(line(&quot;.&quot;)+18, &quot;\tios::sync_with_stdio(false);&quot;) call append(line(&quot;.&quot;)+19, &quot;\t&quot;) call append(line(&quot;.&quot;)+20, &quot;\treturn 0;&quot;) call append(line(&quot;.&quot;)+21, &quot;&#125;&quot;) endif if &amp;filetype == &apos;c&apos; call append(line(&quot;.&quot;)+6, &quot;#include&lt;stdio.h&gt;&quot;) call append(line(&quot;.&quot;)+7, &quot;&quot;) endif &quot;新建文件后，自动定位到文件末尾 autocmd BufNewFile * normal Gendfunc &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;键盘命令&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;nmap &lt;leader&gt;w :w!&lt;cr&gt;nmap &lt;leader&gt;f :find&lt;cr&gt;&quot; 映射全选+复制 ctrl+amap &lt;C-A&gt; ggVGYmap! &lt;C-A&gt; &lt;Esc&gt;ggVGYmap &lt;F12&gt; gg=G&quot; 选中状态下 Ctrl+c 复制vmap &lt;C-c&gt; &quot;+y&quot;去空行 nnoremap &lt;F2&gt; :g/^\s*$/d&lt;CR&gt; &quot;比较文件 nnoremap &lt;C-F2&gt; :vert diffsplit &quot;新建标签 map &lt;M-F2&gt; :tabnew&lt;CR&gt; &quot;列出当前目录文件 map &lt;F3&gt; :tabnew .&lt;CR&gt; &quot;打开树状文件目录 map &lt;C-F3&gt; \be &quot;C，C++ 按F5编译运行map &lt;F5&gt; :call CompileRunGcc()&lt;CR&gt;func! CompileRunGcc() exec &quot;w&quot; if &amp;filetype == &apos;c&apos; exec &quot;!g++ % -o %&lt;&quot; exec &quot;! ./%&lt;&quot; elseif &amp;filetype == &apos;cpp&apos; exec &quot;!g++ % -o %&lt;&quot; exec &quot;! ./%&lt;&quot; elseif &amp;filetype == &apos;java&apos; exec &quot;!javac %&quot; exec &quot;!java %&lt;&quot; elseif &amp;filetype == &apos;sh&apos; :!./% endifendfunc&quot;C,C++的调试map &lt;F8&gt; :call Rungdb()&lt;CR&gt;func! Rungdb() exec &quot;w&quot; exec &quot;!g++ % -g -o %&lt;&quot; exec &quot;!gdb ./%&lt;&quot;endfunc&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;实用设置&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 设置当文件被改动时自动载入set autoread&quot; quickfix模式autocmd FileType c,cpp map &lt;buffer&gt; &lt;leader&gt;&lt;space&gt; :w&lt;cr&gt;:make&lt;cr&gt;&quot;代码补全 set completeopt=preview,menu &quot;允许插件 filetype plugin on&quot;共享剪贴板 set clipboard+=unnamed &quot;从不备份 set nobackup&quot;make 运行:set makeprg=g++\ -Wall\ \ %&quot;自动保存set autowriteset ruler &quot; 打开状态栏标尺set cursorline &quot; 突出显示当前行set magic &quot; 设置魔术set guioptions-=T &quot; 隐藏工具栏set guioptions-=m &quot; 隐藏菜单栏&quot;set statusline=\ %&lt;%F[%1*%M%*%n%R%H]%=\ %y\ %0(%&#123;&amp;fileformat&#125;\ %&#123;&amp;encoding&#125;\ %c:%l/%L%)\&quot; 设置在状态行显示的信息set foldcolumn=0set foldmethod=indent set foldlevel=3 set foldenable &quot; 开始折叠&quot; 不要使用vi的键盘模式，而是vim自己的set nocompatible&quot; 语法高亮set syntax=on&quot; 去掉输入错误的提示声音set noeb&quot; 在处理未保存或只读文件的时候，弹出确认set confirm&quot; 自动缩进set autoindentset cindent&quot; Tab键的宽度set tabstop=4&quot; 统一缩进为4set softtabstop=4set shiftwidth=4&quot; 不要用空格代替制表符set noexpandtab&quot; 在行和段开始处使用制表符set smarttab&quot; 显示行号set number&quot; 历史记录数set history=1000&quot;禁止生成临时文件set nobackupset noswapfile&quot;搜索忽略大小写set ignorecase&quot;搜索逐字符高亮set hlsearchset incsearch&quot;行内替换set gdefault&quot;编码设置set enc=utf-8set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936&quot;语言设置set langmenu=zh_CN.UTF-8set helplang=cn&quot; 我的状态行显示的内容（包括文件类型和解码）&quot;set statusline=%F%m%r%h%w\ [FORMAT=%&#123;&amp;ff&#125;]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %&#123;strftime(\&quot;%d/%m/%y\ -\ %H:%M\&quot;)&#125;&quot;set statusline=[%F]%y%r%m%*%=[Line:%l/%L,Column:%c][%p%%]&quot; 总是显示状态行set laststatus=2&quot; 命令行（在状态行下）的高度，默认为1，这里是2set cmdheight=2&quot; 侦测文件类型filetype on&quot; 载入文件类型插件filetype plugin on&quot; 为特定文件类型载入相关缩进文件filetype indent on&quot; 保存全局变量set viminfo+=!&quot; 带有如下符号的单词不要被换行分割set iskeyword+=_,$,@,%,#,-&quot; 字符间插入的像素行数目set linespace=0&quot; 增强模式中的命令行自动完成操作set wildmenu&quot; 使回格键（backspace）正常处理indent, eol, start等set backspace=2&quot; 允许backspace和光标键跨越行边界set whichwrap+=&lt;,&gt;,h,l&quot; 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位）set mouse=aset selection=exclusiveset selectmode=mouse,key&quot; 通过使用: commands命令，告诉我们文件的哪一行被改变过set report=0&quot; 在被分割的窗口间显示空白，便于阅读set fillchars=vert:\ ,stl:\ ,stlnc:\&quot; 高亮显示匹配的括号set showmatch&quot; 匹配括号高亮的时间（单位是十分之一秒）set matchtime=1&quot; 光标移动到buffer的顶部和底部时保持3行距离set scrolloff=3&quot; 为C程序提供自动缩进set smartindent&quot; 高亮显示普通txt文件（需要txt.vim脚本）au BufRead,BufNewFile * setfiletype txt&quot;自动补全:inoremap ( ()&lt;ESC&gt;i:inoremap ) &lt;c-r&gt;=ClosePair(&apos;)&apos;)&lt;CR&gt;:inoremap &#123; &#123;&lt;CR&gt;&#125;&lt;ESC&gt;O:inoremap &#125; &lt;c-r&gt;=ClosePair(&apos;&#125;&apos;)&lt;CR&gt;:inoremap [ []&lt;ESC&gt;i:inoremap ] &lt;c-r&gt;=ClosePair(&apos;]&apos;)&lt;CR&gt;:inoremap &quot; &quot;&quot;&lt;ESC&gt;i:inoremap &apos; &apos;&apos;&lt;ESC&gt;ifunction! ClosePair(char) if getline(&apos;.&apos;)[col(&apos;.&apos;) - 1] == a:char return &quot;\&lt;Right&gt;&quot; else return a:char endifendfunctionfiletype plugin indent on &quot;打开文件类型检测, 加了这句才可以用智能补全set completeopt=longest,menu&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; CTags的设定 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;let Tlist_Sort_Type = &quot;name&quot; &quot; 按照名称排序 let Tlist_Use_Right_Window = 1 &quot; 在右侧显示窗口 let Tlist_Compart_Format = 1 &quot; 压缩方式 let Tlist_Exist_OnlyWindow = 1 &quot; 如果只有一个buffer，kill窗口也kill掉buffer let Tlist_File_Fold_Auto_Close = 0 &quot; 不要关闭其他文件的tags let Tlist_Enable_Fold_Column = 0 &quot; 不要显示折叠树 autocmd FileType java set tags+=D:\tools\java\tags &quot;autocmd FileType h,cpp,cc,c set tags+=D:\tools\cpp\tags &quot;let Tlist_Show_One_File=1 &quot;不同时显示多个文件的tag，只显示当前文件的&quot;设置tags set tags=tags &quot;set autochdir &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;其他东东&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;默认打开Taglist let Tlist_Auto_Open=1 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; &quot; Tag list (ctags) &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; let Tlist_Ctags_Cmd = &apos;/usr/bin/ctags&apos; let Tlist_Show_One_File = 1 &quot;不同时显示多个文件的tag，只显示当前文件的 let Tlist_Exit_OnlyWindow = 1 &quot;如果taglist窗口是最后一个窗口，则退出vim let Tlist_Use_Right_Window = 1 &quot;在右侧窗口中显示taglist窗口&quot; minibufexpl插件的一般设置let g:miniBufExplMapWindowNavVim = 1let g:miniBufExplMapWindowNavArrows = 1let g:miniBufExplMapCTabSwitchBufs = 1let g:miniBufExplModSelTarget = 1]]></content>
      <categories>
        <category>Configuration</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数论模板]]></title>
    <url>%2Ftemplate%2F%E6%95%B0%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[快速幂相关快速幂（二分幂）时间复杂度：$O(logn)$ 1234567891011int Pow(int a,int b,int c)&#123; int res=1; while(b&gt;0) &#123; if(b&amp;1) res=res*a%c; a=a*a%c; b&gt;&gt;=1; &#125; return res;&#125;//复杂度O(logn) 二分乘法时间复杂度：$O(logn)$ 用途：用来解决乘法的结果远超long long范围，但需要的结果有取余的乘法运算 1234567891011121314151617ll qmul(ll a,ll b,ll m)&#123; ll ans=0; ll k=a; ll f=1;//f是用来存负号的 if(k&lt;0) &#123;f=-1;k=-k;&#125; if(b&lt;0) &#123;f*=-1;b=-b;&#125; while(b)&#123; if(b&amp;1) ans=(ans+k)%m; k=(k+k)%m; b&gt;&gt;=1; &#125; return ans*f;&#125; 快速乘和二分乘法用途一样，时间复杂度为$O(1)$ 1234ll modmul(ll A,ll B,ll Mod)&#123; return (A*B-(ll)((long double)A*B/Mod)*Mod+Mod)%Mod;&#125; 矩阵快速幂其实矩阵快速幂的思想是和快速幂一样的，矩阵快速幂是用于快速求出一个矩阵的 n 次方的方法。 首先，我们要知道，两个矩阵能不能相乘是有一定条件的：假设有两个矩阵 A, B。如果矩阵 A 的列数等于矩阵 B 的行数，那么这两个矩阵才可以进行相乘，否则这两个矩阵是不能相乘的。 矩阵乘法：设$A=(a_{ij})​$是一个$ms​$的矩阵，$B=(b_{ij})​$是一个$sn​$的矩阵，那么规定矩阵A与矩阵B的乘积是一个$m*n​$的矩阵$C=(c_{ij})​$，其中$C_{ij}=a_{i_1}b_{1_j}+a_{i_2}b_{2_j}+…+a_{i_s}b_{s_j}=\sum _{k=1}^{s}a_{i_k}b_{k_j}(i=1,2…m;j=1,2,…n)​$ 计算矩阵A（规模$ns$）与矩阵B（规模$sm$）相乘后得到$n*m$的矩阵res 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;int a[100][100],b[100][100];int res[100][100];void Matrix_mult(int n,int m,int s)&#123; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) for(int k=0;k&lt;s;k++) res[i][j]+=a[i][k]*b[k][j];&#125;int main(int argc, char const *argv[])&#123; int n,m,s; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;s;j++) cin&gt;&gt;a[i][j]; for(int i=0;i&lt;s;i++) for(int j=0;j&lt;m;j++) cin&gt;&gt;b[i][j]; Matrix_mult(n,m,s); for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) cout&lt;&lt;res[i][j]&lt;&lt;"\t"; cout&lt;&lt;endl; &#125; return 0;&#125; 矩阵快速幂 时间复杂度：$O(logn)$ 计算斐波那契的第N项，并对$1e9+7$取模 对于递推式$F[n]=F[n-1]+F[n-2]$，可构造矩阵：$\binom{F_{n+2}}{F_{n+1}}=\begin{pmatrix}1 &amp;1 \ 1 &amp;0\end{pmatrix}\cdot \binom{F_{n+1}}{F_{n}}$ 对于矩阵快速幂，最主要的是构造矩阵，矩阵构造出来了，答案也就出来了 ps:对于大多数用到矩阵快速幂的题目，也可以用BM算法来解决 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#define ll long longconst int maxn=10;const int mod=1e9+7;using namespace std;struct mart&#123; ll m[100][100];&#125;unit;mart mult(mart a,mart b)&#123; mart ans; int x; for(int i=0;i&lt;4;i++) &#123; for(int j=0;j&lt;4;j++) &#123; x=0; for(int k=0;k&lt;4;k++) x=(x%mod+(a.m[i][k]%mod*b.m[k][j]%mod)%mod)%mod; ans.m[i][j]=x%mod; &#125; &#125; return ans;&#125;void init()&#123; for(int i=0;i&lt;4;i++) unit.m[i][i]=1;&#125;mart qpow(mart a,ll b)&#123; init(); mart ans=unit; while(b) &#123; if(b&amp;1) ans=mult(ans,a); a=mult(a,a); b&gt;&gt;=1; &#125; return ans;&#125;ll slove(ll n)&#123; mart a,b; a.m[0][0]=1; a.m[0][1]=1; a.m[1][0]=1; a.m[1][1]=0; b.m[0][0]=1; b.m[1][0]=0; mart c=mult(qpow(a,n-2),b); return c.m[0][0]%mod;&#125;int main(int argc, char const *argv[])&#123; ll n; cin&gt;&gt;n; if(!n) cout&lt;&lt;0&lt;&lt;endl; else cout&lt;&lt;slove(n+1)&lt;&lt;endl; return 0;&#125; GCD、LCM、EXGCD、CRT相关GCD实现原理：辗转相除法 时间复杂度：$O(log_2n)$ 1234567891011121314151617// 递归写法int gcd1(int a,int b)&#123; return b?gcd1(b,a%b):a;&#125;// 非递归int gcd2(int a,int b)&#123; int t; while(b) &#123; t=a; a=b; b=t%b; &#125; return a;&#125; LCM公式：$LCM(a,b)=a*b/GCD(a,b)$ 1234int lcm(int a,int b)&#123; return a/gcd*b;//这样写可以在一定程度上防止数据溢出&#125; EXGCD用途：一般用来求解不定方程，求解线性同余方程，求解模的逆元等 如求解二元一次方程：$ax+by=c$，（a，b均为正整数，取最小正整数解） 存在x，y，使得$gcd(a,b)=ax+by$ 注意：返回值为a和b的最大公约数，最后的x，y可以直接调用 1234567891011121314int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; // 无最大公约数 if(a==0&amp;&amp;b==0) return -1; if(b==0) &#123; x=1;y=0; return a; &#125; int d=exgcd(b,a%b,y,x); y-=a/b*x; return d;&#125; 例题：设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define LL long long #define INF 0x3f3f3f3f#define PI acos(-1.0)using namespace std;LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y)&#123; if(!b) &#123; x=1; y=0; return a; &#125; LL r=exgcd(b,a%b,x,y); LL t=y; y=x-(a/b)*y; x=t; return r;&#125;int main()&#123; LL a,b,x,y,n,m,l,k1,k2;//k2就是方程的一个x的解 cin&gt;&gt;x&gt;&gt;y&gt;&gt;m&gt;&gt;n&gt;&gt;l; LL d=x-y; a=l; b=n-m; LL c=exgcd(a,b,k1,k2);//c是最大公约数 if(d%c)//方程有解的条件 printf("Impossible"); else&#123; LL s=k2*d/c; LL v=a/c;//对结果取余的最小的范围 printf("%lld\n",(s%v+v)%v); &#125; return 0;&#125; 中国剩余定理（CRT）问题：今有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？ 定理1：几个数相加，如果存在一个加数，不能被整数a整除，那么它们的和，就不能被整数a整除。 定理2：两数不能整除，若除数扩大（或缩小）了几倍，而被除数不变，则其商和余数也同时扩大（或缩小）相同的倍数（余数必小于除数）。 简单的说就是求$M\%A=a,M\%B=b,M\%C=c…$的M，其中A、B、C……互质 123456789101112131415161718192021222324252627282930//chu是除数，yu是余数//注意只适用于除数两两互质#define ll long longint ex_gcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123; ll d; if(b == 0) &#123; x = 1; y = 0; return a; &#125; d = ex_gcd(b, a % b, y, x); y -= a / b * x; return d;&#125;ll chinese_remainder(ll b[], ll w[], ll len) &#123; ll i, d, x, y, m, n, ret; ret = 0; n = 1; for(i=0; i &lt; len ;i++) n *= w[i]; for(i=0; i &lt; len ;i++) &#123; m = n / w[i]; d=ex_gcd(w[i], m, x, y); ret = (ret + y*m*b[i]) % n; &#125; return (n + ret%n) % n;&#125; 中国剩余定理扩展求$M\%A=a,M\%B=b,M\%C=c…$的M，其中A、B、C……不互质 1234567891011121314151617181920212223242526272829ll a[maxn],b[maxn];//a是除数，b是余数ll ex_gcd(ll a,ll b,ll &amp;x,ll &amp;y) &#123; ll d; if(b==0) &#123; x=1; y=0; return a; &#125; d=ex_gcd(b,a%b,y,x); y-=a/b*x; return d;&#125;ll ex_crt(ll *a, ll *b, int n)&#123; ll M=a[1],R=b[1],x,y; for (int i=2;i&lt;=n;i++) &#123; ll d=ex_gcd(M,a[i],x,y); if((b[i]-R)%d) return -1; x=(b[i]-R)/d*x%(a[i]/d); R+=x*M; M=M/d*a[i]; R%=M; &#125; return R&gt;0?R:R+M;&#125; 欧拉函数、元根相关欧拉定理：若$n,a$为正整数，且$n,a$互质，则：$a^{φ(n)}\equiv1(mod n)$；即：$a^{φ(n)}$与1在模$m$下同余。 欧拉定理实际上是费马小定理的推广 欧拉函数对于正整数N,少于或等于N ([1,N]),且与N互质的正整数(包括1)的个数，记作$φ(n)$。欧拉函数公式：$φ(N)=N(1-1/P1)(1-1/P2)…(1-1/Pn)$ 直接求： 12345678910111213141516int Eular(int n)&#123; int eu=n; for (int i=2;i*i&lt;=n;i++) &#123; if(n%i==0) &#123; eu-=eu/i; while(n%i==0) n/=i; &#125; &#125; if(n&gt;1) //n本身也是个质因子 eu-=eu/n; return eu; &#125; 打表求 12345678910void Eular()&#123; euler[1]=1; for(int i=2;i&lt;maxn;i++) euler[i]=i; for(int i=2;i&lt;maxn;i++) if(euler[i]==i) for(int j=i;j&lt;maxn;j+=i) euler[j]=euler[j]/i*(i-1);//先进行除法是为了防止中间数据的溢出&#125; 原根定义：对于两个正整数$(a,m)=1$，由欧拉定理可知：存在$d\leq m-1$。比如说欧拉函数$d=φ(m)$，即小于等于$m$的正整数与$m$互质的正整数的个数，使得$a^d\equiv1 (mod m)$。由此，在$(a,m)=1$时，定义$a$对模$m$的指数$\delta m(a)$为使$a^d\equiv1(mod m)$成立的最小正整数$d$。由前知$\delta m(a)$一定小于等于$φ(m)$，若$\delta m(a)=φ(m)$，则称$a$为$m$的原根 应用一：求一个素数的最小的原根 m是正整数，a是正数，若$a\%m$的阶等于$φ(m)$，则a为模m的一个元根（$φ(m)$表示m的欧拉函数） 给出一个素数p，找出p最小的元根 我的理解：找到最小的数x，使得$x^{ϕ(n)}\%n=1$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;const int maxn=1e6+10;#define ll long longusing namespace std;int p[maxn];int k;ll Pow(ll a,ll b,ll c)&#123; ll res=1; while(b) &#123; if(b&amp;1) res=res*a%c; b&gt;&gt;=1; a=a*a%c; &#125; return res;&#125;// 查找n的素因子void getp(ll n)&#123; for(int i=2;i*i&lt;=n;i++) &#123; if(n%i==0) &#123; p[k++]=i; while(n%i==0) n/=i; &#125; &#125; if(n&gt;1) p[k++]=n;&#125;int main(int argc, char const *argv[])&#123; ios::sync_with_stdio(false); ll n; cin&gt;&gt;n; k=0; // 素数的欧拉函数值为n-1 // 对欧拉值进行分解 getp(n-1); for(int i=2;i&lt;n;i++) &#123; int flag=0; for(int j=0;j&lt;k;j++) &#123; if(Pow(i,(n-1)/p[j],n)==1) &#123; flag++; break; &#125; &#125; if(!flag) &#123; cout&lt;&lt;i&lt;&lt;endl; return 0; &#125; &#125; return 0;&#125; 应用二：求原根的个数 定理：如果$p$有原根，则它恰有$φ(φ(p))$个不同的原根，$p$为素数时，$φ(p)=p-1$,因此就有$φ(p-1)$个原根 对应题目：POJ1284 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;int Eular(int n)&#123; int eu=n; for (int i=2;i*i&lt;=n;i++) &#123; if(n%i==0) &#123; eu-=eu/i; while(n%i==0) n/=i; &#125; &#125; if(n&gt;1) //n本身也是个质因子 eu-=eu/n; return eu; &#125;int main(int argc, char const *argv[])&#123; int p; while(cin&gt;&gt;p) &#123; cout&lt;&lt;Eular(p-1)&lt;&lt;endl; &#125; return 0;&#125; 素数相关埃拉托斯特尼篩法时间复杂度：$O(nloglog(n))$，空间复杂度$O(n)$ 123456789101112// 素数标记为0，非素数标记为1inline void init()&#123; memset(vis,0,sizeof(vis)); vis[0]=vis[1]=1; for(int i=2;i&lt;maxn;i++) &#123; if(!vis[i]) for(int j=2;j*i&lt;maxn;j++) vis[j*i]=1; &#125;&#125; 欧拉筛法线性筛法，拿空间换时间 时间复杂度：$O(n)$ 1234567891011121314151617181920int vis[maxn];int prime[maxn];//用来存储素数int cnt;//素数个数inline void init()&#123; memset(vis,0,sizeof(vis)); memset(prime,0,sizeof(prime)); cnt=0; for(int i=2;i&lt;maxn;i++) &#123; if(!vis[i]) prime[cnt++]=i; for(int j=0;i*prime[j]&lt;n;j++) &#123; vis[i*prime[j]]=1; if(i%prime[j]==0) break; &#125; &#125;&#125; 筛素数+欧拉函数打表 12345678910111213141516171819202122232425262728293031323334 /* * 同时得到欧拉函数和素数表 */bool check[maxn+10];int phi[maxn+10];int prime[maxn+10];int tot; // 素数个数inline void phi_and_prime_table(int N)&#123; memset(check,false,sizeof(check)); phi[1]=1; tot=0; for(int i=2;i&lt;=N;i++) &#123; if(!check[i]) &#123; prime[tot++]=i; phi[i]=i-1; &#125; for(int j=0;j&lt;tot;j++) &#123; if(i*prime[j]&gt;N) break; check[i*prime[j]]=true; if (i%prime[j]==0) &#123; phi[i*prime[j]]=phi[i]*prime[j]; break; &#125; else phi[i*prime[j]]=phi[i]*(prime[j]-1); &#125; &#125;&#125; 唯一分解定理定义：每个大于1的自然数，若不是本身就是质数，就是可写为2个以上的质数的积，而且这些质因子按大小排列之后，写法仅有一种方式 唯一分解定理具有：唯一性（分配方式的唯一性）；存在性 例如：$6936=2^3\times3\times17^3$，$1200=2^4\times3\times5^2$ 即：对于任一大于$1$的正整数$n$，都可以唯一分解成有限个质数的乘积：$n=p^{a_{1}}_{1}p^{a_{2}}_{2}\ldots p^{a}_{k}=\prod ^{k}_{i=1}p^{a_{i}}_{i}$（这里$p_i$为素数，其对应的指数$a_i$为正整数） 求质因子及其个数描述：给出一个数字n，求它的质因子及其个数，写成形如：n=p1^a1 + p2^a2…..的形式 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6+10;int a[maxn];int an[maxn];int num;void Prime_num(int n)&#123; memset(a,0,sizeof(a)); memset(an,0,sizeof(an)); num=0; for(int i=2;i*i&lt;=n;i++) &#123; if(n%i==0) &#123; while(n%i==0) &#123; a[num]=i; n/=i; an[num]++; &#125; num++; &#125; &#125; if(n!=1) &#123; a[num]=n; an[num++]++; &#125;&#125;int main()&#123; int n; while(scanf("%d",&amp;n)!=EOF) &#123; Prime_num(n); printf("%d的质因子的个数有%d个\n",n,num); printf("%d=",n); for(int i=0;i&lt;num-1;i++) printf("%d^%d * ",a[i],an[i]); printf("%d^%d\n",a[num-1],an[num-1]); &#125; return 0;&#125; 约数个数定理根据唯一分解定理：$n=\prod ^{k}_{i=1}p^{a_{i}}_{i}$，可知n的正约数个数为：$f\left( n\right) =\prod ^{k}_{i=1}\left( a_{i}+1\right)$ 例如：求278000的约数个数 首先对278000进行质因数分解：$278000=2^4\times3^3\times5^3\times7^1$ 然后可以计算出278000的约数个数共有$(4+1)\times(3+1)\times(1+1)=40$个 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;int prime[maxn],nprime; int vis[maxn]; void getprime()&#123; nprime = 0; memset(vis,0,sizeof(vis)); for(int i = 2; i &lt;= maxn; i++) &#123; int t = maxn/i; for(int j = 2; j &lt;=t; j++) vis[i*j] = 1; &#125; for(int i = 2; i &lt;= maxn; i++) if(!vis[i]) prime[nprime++] = i; &#125; int factor_count(int n)&#123; int ans = 1,sum; int k = sqrt(n*1.0); for(int i = 0; prime[i] &lt; k; i++) &#123; if(n % prime[i] == 0) &#123; sum = 0; while(n % prime[i] == 0) &#123; sum++; n /= prime[i]; &#125; ans *= (sum+1); //ans为n的约数的个数 &#125; &#125; if(n &gt; 1) ans *= 2; return ans; &#125;int main(int argc, char const *argv[])&#123; int n; cin&gt;&gt;n; getprime(); printf("%d的约数一共有%d个\n",n,factor_count(n)); return 0;&#125; 给出$x,y$，求$x^y$的因子个数对10007取模的结果 公式：$x^y=(p_1^{e_1}p_2^{e_2}…p_k^{e_k})^y=p_1^{ye_1}p_2^{ye_2}…p_k^{ye_k}$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define LL long longusing namespace std;const int MAX = 1e6+10;const int INF = 0x3fffffff;int a[MAX];int an[MAX];int num;void Prime_num(int n)&#123; memset(a,0,sizeof(a)); memset(an,0,sizeof(an)); num=0; for(int i=2;i*i&lt;=n;i++) &#123; if(n%i==0)&#123; while(n%i==0) &#123; a[num] = i; n/=i; an[num]++; &#125; num++; &#125; &#125; if(n!=1) &#123; a[num] = n; an[num++] ++; &#125;&#125;int main()&#123; int n,b; while(scanf("%d%d",&amp;n,&amp;b)!=EOF) &#123; Prime_num(n); printf("%d的质因数个数有%d个\n",n,num); printf("%d = ",n); for(int i=0;i&lt;num-1;i++) printf("%d^%d * ",a[i],an[i]); printf("%d^%d\n",a[num-1],an[num-1]); for(int i=0;i&lt;num;i++) an[i] *= b; LL ans =1; for(int i=0;i&lt;num;i++) ans *= (an[i]+1); printf("%d^%d的约数个数对10007取模后的结果为：%lld\n",n,b,ans); &#125; return 0;&#125; 约数和定理对于一个大于1正整数n可以分解质因数：$n=p_1^{a_1}\times p_2^{a_2}\times p_3^{a_3}\times …\times p_k^{a_k}$,则由约数个数定理可知n的正约数有$(a_1+1)(a_2+1)(a_3+1)…(a_k+1)$个，那么n的(a₁+1)(a₂+1)(a₃+1)…(ak+1)个正约数的和为$f(n)=(p_1^0+p_1^1+p_1^2+…p_1^a1)(p_2^0+p_2^1+p_2^2+…p_2^a2)…(p_k^0+p_k^1+p_k^2+…p_k^ak)$ 123456789101112131415161718192021222324252627282930313233343536373839404142int prime[maxn],nprime;int vis[maxn];void getprime()&#123; nprime = 0; memset(vis,0,sizeof(vis)); for(int i = 2; i &lt;= 450; i++)&#123; int t = 450/i; for(int j = 2; j &lt;=t; j++) vis[i*j] = 1; &#125; for(int i = 2; i &lt;= 450; i++)&#123; if(!vis[i]) prime[nprime++] = i; &#125;&#125;int pow_mod(int a,int n,int MOD)&#123; int ans = 1; while(n)&#123; if(n&amp;1) ans = (ans*a)%MOD; n &gt;&gt;= 1; a = (a*a)%MOD; &#125; return ans;&#125;int factor_sum(int n)&#123; int ans = 1,sum; int k = sqrt(n*1.0); for(int i = 0; prime[i] &lt; k; i++)&#123; if(n % prime[i] == 0)&#123; sum = 0; while(n%prime[i] == 0)&#123; sum++; n /= prime[i]; &#125; ans *= (pow_mod(prime[i],sum+1,MOD)-1)/(prime[i]-1); &#125; &#125; if(n &gt; 1) ans *= ans(n*n-1)/(n-1); return ans;&#125; 组合数相关12345678910111213141516//求组合数 C(a, b)int C(int a,int b)&#123; int sum=1; for(int i=1;i&lt;=b;i++) sum=sum*(a+1-i)/i; return sum;&#125;//求排列数 A(a, b)int A(int a,int b)&#123; int sum=1; for(int i=0;i&lt;b;i++) sum=sum*(n-i); return sum;&#125; 卢卡斯定理求组合数表达式：$C_n^m\%mod=C_{n/p}^{m/p}\times C_{n\%mod}^{m\%mod}\%mod$ 递推式：$(C_{n\%mod}^{m\%mod}\times Lucas(n/p,m/p))\%mod$（递归出口为$m==0$，$return 1$） 注意：mod必须为质数 123456789101112131415161718192021222324252627282930313233343536373839404142434445//求 C（r, n）% MOD//数据范围： 0 &lt;= r、n &lt;= 1e5#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e5+10;ll n,m,MOD;//题目保证了MOD为质数ll fac[maxn];ll pow(ll a,ll b)&#123; ll r=1,base=a%MOD; while(b) &#123; if(b&amp;1) r=r*base%MOD; base=base*base%MOD; b&gt;&gt;=1; &#125; return r%MOD;&#125;void init()&#123; fac[0]=1; for(ll i=1;i&lt;=maxn;i++) fac[i]=fac[i-1]*i%MOD;&#125;ll C(ll n,ll m)&#123; if(n&lt;m) return 0; return fac[n]*pow(fac[m]*fac[n-m],MOD-2)%MOD;&#125;ll Lucas(ll n,ll m)&#123; if(!m) return 1; else return Lucas(n/MOD,m/MOD)%MOD*C(n%MOD,m%MOD)%MOD;&#125;int main(int argc, char const *argv[])&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;MOD; init(); cout&lt;&lt;Lucas(n,m)&lt;&lt;endl; return 0;&#125; 拓展卢卡斯定理$1\leq m\leq n\leq1e18$，$2\leq mod\leq1e6$，不保证$mod$是素数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll p;const int MAXN=11;ll n,m;ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(!b) &#123; x=1; y=0; return a; &#125; ll res=exgcd(b,a%b,x,y),t; t=x;x=y;y=t-a/b*y; return res;&#125;ll power(ll a,ll b,ll mod)&#123; ll sm; for(sm=1;b;b&gt;&gt;=1,a=a*a%mod) if(b&amp;1) sm=sm*a%mod; return sm;&#125;ll fac(ll n,ll pi,ll pk)&#123; if(!n) return 1; ll res=1; for(ll i=2;i&lt;=pk;++i) if(i % pi) (res*=i)%=pk; res=power(res,n/pk,pk); for(ll i=2;i&lt;=n%pk;++i) if(i%pi) (res*=i)%=pk; return res*fac(n/pi,pi,pk)%pk;&#125;ll inv(ll n,ll mod)&#123; ll x,y; exgcd(n,mod,x,y); return (x+=mod)&gt;mod?x-mod:x;&#125;ll CRT(ll b, ll mod)&#123; return b*inv(p/mod,mod)%p*(p/mod)%p;&#125;ll C(ll n,ll m,ll pi,ll pk)&#123; ll up=fac(n,pi,pk),d1=fac(m,pi,pk),d2=fac(n-m,pi,pk); ll k=0; for(ll i=n;i;i/=pi) k+=i/pi; for(ll i=m;i;i/=pi) k-=i/pi; for(ll i=n-m;i;i/=pi) k-=i/pi; return up*inv(d1,pk)%pk*inv(d2,pk)%pk*power(pi,k,pk)%pk;&#125;ll exlucus(ll n,ll m)&#123; ll res=0,tmp=p,pk; int lim=sqrt(p)+5; for(int i=2;i&lt;=lim;++i) if(tmp%i==0) &#123; pk=1; while(tmp%i==0) pk*=i,tmp/=i; (res+=CRT(C(n,m,i,pk),pk))%=p; &#125; if(tmp&gt;1) (res+=CRT(C(n,m,tmp,tmp),tmp))%=p; return res;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;p; cout&lt;&lt;exlucus(n,m)&lt;&lt;endl; return 0;&#125; 容斥定理描述：要计算几个集合并集的大小，我们要先将所有单个集合的大小计算出来，然后减去所有两个集合相交的部分，再加回所有三个集合相交的部分，再减去所有四个集合相交的部分，依此类推，一直计算到所有集合相交的部分。 公式：$\sum _ { 1 \leq i \leq m } \left| A _ { i } \right| - \sum _ { 1 \leq i &lt; j \leq m } \left| A _ { i } \cap A _ { j } \right| + \sum _ { 1 \leq i &lt; j &lt; k \leq m } \left| A _ { i } \cap A _ { j } \cap A _ { k } \right| - \cdots + ( - 1 ) ^ { m - 1 } \left| A _ { 1 } \cap A _ { 2 } \cap \cdots \cap A _ { m } \right|$ 公式的解释：目的是求解m个集合的并集，首先将m个集合相加，减去集合间两两相交的部分，加上三三相交的部分，再减去四四相交的部分……一直到m个集合相交的部分，当m为偶数时，最后一项的符号为负数，否则为正数。 应用一： 计算$1 \sim n$之间不能整除2,5,7的正整数有多少个 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main(int argc, char const *argv[])&#123; int n; cin&gt;&gt;n; int a=n/2; int b=n/5; int c=n/7; int d=n/(2*5); int e=n/(2*7); int f=n/(5*7); int g=n/(2*5*7); int ans=n-(a+b+c-d-e-f+g); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 应用二： 计算$1 \sim n$之间不能整除a,b,c的正整数有多少个（应用一的升级版，对应NYOJ1160） 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll lcm(ll a,ll b)&#123; return a/__gcd(a,b)*b;&#125;int main(int argc, char const *argv[])&#123; ll n,a,b,c; while(cin&gt;&gt;n&amp;&amp;n) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; ll _a=n/a; ll _b=n/b; ll _c=n/c; ll d=n/(lcm(a,b)); ll e=n/(lcm(a,c)); ll f=n/(lcm(b,c)); ll g=n/(lcm(a,lcm(b,c))); ll ans=n-(_a+_b+_c-d-e-f+g); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 与二进制结合的容斥定理二进制枚举的模板 12345678int n; for(int i=0;i&lt;(1&lt;&lt;n);i++)&#123; // 相当于枚举所有的情况 o(2^n*n) for(int j = 0; j &lt; n ;j++) &#123; printf("%d ",(i&gt;&gt;j)&amp;1); &#125;&#125; 应用一：求$[a,b]$区间与$n$互质的数的个数（对应题目：HDU4135） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;#define ll long longconst int maxn=1e6+10;using namespace std;int A[maxn];ll lcm(ll a,ll b)&#123; return a/__gcd(a,b)*b;&#125;int main(int argc, char const *argv[])&#123; int t; ll a,b,n; scanf("%d",&amp;t); int x=0; while(t--) &#123; ll ans1,ans; ans=ans1=0; map&lt;int,int&gt;mmp;//记录质因子 scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;n); ll m=n; int k=0; for(int i=2;i*i&lt;=m;i++) &#123; if(m%i==0) &#123; while(m%i==0) &#123; if(mmp[i]==0) &#123; A[k++]=i; mmp[i]=1; &#125; m/=i; &#125; &#125; &#125; if(m&gt;1) &#123; A[k++]=m; mmp[m]=1; &#125; for(int i=1;i&lt;(1&lt;&lt;k);i++) &#123; int cnt=0; ll tmp=1; for(int j=0;j&lt;k;j++) &#123; if(i&gt;&gt;j&amp;1) &#123; cnt++; tmp=lcm(tmp,A[j]); &#125; &#125; if(cnt&amp;1) &#123; ans+=(a-1)/tmp; ans1+=(b)/tmp; &#125; else &#123; ans-=(a-1)/tmp; ans1-=b/tmp; &#125; &#125; printf("Case #%d: %lld\n",++x,(b-a+1)-ans1+ans); &#125; return 0;&#125; 应用二：求$[1,n]$中与$n$互质的数的平方和 平方和公式：$\sum ^{n}_{i=1}i^{2}=\dfrac {n\left( n+1\right) \left( 2n+1\right) }{6}$不互质平方和为：$\sum ^{n}_{k=1}\left( k\ast m\right) ^{2}=m^{2}\sum ^{\dfrac {n}{m}}_{k=1}k^{2}=m^{2}\dfrac {\dfrac {n}{m}\left( \dfrac {n}{m}+1\right) \left( 2\dfrac {n}{m}+1\right) }{6}$ 把n进行质因子分解，进行容斥，结果=总和-不互质的平方和 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt; #include &lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn = 1e6 + 10;LL arr[maxn];int p;LL get(LL x, LL y) &#123; LL cnt = x / y; //这里return的是推出来的公式 return ((y * y) * (cnt * (cnt + 1) * (2 * cnt + 1) / 6));&#125;void getp(LL n) &#123; //分解质因子 p = 0; for(int i = 2; i * i &lt;= n; i++) &#123; if(n % i == 0) &#123; arr[p++] = i; while(n % i == 0) n /= i; &#125; &#125; if(n &gt; 1) arr[p++] = n;&#125;int main() &#123; LL n; while(scanf("%lld", &amp;n) != EOF) &#123; if(n == 0 || n == 1) &#123; puts("0"); continue; &#125; getp(n); LL sum = n * (n + 1) * (2 * n + 1) / 6; LL ans = 0; for(int i = 1; i &lt; (1 &lt;&lt; p); i++) &#123; //状压 LL res = 0, cnt = 1; for(int j = 0; j &lt; p; j++) &#123; if(i &amp; (1 &lt;&lt; j)) &#123; cnt *= arr[j]; res++; &#125; &#125; if(res &amp; 1) ans += get(n, cnt); //容斥 else ans -= get(n, cnt); &#125; printf("%lld\n", sum - ans); &#125; return 0;&#125; 鸽巢原理（抽屉原理）描述： 若有$n$个笼子和$n+1$只鸽子，所有的鸽子都被关在鸽笼里，那么至少有一个笼子有至少$2$只鸽子。 若有$n$个笼子和$kn+1$只鸽子，所有的鸽子都被关在鸽笼里，那么至少有一个笼子有至少$k+1$只鸽子。 解题关键：弄清题目中，谁是鸽子谁是巢 例题题1：证明，如果从$\{1,2,3,….3n\}$中选择$n+1$个整数，那么总存在两个整数，他们之间的差最多为$2$。 解：分组化简。将这$3n$个整数分组，$\{1,2,3\}$，$\{4,5,6\}$…..$\{3n-2,3n-1,3n\}$ 共$n$组。这样题目等价于：将$n+1$个整数放在$n$个盒子里。则根据原理，至少存在一个盒子里有两个数，这两个数之差最多为2。 题2：证明，对于任意给定的52个整数，存在其中的两个整数，要么两者的和能被100整除。要么两者的差能被100整除。 解：还是分组化简！将数这样进行分组：将所有整数的后两位尾数分组。$\{+0,-0,+100,-100,+200,-200….\}$，$\{+1,-1,+99,-99,+101,-101,+199,-199,+201,-201……\}$……$\{+49,-49,+51,-51,+149,-149,+151,……\}$$\{+50,-50,+150,-150,+250,-250……\}$ 这样。将所有的能被$100$整数的数分为$51$组（鸽子）。而从中取$52$个，（巢）。必有两个在同一组。得证。 题3：一个学生有$37$天来准备考试，她知道她需要不超过$60$小时的学习时间，她还希望每天至少学习$1$小时。证明，无论如何安排学习时间（每天都是整数小时），都存在连续的若干天，在此期间她恰好学习了$13$个小时。 证明：令$a_1$为她第一天学习的小时数，$a_2$为第二天的学习时数。这样。存在这样一个递增数列$a_1,a_2,a_3,……a_{37}$。满足：$1\leq a_1&lt;a_2&lt;a_3……a_{37}\leq 60$。同时，将这个数列每个数都加上13。则存在数列：$14\leq a1+13&lt;a2+13&lt;a3+13……a37+13\leq 73$。而这两个数列共有$37+37=74$个成员。这样。鸽子和巢终于出现^_^必然存在一个$a_i$,和一个$a_j$.使得$a_i=a_j+13$.就是说这两个数列中必然有两个差为$13$的数。得证。 题4：一个袋子装了$100$个苹果，$100$个香蕉，$100$个橘子，$100$个梨子。如果我们每分钟从袋子里取出$1$种水果，那么需要多少时间我就能肯定至少已经拿出1打相同种类的水果。 解：根据鸽巢原理加强形式：如果$q_1,q_2,,,,,q_n$为正整数，将$q_1+q_2+…..q_n-n+1$个物体放入$n$个盒子里。那么，至少存在一个盒子含有$q_n$个物体。对于此题：我们需要取$12$个水果。设已经取出了$11$个水果，还剩下一个。那么需要$11\times4+1$分钟。 题5：证明对于任意$n+1$个整数$a_1,a_2,…..a_{n+1}$存在两个整数$a_i和a_j$，$i\neq j$，使得$a_i-a_j$能够被$n$整除。 解：由于任一整数被n整除的余数有$0,1,2,……n-1$。 共$n$种，对于$n+1$个数，由鸽巢原理可得证。即存在$a_i,a_j$。$a_i=b_n+r,a_j=c_n+r (b&gt;c)$。$a_i-a_j=(b-c)n$。所以$n|a_i-a_j$。至少两个整数被$n$整除的余数相等。 题6：证明，边长为$2$的正方形中取$5$个点，当中存在$2$个点，这$2$点的距离至多为$\sqrt2$ 解：将正方形分成四等分即可。 Ramsey定理（拉姆齐二染色定理）描述：在$6$个人中，总有$3$个人互相认识或互相皆不认识 应用：要找这样一个最小的数$R(k,l)=n$，使得$n$个人中必定有$k$个人相识或$l$个人互不相识 一些非平凡Ramsey数： R(3, 3) = 6R(3, 4) = 9R(3, 5) = 14R(3, 6) = 18R(3, 7) = 23R(3, 8) = 28R(3, 9) = 3640&lt;=R(3, 10)&lt;=43R(4,4) = 18R(4,5) = 2543&lt;=R(5,5)&lt;=5 卡特兰数应用： （1）一个栈(无穷大)的进栈序列为$1，2，3，…，n$，有多少个不同的出栈序列?（2）在$n\times n$的格子中，只在下三角行走，每次横或竖走一格，有多少中走法？（3）将一个凸$n+2$边形区域分成三角形区域的方法数？（4）圆上选择$2n$个点,将这些点成对连接起来使得所得到的$n$条线段不相交的方法数？（5）有$2n$个人排成一行进入剧场。入场费$5$元。其中只有$n$个人有一张5元钞票，另外$n$人只有$10$元钞票，剧院无其它钞票，问有多少中方法使得只要有$10$元的人买票，售票处就有5元的钞票找零？ 公式：$h\left( n\right) =\dfrac {C^{n}_{2n}}{n+1} \left(n= 1,2,3\ldots \right) $或$h\left( n\right) =C^{n}_{2n}-C^{n-1}_{2n} \left(n= 1,2,3\ldots \right) $ 代码一：大数版本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include&lt;string.h&gt;int a[105][1000];//大数运算 int b[105]; //储存对应卡特兰数有多少位 void catalan() //求卡特兰数&#123; int i, j, len, carry, temp; a[1][0] = b[1] = 1; len = 1; for(i = 2; i &lt;= 100; i++) &#123; for(j = 0; j &lt; len; j++) //乘法 a[i][j] = a[i-1][j]*(4*(i-1)+2); carry = 0; for(j = 0; j &lt; len; j++) //处理相乘结果 &#123; temp = a[i][j] + carry; a[i][j] = temp % 10; carry = temp / 10; &#125; while(carry) //进位处理 &#123; a[i][len++] = carry % 10; carry /= 10; &#125; carry = 0; for(j = len-1; j &gt;= 0; j--) //除法 &#123; temp = carry*10 + a[i][j]; a[i][j] = temp/(i+1); carry = temp%(i+1); &#125; while(!a[i][len-1]) //高位零处理 len --; b[i] = len; &#125;&#125; int main() &#123; catalan(); for(int i=1;i&lt;=100;i++) &#123; for(int j=b[i]-1;j&gt;=0;j--) &#123; printf("%d",a[i][j]); &#125; printf("\n"); &#125;&#125; 代码二：正常取模版本 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define ll long long#define ms(a) memset(a,0,sizeof(a))const int N=1e4+10;const ll Mod=19260817;using namespace std;ll fat[N];ll inv[N];ll finv[N];ll n;void Init()&#123; ll i; for(i=2,inv[1]=1;i&lt;N;i++) inv[i]=((Mod - Mod/i)*1ll*inv[Mod%i])%Mod; for(i=1,fat[0]=1,finv[0]=1;i&lt;N;i++) &#123; fat[i]=(fat[i-1]*i)%Mod; finv[i]=(finv[i-1]*inv[i])%Mod; &#125;&#125;ll C(ll n,ll m)&#123; ll res=1; res=res*fat[n]%Mod; res=(res*finv[m]%Mod*finv[n-m]%Mod); return res;&#125;ll Ctl(ll n)&#123; return (C(2*n,n)-C(2*n,n-1)+Mod)%Mod;&#125;int main(int argc, char const *argv[])&#123; ios::sync_with_stdio(false); Init(); while(cin&gt;&gt;n) cout&lt;&lt;Ctl(n)&lt;&lt;endl; return 0;&#125; 环涂色问题题目描述：如下图，有$m(m\geq2)$个区域，如果给你$n(n\geq3)$种颜色，给这$m$个区域涂色，要求相邻的区域颜色不能一样，问一共有几种涂法 公式：$f(m)=(-1)^m\times (n-1)+(n-1)^m$ 阶乘问题大数阶乘代码一： 计算$1e6$以内的数的阶乘即位数 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;int main() &#123; int carry; //进位 int n,j; int a[40001]; //保存结算结果的数组 int digit; //结果的最高位 int temp,i; while(scanf("%d",&amp;n)!=EOF) &#123; a[0]=1;digit=1; for(i=2; i&lt;=n; i++) &#123; for(carry=0,j=1; j&lt;=digit; ++j) &#123; temp=a[j-1]*i+carry; //计算结果 a[j-1]=temp%10; //计算结果 carry=temp/10; //计算进位 &#125; while(carry) &#123; a[++digit-1]=carry%10; //取当前位 carry/=10; //计算进位 &#125; &#125; for(int k=digit; k&gt;=1; --k) printf("%d",a[k-1]); printf("\n"); printf("length=%d\n",digit); &#125; return 0;&#125; 代码二： 计算$1e4$以内的数的阶乘 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll l=1e14;const int maxn=20000;ll f[maxn+1];int main()&#123; ll n,c; ll d=1; scanf("%lld",&amp;n); memset(f,0,sizeof(f)); f[0]=1; for(int i=1;i&lt;=n;i++) &#123; c=0; for(int j=0;j&lt;d;j++) &#123; ll s=f[j]*i+c; f[j]=s%l; c=s/l; &#125; if(c) f[d++]=c; &#125; printf("%lld",f[d-1]); for(int j=d-2;j&gt;=0;j--) printf("%014lld",f[j]); printf("\n"); return 0;&#125; 斯特林公式应用：用来求$n!$的近似值 公式为：$\lim _{n\rightarrow \infty }\left( \dfrac {n}{\pi }\right) ^{n}\sqrt {\dfrac {2\pi n}{n!}}=1$，可以得出：$n!\approx \sqrt {2\pi n}\left( \dfrac {n}{e}\right) ^{n}$ 计算$n!$的长度公式：$len=\dfrac {\lg 2\pi n}{2}+n\lg \dfrac {n}{e}+1$（$len$向下取整） 代码： 12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;#define pi acos(-1.0) const double E=exp(1);int main()&#123; int t; int n; cin&gt;&gt;n; long long ans=1+0.5*log10(2*pi*n)+n*log10(n/E); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 阶乘最后非$0$位复杂度：$O(nlogn)$ 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define maxn 10000int lastdigit(char buf[])&#123; const int mod[20]=&#123;1,1,2,6,4,2,2,4,2,8,4,4,8,4,6,8,8,6,8,2&#125;; int len=strlen(buf),a[maxn],i,c,ret=1; if(len==1) return mod[buf[0]-'0']; for(i=0;i&lt;len;i++) a[i]=buf[len-1-i]-'0'; for(;len;len-=!a[len-1]) &#123; ret=ret*mod[a[1]%2*10+a[0]]%5; for(c=0,i=len-1;i&gt;=0;i--) c=c*10+a[i],a[i]=c/5,c%=5; &#125; return ret+ret%2*5;&#125;int main()&#123; char n[maxn]; int a; while(scanf("%s",n)!=EOF) &#123; a=lastdigit(n); printf("%d\n",a); &#125; return 0;&#125; 阶乘末尾$0$的个数12345678910int find(int n)&#123; int count=0; while(n&gt;0) &#123; count+=n/5; n=n/5; &#125; return count;&#125; 计算逆元逆元的定义：对于正整数$a$和$m$，如果$ax\equiv 1(mod m)$，那么把这个同余方程中$x$的最小正整数叫做$a$模$m$的逆元 EXGCD计算逆元1234567891011//要求a和m互质// ax = 1(mod m)int mod_reverse(int a,int m)&#123; int x,y; int d=exgcd(a,m,x,y); if(d==1) return (x%m+m)%m; else return -1;&#125; 递归写法注意：只能计算$a&lt;m$的情况，并且要保证a和m互质 1234567//求 ax = 1( mod m) 的 x 值，就是逆元 (0&lt;a&lt;m)int inv(int a,int m)&#123; if(a==1) return 1; return inv(m%a,m)*(m-m/a)%m;&#125; 利用欧拉函数求逆元x和m互质（m可以使非素数）；时间复杂度：$O({\sqrt{(n)}})$ 123456789101112131415161718192021//求欧拉函数值int eurler_phi(int n)&#123; int res = n; for(int i = 2; i * i &lt;= n; i++) &#123; if(n % i == 0) &#123; res = res / i * (i - 1); while(n % i == 0) n /= i; &#125; &#125; if(n != 1) res = res / n * (n - 1); return res;&#125;//求逆元int inv(int a,int m)&#123; return Pow(a,eurler_phi(m)-1,m);&#125; 快速幂求逆元要求m为素数，a与m互质 公式：$inv=a^{m-1}\%m$ 推导：$a^{m-1}\equiv1(mod m)\Rightarrow a\cdot a^{m-2}\equiv1(mod m)\Rightarrow a^{m-2}\equiv\dfrac {1}{a}(mod m)$ 12345// a和m互质，m为素数int inv(int a,int m)&#123; return Pow(a,m-2,m);&#125; 线性时间求逆元时间复杂度：$O(n)$ 12345// 逆元打表int inv[maxn];inv[1] = 1;for(int i=2;i&lt;maxn;i++) inv[i]=(mod-mod/ i)*inv[mod%i]%mod;]]></content>
      <categories>
        <category>template</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模板（未完成）]]></title>
    <url>%2Ftemplate%2F%E6%A8%A1%E6%9D%BF2%2F</url>
    <content type="text"><![CDATA[数论 素数素数筛法1.线性筛选法——欧拉筛法欧拉筛法通过红色标记部分保证每个合数只会被它的最小质因数筛去，时间复杂度降低到O(n)。代码实现： 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXN 100000#define MAXL 1000000int prime[MAXN];_Bool check[MAXL]; int main(void)&#123; int n, count; while (~scanf(&quot;%d&quot;, &amp;n)) &#123; memset(check, 0, sizeof(check)); count = 0; for (int i = 2; i &lt;= n; i++) &#123; if (!check[i]) prime[count++] = i; for (int j = 0; j &lt; count; j++) &#123; if (i*prime[j] &gt; MAXL) break; // 过大的时候跳出 check[i*prime[j]] = 1; if ((i%prime[j]) == 0) // 如果i是一个合数，而且i % prime[j] == 0 break; &#125; &#125; for (int i = 0; i &lt; count; i++) printf(&quot;%d\n&quot;, prime[i]); &#125; return 0;&#125; 2.小应用：求n的阶乘的因子数，题目n的范围（1000）；数论的原理，n的阶乘的因子个数等于n的素因子个数的幂的乘积；代码实现： 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int k[1005]; const LL mod=1e9+7;int main()&#123; int n; cin&gt;&gt;n; for(int i=2;i&lt;=n;i++) &#123; int l=i; for(int j=2;j&lt;=l;j++) &#123; while(l%j==0) &#123; k[j]++; l/=j; &#125; &#125; if(l) k[l]++; &#125; LL sum=1; for(int i=2;i&lt;=n;i++) &#123; if(k[i]) &#123; sum*=(k[i]+1); sum=sum%mod; &#125; &#125; printf(&quot;%lld\n&quot;,sum%mod); return 0;&#125; 3.查找出小于等于MAXN的素数（生成连续素数表）123456789101112131415161718192021222324252627/* * 素数筛选，查找出小于等于MAXN的素数 * prime[0]存素数的个数 */const int MAXN = 100000;int prime[MAXN + 1];void getPrime()&#123; memset(prime, 0, sizeof(prime)); for (int i = 2; i &lt;= MAXN; i++) &#123; if (!prime[i]) &#123; prime[++prime[0]] = i; &#125; for (int j = 1; j &lt;= prime[0] &amp;&amp; prime[j] &lt;= MAXN / i; j++) &#123; prime[prime[j] * i] = 1; if (i % prime[j] == 0) &#123; break; &#125; &#125; &#125;&#125; 4.同时得到欧拉函数表和素数表（线性筛）123456789101112131415161718192021222324252627282930313233343536373839404142 /* * 同时得到欧拉函数和素数表 */const int MAXN = 10000000;bool check[MAXN + 10];int phi[MAXN + 10];int prime[MAXN + 10];int tot; // 素数个数void phi_and_prime_table(int N)&#123; memset(check, false, sizeof(check)); phi[1] = 1; tot = 0; for (int i = 2; i &lt;= N; i++) &#123; if (!check[i]) &#123; prime[tot++] = i; phi[i] = i - 1; &#125; for (int j = 0; j &lt; tot; j++) &#123; if (i * prime[j] &gt; N) &#123; break; &#125; check[i * prime[j]] = true; if (i % prime[j] == 0) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; else &#123; phi[i * prime[j]] = phi[i] * (prime[j] - 1); &#125; &#125; &#125; return ;&#125; 二、GCD &amp;&amp; exgcd1.GCD: 公式：gcd(a,b) = gcd(b, a%b)求a,b 最大公约数代码实现: 123456ll gcd(ll a, ll b)&#123; if(b == 0) return a; return gcd(b, a % b);&#125; 2.EXGCD: 公式： ax+by=c; 功能：用来解二元一次方程组； 注意事项：a,b均为正数; 取最小正整数解： 例题：。设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define LL long long #define INF 0x3f3f3f3f#define PI acos(-1.0)using namespace std;LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y)&#123; if(!b) &#123; x=1; y=0; return a; &#125; LL r=exgcd(b,a%b,x,y); LL t=y; y=x-(a/b)*y; x=t; return r;&#125;int main()&#123; LL a,b,x,y,n,m,l,k1,k2;//k2就是方程的一个x的解 cin&gt;&gt;x&gt;&gt;y&gt;&gt;m&gt;&gt;n&gt;&gt;l; LL d=x-y; a=l; b=n-m; LL c=exgcd(a,b,k1,k2);//c是最大公约数 if(d%c)//方程有解的条件 printf(&quot;Impossible&quot;); else&#123; LL s=k2*d/c; LL v=a/c;//对结果取余的最小的范围 printf(&quot;%lld\n&quot;,(s%v+v)%v); &#125; return 0;&#125; 三、唯一分解定理 任何大于１的自然数，都可以唯一分解成有限个质数的乘积 例如对于大于1的自然数n，这里Pi均为质数，其指数ai是正整数。这样的分解称为的标准分解式。1.找出一个数n的所有素因子 1234567891011121314typedef long long ll;ll fac[10050], num;//素因数,素因数的个数void init(ll n) &#123;//唯一分解定理 num = 0; ll cpy = n; int m = (int)sqrt(n + 0.5); for (int i = 2; i &lt;= m; ++i) &#123; if (cpy % i == 0) &#123; fac[num++] = i; while (cpy % i == 0) cpy /= i; &#125; &#125; if (cpy &gt; 1) fac[num++] = cpy;&#125; 2.约数和定理&amp;&amp;约数个数定理(1) 约数个数定理约数个数定理可以计算出一个数约数的个数根据唯一分解定理：则n的正约数的个数就是将378000分解质因数378000=2^ 4×3^ 3×5^ 3×7^1由约数个数定理可知378000共有正约数(4+1)×(3+1)×(3+1)×(1+1)=160个。代码实现 12345678910111213141516171819202122232425262728293031323334int prime[maxn],nprime; int vis[maxn]; void getprime()&#123; nprime = 0; memset(vis,0,sizeof(vis)); for(int i = 2; i &lt;= 450; i++)&#123; int t = 450/i; for(int j = 2; j &lt;=t; j++) vis[i*j] = 1; &#125; for(int i = 2; i &lt;= 450; i++)&#123; if(!vis[i]) prime[nprime++] = i; &#125; &#125; int factor_count(int n)&#123; int ans = 1,sum; int k = sqrt(n*1.0); for(int i = 0; prime[i] &lt; k; i++)&#123; if(n % prime[i] == 0)&#123; sum = 0; while(n % prime[i] == 0)&#123; sum++; n /= prime[i]; &#125; ans *= (a+1); //ans为n的约数的个数 &#125; &#125; if(n &gt; 1) ans *= 2; return ans; &#125; (2)约数和定理n的(a₁+1)(a₂+1)(a₃+1)…(ak+1)个正约数的和为f(n)=(p1 ^ 0+p1 ^ 1+p1 ^ 2+…p1^ a1)(p2 ^ 0+p2 ^ 1+p2 ^ +…p2 ^ a2)…(pk ^ 0+pk^1+pk ^ 2+…pk ^ ak）代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445int prime[maxn],nprime;int vis[maxn]; void getprime()&#123; nprime = 0; memset(vis,0,sizeof(vis)); for(int i = 2; i &lt;= 450; i++)&#123; int t = 450/i; for(int j = 2; j &lt;=t; j++) vis[i*j] = 1; &#125; for(int i = 2; i &lt;= 450; i++)&#123; if(!vis[i]) prime[nprime++] = i; &#125;&#125; int pow_mod(int a,int n,int MOD)&#123; int ans = 1; while(n)&#123; if(n&amp;1) ans = (ans*a)%MOD; n &gt;&gt;= 1; a = (a*a)%MOD; &#125; return ans;&#125; int factor_sum(int n)&#123; int ans = 1,sum; int k = sqrt(n*1.0); for(int i = 0; prime[i] &lt; k; i++)&#123; if(n % prime[i] == 0)&#123; sum = 0; while(n%prime[i] == 0)&#123; sum++; n /= prime[i]; &#125; ans *= (pow_mod(prime[i],sum+1,MOD)-1)/(prime[i]-1); &#125; &#125; if(n &gt; 1) ans *= ans(n*n-1)/(n-1); return ans;&#125; 杜教筛: 有些时候也有一些奇形怪状的函数比如 ，其中是pi质数，ai&gt;0且。接着，出题人给了你一个挺大的n，n一般来说都有10^10左右。最后，他想让你输出的值（可能会对一个大数取模）。杜教筛差不多就是拿来解决这类问题哒..它给出了一个比较通用的技巧使得可以在或者的时间复杂度内求的答案。例如：f(i,j)是一个积性函数，求前缀和，可以用杜教筛 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include &lt;tr1/unordered_map&gt;typedef long long ll;using namespace std;using namespace std::tr1; const int P=1000000007;const int inv2=(P+1)/2;const int inv3=(P+1)/3;const int maxn=1000000; int prime[2000000],num;int miu[maxn+5];ll sumd[maxn+5],t1[maxn+5],t2[maxn+5]; int d[maxn+5]; inline void Pre()&#123; miu[1]=1; sumd[1]=1; for (int i=2;i&lt;=maxn;i++)&#123; if (!d[i]) d[i]=prime[++num]=i,sumd[i]=1+i,t1[i]=1+i,t2[i]=i,miu[i]=-1; for (int j=1;j&lt;=num &amp;&amp; (ll)i*prime[j]&lt;=maxn;j++)&#123; d[i*prime[j]]=prime[j]; int k=i*prime[j]; if (i%prime[j]==0)&#123; miu[k]=0; t2[k]=t2[i]*prime[j],t1[k]=t1[i]+t2[k],sumd[k]=sumd[i]/t1[i]*t1[k]; break; &#125; miu[i*prime[j]]=miu[i]*miu[prime[j]]; sumd[k]=sumd[i]*sumd[prime[j]],t1[k]=1+prime[j],t2[k]=prime[j]; &#125; &#125; for (int i=1;i&lt;=maxn;i++) miu[i]=((ll)i*((P+miu[i])%P)%P+miu[i-1])%P,(sumd[i]+=sumd[i-1])%=P;&#125; unordered_map&lt;ll,int&gt; S; inline void add(int &amp;x,int y)&#123; x+=y; if (x&gt;=P) x-=P;&#125; inline int sum1(ll n)&#123; return (n+1)%P*(n%P)%P*inv2%P;&#125;inline int sum1(ll l,ll r)&#123; return (l+r)%P*((r-l+1)%P)%P*inv2%P; &#125; inline int Sum(ll n)&#123; if (n&lt;=maxn) return miu[n]; if (S.find(n)!=S.end()) return S[n]; int tem=1; ll l,r; for (l=2;l*l&lt;=n;l++) add(tem,P-l*Sum(n/l)%P); for (ll t=n/l;l&lt;=n;l=r+1,t--) r=n/t,add(tem,P-(ll)sum1(l,r)*Sum(t)%P); return S[n]=tem;&#125;/*inline int F(ll n)&#123; int t1=0,t2=0; ll l,r; for (l=1;l*l&lt;=n;l++) add(t1,l%P*(n/l)%P),add(t2,sum1(n/l)%P); for (ll t=n/l;l&lt;=n;l=r+1,t--) r=n/t,add(t1,(ll)sum1(l,r)*(n/l)%P),add(t2,(r-l+1)%P*sum1(n/l)%P); return (ll)t1*t2%P;&#125;*/ inline int F(ll n)&#123; if (n&lt;=maxn) return (ll)sumd[n]*sumd[n]%P; int t1=0; ll l,r; for (l=1;l*l&lt;=n;l++) add(t1,l%P*(n/l)%P); for (ll t=n/l;l&lt;=n;l=r+1,t--) r=n/t,add(t1,(ll)sum1(l,r)*(n/l)%P); return (ll)t1*t1%P;&#125; int main()&#123; ll n,l,r; int Ans=0; freopen(&quot;t.in&quot;,&quot;r&quot;,stdin); freopen(&quot;t.out&quot;,&quot;w&quot;,stdout); Pre(); scanf(&quot;%lld&quot;,&amp;n); for (l=1;l*l&lt;=n;l++) add(Ans,(ll)(Sum(l)+P-Sum(l-1))%P*F(n/l)%P); for (ll t=n/l;l&lt;=n;l=r+1,t--) r=n/t,add(Ans,(ll)(Sum(r)+P-Sum(l-1))%P*F(n/l)%P); printf(&quot;%d\n&quot;,Ans); return 0;&#125; 黑科技之BM 线性递推式，给出前几项自动可得出n项的值；前面的不用动 ，只需更改main函数中的 初值 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cassert&gt;#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define all(x) (x).begin(),(x).end()#define fi first#define se second#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;typedef long long ll;typedef pair&lt;int,int&gt; PII;const ll mod=1e9+7;ll powmod(ll a,ll b) &#123;ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125;// headint _,n;namespace linear_seq &#123; const int N=10010; ll res[N],base[N],_c[N],_md[N]; vector&lt;int&gt; Md; void mul(ll *a,ll *b,int k) &#123; rep(i,0,k+k) _c[i]=0; rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod; for (int i=k+k-1;i&gt;=k;i--) if (_c[i]) rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod; rep(i,0,k) a[i]=_c[i]; &#125; int solve(ll n,VI a,VI b) &#123; // a 系数 b 初值 b[n+1]=a[0]*b[n]+...// printf(&quot;%d\n&quot;,SZ(b)); ll ans=0,pnt=0; int k=SZ(a); assert(SZ(a)==SZ(b)); rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1; Md.clear(); rep(i,0,k) if (_md[i]!=0) Md.push_back(i); rep(i,0,k) res[i]=base[i]=0; res[0]=1; while ((1ll&lt;&lt;pnt)&lt;=n) pnt++; for (int p=pnt;p&gt;=0;p--) &#123; mul(res,res,k); if ((n&gt;&gt;p)&amp;1) &#123; for (int i=k-1;i&gt;=0;i--) res[i+1]=res[i];res[0]=0; rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod; &#125; &#125; rep(i,0,k) ans=(ans+res[i]*b[i])%mod; if (ans&lt;0) ans+=mod; return ans; &#125; VI BM(VI s) &#123; VI C(1,1),B(1,1); int L=0,m=1,b=1; rep(n,0,SZ(s)) &#123; ll d=0; rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod; if (d==0) ++m; else if (2*L&lt;=n) &#123; VI T=C; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; L=n+1-L; B=T; b=d; m=1; &#125; else &#123; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; ++m; &#125; &#125; return C; &#125; int gao(VI a,ll n) &#123; VI c=BM(a); c.erase(c.begin()); rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod; return solve(n,c,VI(a.begin(),a.begin()+SZ(c))); &#125;&#125;;int main()&#123; int T; scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; vector&lt;int&gt;v; v.push_back(3); v.push_back(9); v.push_back(20); v.push_back(46); v.push_back(106); v.push_back(244); v.push_back(560); v.push_back(1286); v.push_back(2956); v.push_back(6794); v.push_back(15610); v.push_back(35866); //VI&#123;1,2,4,7,13,24&#125; ll n; scanf(&quot;%lld&quot;,&amp;n); printf(&quot;%lld\n&quot;,linear_seq::gao(v,n-1)); &#125;&#125; 斯特林近似公式： 12345678910111213141516171819#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define PI 3.1415926 ll n,t; void solve() &#123; ll a=(ll) ((0.5 * log ( 2 * PI * n) + n * log(n) - n-0.0005) / log(10)); printf(&quot;%lld\n&quot;,a+1); //是2 不是22，上传时貌似出问题了 &#125; int main() &#123; scanf(&quot;%lld&quot;,&amp;t); while(t--)&#123; scanf(&quot;%lld&quot;,&amp;n); solve(); &#125; return 0; &#125;//n! = sqrt((2 * n * PI) * (n / e ) ^ n) 卡特兰数 1.求n对括号合法的匹配的方式 C（n,2n）-C（n+1,2n） 2.卡特兰数公式 令h(0)=1,h(1)=1，catalan数满足递推式：h(n)= h(0)h(n-1)+h(1)h(n-2) + … +h(n-1)*h(0) (n&gt;=2) 另类递推式[2]：h(n)=h(n-1)(4n-2)/(n+1); 递推关系的解为：h(n)=C(2n,n)/(n+1) (n=0,1,2,…) 递推关系的另类解为：h(n)=c(2n,n)-c(2n,n-1)(n=0,1,2,…)3.可以利用卡特兰数解决的常见问题： 一个栈(无穷大)的进栈序列为1，2，3，…，n，有多少个不同的出栈序列? 在n*n的格子中，只在下三角行走，每次横或竖走一格，有多少中走法？ 将一个凸n+2边形区域分成三角形区域的方法数？ 圆上选择2n个点,将这些点成对连接起来使得所得到的n条线段不相交的方法数？ 有2n个人排成一行进入剧场。入场费5元。其中只有n个人有一张5元钞票，另外n人只有10元钞票，剧院无其它钞票，问有多少中方法使得只要有10元的人买票，售票处就有5元的钞票找零？代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include&lt;string.h&gt;int a[105][1000];//大数运算 int b[105]; //储存对应卡特兰数有多少位 void catalan() //求卡特兰数&#123; int i, j, len, carry, temp; a[1][0] = b[1] = 1; len = 1; for(i = 2; i &lt;= 100; i++) &#123; for(j = 0; j &lt; len; j++) //乘法 a[i][j] = a[i-1][j]*(4*(i-1)+2); carry = 0; for(j = 0; j &lt; len; j++) //处理相乘结果 &#123; temp = a[i][j] + carry; a[i][j] = temp % 10; carry = temp / 10; &#125; while(carry) //进位处理 &#123; a[i][len++] = carry % 10; carry /= 10; &#125; carry = 0; for(j = len-1; j &gt;= 0; j--) //除法 &#123; temp = carry*10 + a[i][j]; a[i][j] = temp/(i+1); carry = temp%(i+1); &#125; while(!a[i][len-1]) //高位零处理 len --; b[i] = len; &#125;&#125; int main() &#123; catalan(); for(int i=1;i&lt;=100;i++) &#123; for(int j=b[i]-1;j&gt;=0;j--) &#123; printf(&quot;%d&quot;,a[i][j]); &#125; printf(&quot;\n&quot;); &#125;&#125;]]></content>
      <categories>
        <category>template</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模板整理（未完成）]]></title>
    <url>%2Ftemplate%2F%E6%A8%A1%E6%9D%BF1%2F</url>
    <content type="text"><![CDATA[DP01背包（每种物品只有一个）1234567891011//n 物品数量，v 背包容量 //size 单个物品体积，value 单个物品价值void bag01()&#123; for(int i=0;i&lt;n;i++) for(int j=v;j&gt;=size[i];j--) &#123; dp[j]=max(dp[j],dp[j-size[i]]+value[i]); &#125; cout&lt;&lt;dp[v]&lt;&lt;endl;&#125; 完全背包（每种物品有无穷多）123456789void complete()&#123; for(int i=0;i&lt;n;i++) for(int j=size[i];j&lt;=v;j++) &#123; dp[j]=max(dp[j],dp[j-size[i]]+value[i]); &#125; cout&lt;&lt;dp[v]&lt;&lt;endl;&#125; 多重背包（每种物品数量有限）1234567891011121314151617181920//n 物品数量，v 背包容量 //size 单个物品体积，value 单个物品价值，num 该物品的数量 void multiply()&#123; for(int i=0;i&lt;n;i++) &#123; int d1=1,d2=num[i]; while(d1&lt;d2) &#123; for(int j=v;j&gt;=d1*size[i];j--) &#123; dp[j]=max(dp[j],dp[j-d1*size[i]]+value[i]*d1); &#125; d2-=d1; d1*=2; &#125; for(int j=v;j&gt;=d2*size[i];j--) dp[j]=max(dp[j],dp[j-d2*size[i]]+value[i]*d2); &#125; cout&lt;&lt;dp[v]&lt;&lt;endl;&#125; LIS（最长上升子序列）123456789101112131415161718192021222324252627//这个是计算连续的上升序列 如：1，2，3,4这种void lis(int n)//n是数组元素的个数&#123; for(int i=1;i&lt;=n;i++) &#123; b[a[i]]=b[a[i]-1]+1; ans=std::max(ans,b[a[i]]); &#125;&#125; //这个计算的是递增的（不需要连续递增）如：1,3,5,7这种int a[maxn];int dp[maxn];int n;void longest()&#123; dp[0]=a[0]; int pos; int L=1; for(int i=0;i&lt;n;i++) &#123; pos=lower_bound(dp,dp+L,a[i])-dp; dp[pos]=a[i]; L=max(L,pos+1); &#125; cout&lt;&lt;L&lt;&lt;endl;&#125; LCS（最长公共子序列）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//状态转移方程：// if( s[i]==t[j] ) // dp[i+1][j+1] = dp[i][j] + 1; // else // dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1]); int dp[maxn][maxn];char a[maxn],b[maxn];int vis[maxn][maxn];//只求长度的时候可以去掉// 如果要输出公共子序列，把int改成void，并把return去掉int LCS()&#123; int len1,len2,i,j; len1=strlen(a); len2=strlen(b); memset(dp,0,sizeof(dp)); for(i=1;i&lt;=len1;i++) for(j=1;j&lt;=len2;j++) &#123; if(a[i-1]==b[j-1]) dp[i][j]=dp[i-1][j-1]+1; else if(dp[i-1][j]&gt;=dp[i][j-1]) &#123; dp[i][j]=dp[i-1][j]; vis[i][j]=1; &#125; else &#123; dp[i][j]=dp[i][j-1]; vis[i][j]=-1; &#125; &#125; return dp[len1][len2];&#125;// 这个函数可以将LCS打印出来void Print(int i, int j)//i，j分别代表a，b字符串的长度&#123; if(i==0||j==0) return; if(!vis[i][j])//如果a[i]和b[j]子母相同，输出 &#123; Print(i-1,j-1); printf(&quot;%c&quot;,a[i-1]); &#125; else if(vis[i][j]==1)//如果dp[i-1][j]&gt;dp[i][j-1] Print(i-1,j); else//如果dp[i][j-1]&gt;=dp[i-1][j] Print(i,j-1);&#125; 数论素数素数筛法1.线性筛选法——欧拉筛法欧拉筛法通过红色标记部分保证每个合数只会被它的最小质因数筛去，时间复杂度降低到O(n)。代码实现： 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXN 100000#define MAXL 1000000int prime[MAXN];_Bool check[MAXL]; int main(void)&#123; int n, count; while (~scanf(&quot;%d&quot;, &amp;n)) &#123; memset(check, 0, sizeof(check)); count = 0; for (int i = 2; i &lt;= n; i++) &#123; if (!check[i]) prime[count++] = i; for (int j = 0; j &lt; count; j++) &#123; if (i*prime[j] &gt; MAXL) break; // 过大的时候跳出 check[i*prime[j]] = 1; if ((i%prime[j]) == 0) // 如果i是一个合数，而且i % prime[j] == 0 break; &#125; &#125; for (int i = 0; i &lt; count; i++) printf(&quot;%d\n&quot;, prime[i]); &#125; return 0;&#125; 2.小应用：求n的阶乘的因子数，题目n的范围（1000）；数论的原理，n的阶乘的因子个数等于n的素因子个数的幂的乘积；代码实现： 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int k[1005]; const LL mod=1e9+7;int main()&#123; int n; cin&gt;&gt;n; for(int i=2;i&lt;=n;i++) &#123; int l=i; for(int j=2;j&lt;=l;j++) &#123; while(l%j==0) &#123; k[j]++; l/=j; &#125; &#125; if(l) k[l]++; &#125; LL sum=1; for(int i=2;i&lt;=n;i++) &#123; if(k[i]) &#123; sum*=(k[i]+1); sum=sum%mod; &#125; &#125; printf(&quot;%lld\n&quot;,sum%mod); return 0;&#125; 3.查找出小于等于MAXN的素数（生成连续素数表）123456789101112131415161718192021222324252627/* * 素数筛选，查找出小于等于MAXN的素数 * prime[0]存素数的个数 */const int MAXN = 100000;int prime[MAXN + 1];void getPrime()&#123; memset(prime, 0, sizeof(prime)); for (int i = 2; i &lt;= MAXN; i++) &#123; if (!prime[i]) &#123; prime[++prime[0]] = i; &#125; for (int j = 1; j &lt;= prime[0] &amp;&amp; prime[j] &lt;= MAXN / i; j++) &#123; prime[prime[j] * i] = 1; if (i % prime[j] == 0) &#123; break; &#125; &#125; &#125;&#125; 同时得到欧拉函数表和素数表（线性筛）123456789101112131415161718192021222324252627282930313233343536373839404142 /* * 同时得到欧拉函数和素数表 */const int MAXN = 10000000;bool check[MAXN + 10];int phi[MAXN + 10];int prime[MAXN + 10];int tot; // 素数个数void phi_and_prime_table(int N)&#123; memset(check, false, sizeof(check)); phi[1] = 1; tot = 0; for (int i = 2; i &lt;= N; i++) &#123; if (!check[i]) &#123; prime[tot++] = i; phi[i] = i - 1; &#125; for (int j = 0; j &lt; tot; j++) &#123; if (i * prime[j] &gt; N) &#123; break; &#125; check[i * prime[j]] = true; if (i % prime[j] == 0) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; else &#123; phi[i * prime[j]] = phi[i] * (prime[j] - 1); &#125; &#125; &#125; return ;&#125; GCD1234int gcd(int a,int b)&#123; return b==0?a:gcd(b,a%b);&#125; LCM1234int lcm(int a,int b)&#123; return a/gcd(a,b)*b;//如果先运算a*b，很可能超数据范围&#125; EX_GCD一般用来求解不定方程，求解线性同余方程，求解模的逆元等公式： ax+by=c; 功能：用来解二元一次方程组； 注意事项：a,b均为正数;取最小正整数解引理：存在 x , y 使得 gcd(a,b)=ax+by 1234567891011121314int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; // 无最大公约数 if(a==0&amp;&amp;b==0) return -1; if(b==0) &#123; x=1;y=0; return a; &#125; int d=exgcd(b,a%b,y,x); y-=a/b*x; return d;&#125; 例题：。设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define LL long long #define INF 0x3f3f3f3f#define PI acos(-1.0)using namespace std;LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y)&#123; if(!b) &#123; x=1; y=0; return a; &#125; LL r=exgcd(b,a%b,x,y); LL t=y; y=x-(a/b)*y; x=t; return r;&#125;int main()&#123; LL a,b,x,y,n,m,l,k1,k2;//k2就是方程的一个x的解 cin&gt;&gt;x&gt;&gt;y&gt;&gt;m&gt;&gt;n&gt;&gt;l; LL d=x-y; a=l; b=n-m; LL c=exgcd(a,b,k1,k2);//c是最大公约数 if(d%c)//方程有解的条件 printf(&quot;Impossible&quot;); else&#123; LL s=k2*d/c; LL v=a/c;//对结果取余的最小的范围 printf(&quot;%lld\n&quot;,(s%v+v)%v); &#125; return 0;&#125; 快速幂时间复杂度O(log(n)) 1234567891011int Pow(int a,int b,int c)&#123; int res=1; while(b&gt;0) &#123; if(b&amp;1) res=res*a%c; a=a*a%c; b&gt;&gt;=1; &#125; return res;&#125; 中国剩余定理（CRT）求M%A=a,M%B=b,…中的M，其中A,B,C…互质123456789101112131415161718192021222324252627282930//chu是除数，yu是余数//注意只适用于除数两两互质#define ll long longint ex_gcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123; ll d; if(b == 0) &#123; x = 1; y = 0; return a; &#125; d = ex_gcd(b, a % b, y, x); y -= a / b * x; return d;&#125;ll chinese_remainder(ll b[], ll w[], ll len) &#123; ll i, d, x, y, m, n, ret; ret = 0; n = 1; for(i=0; i &lt; len ;i++) n *= w[i]; for(i=0; i &lt; len ;i++) &#123; m = n / w[i]; d=ex_gcd(w[i], m, x, y); ret = (ret + y*m*b[i]) % n; &#125; return (n + ret%n) % n;&#125; 中国剩余定理扩展求M%A=a,M%B=b,…中的M，其中A,B,C…不互质 1234567891011121314151617181920212223242526272829ll a[maxn],b[maxn];//a是除数，b是余数ll ex_gcd(ll a,ll b,ll &amp;x,ll &amp;y) &#123; ll d; if(b==0) &#123; x=1; y=0; return a; &#125; d=ex_gcd(b,a%b,y,x); y-=a/b*x; return d;&#125;ll ex_crt(ll *a, ll *b, int n)&#123; ll M=a[1],R=b[1],x,y; for (int i=2;i&lt;=n;i++) &#123; ll d=ex_gcd(M,a[i],x,y); if((b[i]-R)%d) return -1; x=(b[i]-R)/d*x%(a[i]/d); R+=x*M; M=M/d*a[i]; R%=M; &#125; return R&gt;0?R:R+M;&#125; 求逆元EX_GCD求逆元1234567891011//要求a和m互质// ax = 1(mod m)int mod_reverse(int a,int m)&#123; int x,y; int d=exgcd(a,m,x,y); if(d==1) return (x%m+m)%m; else return -1;&#125; 简洁写法注意：这个只能求a&lt;m的情况，而且必须保证a和m互质 1234567//求 ax = 1( mod m) 的 x 值，就是逆元 (0&lt;a&lt;m)int inv(int a,int m)&#123; if(a==1) return 1; return inv(m%a,m)*(m-m/a)%m;&#125; 利用欧拉函数求逆元x和m互质（m可以不是素数）；时间复杂度O(sqrt(n)) 123456789101112131415161718192021//求欧拉函数值int eurler_phi(int n)&#123; int res = n; for(int i = 2; i * i &lt;= n; i++) &#123; if(n % i == 0) &#123; res = res / i * (i - 1); while(n % i == 0) n /= i; &#125; &#125; if(n != 1) res = res / n * (n - 1); return res;&#125;//求逆元int inv(int a,int m)&#123; return Pow(a,eurler_phi(m)-1,m);&#125; 线性时间求逆元时间复杂度O(n)12345// 逆元打表int inv[maxn];inv[1] = 1;for(int i=2;i&lt;maxn;i++) inv[i]=(mod-mod/ i)*inv[mod%i]%mod; 快速幂求逆元原理是费马小定理，要求m为素数12345// a和m互质，m为素数int inv(int a,int m)&#123; return Pow(a,m-2,m);&#125; 二分乘法（快速乘）用来解决乘法的结果远超int范围，但需要的结果有取余的乘法运算1234567891011121314151617ll qmul(ll a,ll b,ll m)&#123; ll ans=0; ll k=a; ll f=1;//f是用来存负号的 if(k&lt;0) &#123;f=-1;k=-k;&#125; if(b&lt;0) &#123;f*=-1;b=-b;&#125; while(b)&#123; if(b&amp;1) ans=(ans+k)%m; k=(k+k)%m; b&gt;&gt;=1; &#125; return ans*f;&#125; 欧拉函数对于正整数N,少于或等于N ([1,N]),且与N互质的正整数(包括1)的个数，记作φ(n)。欧拉函数公式：φ(N)=N(1-1/P1)(1-1/P2)…(1-1/Pn) 直接求12345678910111213141516int Eular(int n)&#123; int eu = n; for (int i = 2 ; i * i &lt;= n ; i++) &#123; if (n % i == 0) &#123; eu -= eu / i; while (n % i == 0) n /= i; &#125; &#125; if (n &gt; 1) //n本身也是个质因子 eu -= eu / n; return eu; &#125; 打表求12345678910void Eular()&#123; euler[1]=1; for(int i=2;i&lt;maxn;i++) euler[i]=i; for(int i=2;i&lt;maxn;i++) if(euler[i]==i) for(int j=i;j&lt;maxn;j+=i) euler[j]=euler[j]/i*(i-1);//先进行除法是为了防止中间数据的溢出&#125; 唯一分解定理任何大于１的自然数，都可以唯一分解成有限个质数的乘积 n=p^{a_{1}}_{1}p^{a_{2}}_{2}\ldots p^{a}_{k}=\prod ^{k}_{i=1}p^{a_{i}}_{i}这里pi均为素数，其指数ai是正整数 找到数n的所有质因子123456789101112131415161718// pri记录质因子，k记录质因子个数int pri[maxn],k;void resolve(int n)&#123; k=0; int N=n; for(int i=2;i*i&lt;=n;i++) &#123; if(N%i==0) &#123; pri[k++]=i; while(N%i==0) N/=i; &#125; &#125; if(N&gt;1) num[k++]=N;&#125; 约数个数定理计算一个数约数的个数 根据唯一分解定理： n=\prod ^{k}_{i=1}p^{a_{i}}_{i}则n的正约数个数为： f\left( n\right) =\prod ^{k}_{i=1}\left( a_{i}+1\right)如：将278000分解质因数 278000=2^{4}\times 3^{3}\times 5^{3}\times 7^{1}可以计算出278000的正约数共有 \left( 4+1\right) \times \left( 3+1\right) \times \left( 1+1\right)=40个1234567891011121314151617181920212223242526272829303132int prime[maxn],nprime; int vis[maxn]; void getprime()&#123; nprime = 0; memset(vis,0,sizeof(vis)); for(int i = 2; i &lt;= 450; i++)&#123; int t = 450/i; for(int j = 2; j &lt;=t; j++) vis[i*j] = 1; &#125; for(int i = 2; i &lt;= 450; i++)&#123; if(!vis[i]) prime[nprime++] = i; &#125; &#125; int factor_count(int n)&#123; int ans = 1,sum; int k = sqrt(n*1.0); for(int i = 0; prime[i] &lt; k; i++)&#123; if(n % prime[i] == 0)&#123; sum = 0; while(n % prime[i] == 0)&#123; sum++; n /= prime[i]; &#125; ans *= (a+1); //ans为n的约数的个数 &#125; &#125; if(n &gt; 1) ans *= 2; return ans; &#125; 约数和定理正整数n的所有正约数的和为 f(n)=(p1^0 + p1^1 + p1^2 +…+ p1^a1)(p2^0 + p2^1 + p2^2 +…+ p2^a2)…(pk^0 + pk^1 + pk^2 +…+ pk^ak) 123456789101112131415161718192021222324252627282930313233343536373839404142int prime[maxn],nprime;int vis[maxn];void getprime()&#123; nprime = 0; memset(vis,0,sizeof(vis)); for(int i = 2; i &lt;= 450; i++)&#123; int t = 450/i; for(int j = 2; j &lt;=t; j++) vis[i*j] = 1; &#125; for(int i = 2; i &lt;= 450; i++)&#123; if(!vis[i]) prime[nprime++] = i; &#125;&#125;int pow_mod(int a,int n,int MOD)&#123; int ans = 1; while(n)&#123; if(n&amp;1) ans = (ans*a)%MOD; n &gt;&gt;= 1; a = (a*a)%MOD; &#125; return ans;&#125;int factor_sum(int n)&#123; int ans = 1,sum; int k = sqrt(n*1.0); for(int i = 0; prime[i] &lt; k; i++)&#123; if(n % prime[i] == 0)&#123; sum = 0; while(n%prime[i] == 0)&#123; sum++; n /= prime[i]; &#125; ans *= (pow_mod(prime[i],sum+1,MOD)-1)/(prime[i]-1); &#125; &#125; if(n &gt; 1) ans *= ans(n*n-1)/(n-1); return ans;&#125; 元根m是正整数，a是正数，若a mod m的阶等于φ(m)，则a为模m的一个元根（φ(m)表示m的欧拉函数） 给出一个素数p，找出p最小的元根 我的理解：找到最小的数x，使得 x^{\phi \left( n\right) }\% n=11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;int p[maxn];int k;ll Pow(ll a,ll b,ll c)&#123; ll res=1; while(b) &#123; if(b&amp;1) res=res*a%c; b&gt;&gt;=1; a=a*a%c; &#125; return res;&#125;// 查找n的素因子void getp(ll n)&#123; for(int i=2;i*i&lt;=n;i++) &#123; if(n%i==0) &#123; p[k++]=i; while(n%i==0) n/=i; &#125; &#125; if(n&gt;1) p[k++]=n;&#125;int main(int argc, char const *argv[])&#123; ios::sync_with_stdio(false); ll n; cin&gt;&gt;n; k=0; // 素数的欧拉函数值为n-1 // 对欧拉值进行分解 getp(n-1); for(int i=2;i&lt;n;i++) &#123; int flag=0; for(int j=0;j&lt;k;j++) &#123; if(Pow(i,(n-1)/p[j],n)==1) &#123; flag++; break; &#125; &#125; if(!flag) &#123; cout&lt;&lt;i&lt;&lt;endl; return 0; &#125; &#125; return 0;&#125; 容斥原理（二进制状态枚举）1234567891011121314151617181920212223242526int n; for(int i=0;i&lt;(1&lt;&lt;n);i++)&#123; // 相当于枚举所有的情况 o(2^n*n) for(int j = 0; j &lt; n ;j++) &#123; printf(&quot;%d &quot;,(i&gt;&gt;j)&amp;1); &#125;&#125; /**********应用*************/// 二进制枚举计算[1,n]区间内有多少和数组a互质/不互质的数ll ans = 0; for(int i = 1; i &lt; (1 &lt;&lt; n); i++)&#123; // 相当于枚举所有的情况 o(2^n*n) int cnt = 0; ll tmp = 1; for(int j = 0; j &lt; n ;j++) &#123; // a[j] if(i &gt;&gt; j &amp; 1) &#123; cnt ++; tmp = lcm(tmp, a[j]); &#125; &#125; if(cnt &amp; 1) ans += n / tmp; else ans -= n / tmp; &#125; 与1~n中与n互质的数的平方和平方和公式： \sum ^{n}_{i=1}i^{2}=\dfrac {n\left( n+1\right) \left( 2n+1\right) }{6}把n进行质因子分解，进行容斥，结果=总和-不互质的平方和不互质平方和为： \sum ^{n}_{k=1}\left( k\ast m\right) ^{2}=m^{2}\sum ^{\dfrac {n}{m}}_{k=1}k^{2}=m^{2}\dfrac {\dfrac {n}{m}\left( \dfrac {n}{m}+1\right) \left( 2\dfrac {n}{m}+1\right) }{6}把n进行质因子分解，进行容斥，结果=总和-不互质的平方和不互质平方和为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt; #include &lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn = 1e6 + 10;LL arr[maxn];int p;LL get(LL x, LL y) &#123; LL cnt = x / y; //这里return的是推出来的公式 return ((y * y) * (cnt * (cnt + 1) * (2 * cnt + 1) / 6));&#125;void getp(LL n) &#123; //分解质因子 p = 0; for(int i = 2; i * i &lt;= n; i++) &#123; if(n % i == 0) &#123; arr[p++] = i; while(n % i == 0) n /= i; &#125; &#125; if(n &gt; 1) arr[p++] = n;&#125;int main() &#123; LL n; while(scanf(&quot;%lld&quot;, &amp;n) != EOF) &#123; if(n == 0 || n == 1) &#123; puts(&quot;0&quot;); continue; &#125; getp(n); LL sum = n * (n + 1) * (2 * n + 1) / 6; LL ans = 0; for(int i = 1; i &lt; (1 &lt;&lt; p); i++) &#123; //状压 LL res = 0, cnt = 1; for(int j = 0; j &lt; p; j++) &#123; if(i &amp; (1 &lt;&lt; j)) &#123; cnt *= arr[j]; res++; &#125; &#125; if(res &amp; 1) ans += get(n, cnt); //容斥 else ans -= get(n, cnt); &#125; printf(&quot;%lld\n&quot;, sum - ans); &#125; return 0;&#125; DLS模板杜教筛有些时候也有一些奇形怪状的函数比如 f\left( n\right) =\prod \left( p^{a_{i}}_{i}+1\right)其中pi为质数，ai&gt;0且 n=\prod p^{a_{i}}_{i}接着出题人给了一个挺大的n（一般在10^10左右）。最后要求输出这个式子的值（可能会对一个大数进行取模）杜教筛差不对就是拿来解决这类问题的它给出了一个比较通用的技巧，使得可以在O(n^(2/3))或者O(n^(3/4))的时间复杂度内求得结果例如： f\left( ij\right) =\sum ^{a}_{i=1}\sum ^{b}_{j=1}\dfrac {aj}{b}\left[ \left( a,b\right) =1\right]f(i,j)是一个积性函数，求前缀和12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include &lt;tr1/unordered_map&gt;typedef long long ll;using namespace std;using namespace std::tr1; const int P=1000000007;const int inv2=(P+1)/2;const int inv3=(P+1)/3;const int maxn=1000000; int prime[2000000],num;int miu[maxn+5];ll sumd[maxn+5],t1[maxn+5],t2[maxn+5]; int d[maxn+5]; inline void Pre()&#123; miu[1]=1; sumd[1]=1; for (int i=2;i&lt;=maxn;i++)&#123; if (!d[i]) d[i]=prime[++num]=i,sumd[i]=1+i,t1[i]=1+i,t2[i]=i,miu[i]=-1; for (int j=1;j&lt;=num &amp;&amp; (ll)i*prime[j]&lt;=maxn;j++)&#123; d[i*prime[j]]=prime[j]; int k=i*prime[j]; if (i%prime[j]==0)&#123; miu[k]=0; t2[k]=t2[i]*prime[j],t1[k]=t1[i]+t2[k],sumd[k]=sumd[i]/t1[i]*t1[k]; break; &#125; miu[i*prime[j]]=miu[i]*miu[prime[j]]; sumd[k]=sumd[i]*sumd[prime[j]],t1[k]=1+prime[j],t2[k]=prime[j]; &#125; &#125; for (int i=1;i&lt;=maxn;i++) miu[i]=((ll)i*((P+miu[i])%P)%P+miu[i-1])%P,(sumd[i]+=sumd[i-1])%=P;&#125; unordered_map&lt;ll,int&gt; S; inline void add(int &amp;x,int y)&#123; x+=y; if (x&gt;=P) x-=P;&#125; inline int sum1(ll n)&#123; return (n+1)%P*(n%P)%P*inv2%P;&#125;inline int sum1(ll l,ll r)&#123; return (l+r)%P*((r-l+1)%P)%P*inv2%P; &#125; inline int Sum(ll n)&#123; if (n&lt;=maxn) return miu[n]; if (S.find(n)!=S.end()) return S[n]; int tem=1; ll l,r; for (l=2;l*l&lt;=n;l++) add(tem,P-l*Sum(n/l)%P); for (ll t=n/l;l&lt;=n;l=r+1,t--) r=n/t,add(tem,P-(ll)sum1(l,r)*Sum(t)%P); return S[n]=tem;&#125;/*inline int F(ll n)&#123; int t1=0,t2=0; ll l,r; for (l=1;l*l&lt;=n;l++) add(t1,l%P*(n/l)%P),add(t2,sum1(n/l)%P); for (ll t=n/l;l&lt;=n;l=r+1,t--) r=n/t,add(t1,(ll)sum1(l,r)*(n/l)%P),add(t2,(r-l+1)%P*sum1(n/l)%P); return (ll)t1*t2%P;&#125;*/ inline int F(ll n)&#123; if (n&lt;=maxn) return (ll)sumd[n]*sumd[n]%P; int t1=0; ll l,r; for (l=1;l*l&lt;=n;l++) add(t1,l%P*(n/l)%P); for (ll t=n/l;l&lt;=n;l=r+1,t--) r=n/t,add(t1,(ll)sum1(l,r)*(n/l)%P); return (ll)t1*t1%P;&#125; int main()&#123; ll n,l,r; int Ans=0; freopen(&quot;t.in&quot;,&quot;r&quot;,stdin); freopen(&quot;t.out&quot;,&quot;w&quot;,stdout); Pre(); scanf(&quot;%lld&quot;,&amp;n); for (l=1;l*l&lt;=n;l++) add(Ans,(ll)(Sum(l)+P-Sum(l-1))%P*F(n/l)%P); for (ll t=n/l;l&lt;=n;l=r+1,t--) r=n/t,add(Ans,(ll)(Sum(r)+P-Sum(l-1))%P*F(n/l)%P); printf(&quot;%d\n&quot;,Ans); return 0;&#125; 杜教BM模板自动计算线性递推式（例如：f[x]=2f[x-1]+f[x-2]），推出前几项，压进vector就可以直接输出结果了（有些递推式也可以用矩阵快速幂来求） 例如：计算线性递推式： a\left[ i\right]=2\times a\left[ i-1\right]-a\left[ i-2\right]+3\times a\left[ i-3\right]+2\times a\left[ i-4\right]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cassert&gt;#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define all(x) (x).begin(),(x).end()#define fi first#define se second#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;typedef long long ll;typedef pair&lt;int,int&gt; PII;const ll mod=1e9+7;ll powmod(ll a,ll b) &#123;ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125;// headint _,n;namespace linear_seq &#123; const int N=10010; ll res[N],base[N],_c[N],_md[N]; vector&lt;int&gt; Md; void mul(ll *a,ll *b,int k) &#123; rep(i,0,k+k) _c[i]=0; rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod; for (int i=k+k-1;i&gt;=k;i--) if (_c[i]) rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod; rep(i,0,k) a[i]=_c[i]; &#125; int solve(ll n,VI a,VI b) &#123; // a 系数 b 初值 b[n+1]=a[0]*b[n]+...// printf(&quot;%d\n&quot;,SZ(b)); ll ans=0,pnt=0; int k=SZ(a); assert(SZ(a)==SZ(b)); rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1; Md.clear(); rep(i,0,k) if (_md[i]!=0) Md.push_back(i); rep(i,0,k) res[i]=base[i]=0; res[0]=1; while ((1ll&lt;&lt;pnt)&lt;=n) pnt++; for (int p=pnt;p&gt;=0;p--) &#123; mul(res,res,k); if ((n&gt;&gt;p)&amp;1) &#123; for (int i=k-1;i&gt;=0;i--) res[i+1]=res[i];res[0]=0; rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod; &#125; &#125; rep(i,0,k) ans=(ans+res[i]*b[i])%mod; if (ans&lt;0) ans+=mod; return ans; &#125; VI BM(VI s) &#123; VI C(1,1),B(1,1); int L=0,m=1,b=1; rep(n,0,SZ(s)) &#123; ll d=0; rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod; if (d==0) ++m; else if (2*L&lt;=n) &#123; VI T=C; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; L=n+1-L; B=T; b=d; m=1; &#125; else &#123; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; ++m; &#125; &#125; return C; &#125; int gao(VI a,ll n) &#123; VI c=BM(a); c.erase(c.begin()); rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod; return solve(n,c,VI(a.begin(),a.begin()+SZ(c))); &#125;&#125;;int main()&#123; int T; scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; vector&lt;int&gt;v; /** * 下面放入推出的前几项（项数越多结果越准确） */ v.push_back(3); v.push_back(9); v.push_back(20); v.push_back(46); v.push_back(106); v.push_back(244); v.push_back(560); v.push_back(1286); v.push_back(2956); v.push_back(6794); v.push_back(15610); v.push_back(35866); //VI&#123;1,2,4,7,13,24&#125; ll n; scanf(&quot;%lld&quot;,&amp;n); printf(&quot;%lld\n&quot;,linear_seq::gao(v,n-1)); &#125;&#125; 阶乘最后非零位1234567891011121314151617181920212223242526272829303132/* * 阶乘最后非零位 复杂度O(nlongn) * 返回改为，n以字符串方式传入 */#define MAXN 10000const int mod[20] = &#123;1, 1, 2, 6, 4, 2, 2, 4, 2, 8, 4, 4, 8, 4, 6, 8, 8, 6, 8, 2&#125;;int lastDigit(char *buf)&#123; int len = (int)strlen(buf); int a[MAXN], i, c, ret = 1; if (len == 1) &#123; return mod[buf[0] - &apos;0&apos;]; &#125; for (i = 0; i &lt; len; i++) &#123; a[i] = buf[len - 1 - i] - &apos;0&apos;; &#125; for (; len; len -= !a[len - 1]) &#123; ret = ret * mod[a[1] % 2 * 10 + a[0]] % 5; for (c = 0, i = len - 1; i &gt;= 0; i--) &#123; c = c * 10 + a[i]; a[i] = c / 5; c %= 5; &#125; &#125; return ret + ret % 2 * 5;&#125; 斯特林公式求n阶乘的近似值公式： \lim _{n\rightarrow \infty }\left( \dfrac {n}{\pi }\right) ^{n}\sqrt {\dfrac {2\pi n}{n!}}=1可以得出： n!\approx \sqrt {2\pi n}\left( \dfrac {n}{e}\right) ^{n}利用斯特林公式计算n阶乘的长度公式：(需要对len取整) len=\dfrac {\lg 2\pi n}{2}+n\lg \dfrac {n}{e}+112345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;#define pi acos(-1.0) const double E=exp(1);int main()&#123; int t; int n; cin&gt;&gt;n; long long ans=1+0.5*log10(2*pi*n)+n*log10(n/E); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 卡特兰数求n对括号合法的匹配方式 C^{n}_{2n}-C^{n+1}_{2n}卡特兰数公式令h(0)=1,h(1)=1;catalan数满足递推式：h(n)= h(0)h(n-1)+h(1)h(n-2) + … +h(n-1)h(0) (n&gt;=2)另类递推式：h(n)=h(n-1)(4n-2)/(n+1);递推关系的解为： h\left( n\right) =\dfrac {C^{n}_{2n}}{n+1} \left(n= 1,2,3\ldots \right)递推关系的另类解为： h\left( n\right) =C^{n}_{2n}-C^{n-1}_{2n} \left(n= 1,2,3\ldots \right)可以用卡特兰数解决的常见问题（1）一个栈(无穷大)的进栈序列为1，2，3，…，n，有多少个不同的出栈序列?（2）在n x n的格子中，只在下三角行走，每次横或竖走一格，有多少中走法？（3）将一个凸n+2边形区域分成三角形区域的方法数？（4）圆上选择2n个点,将这些点成对连接起来使得所得到的n条线段不相交的方法数？（5）有2n个人排成一行进入剧场。入场费5元。其中只有n个人有一张5元钞票，另外n人只有10元钞票，剧院无其它钞票，问有多少中方法使得只要有10元的人买票，售票处就有5元的钞票找零？代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include&lt;string.h&gt;int a[105][1000];//大数运算 int b[105]; //储存对应卡特兰数有多少位 void catalan() //求卡特兰数&#123; int i, j, len, carry, temp; a[1][0] = b[1] = 1; len = 1; for(i = 2; i &lt;= 100; i++) &#123; for(j = 0; j &lt; len; j++) //乘法 a[i][j] = a[i-1][j]*(4*(i-1)+2); carry = 0; for(j = 0; j &lt; len; j++) //处理相乘结果 &#123; temp = a[i][j] + carry; a[i][j] = temp % 10; carry = temp / 10; &#125; while(carry) //进位处理 &#123; a[i][len++] = carry % 10; carry /= 10; &#125; carry = 0; for(j = len-1; j &gt;= 0; j--) //除法 &#123; temp = carry*10 + a[i][j]; a[i][j] = temp/(i+1); carry = temp%(i+1); &#125; while(!a[i][len-1]) //高位零处理 len --; b[i] = len; &#125;&#125; int main() &#123; catalan(); for(int i=1;i&lt;=100;i++) &#123; for(int j=b[i]-1;j&gt;=0;j--) &#123; printf(&quot;%d&quot;,a[i][j]); &#125; printf(&quot;\n&quot;); &#125;&#125; STLset基本操作：12345678910111213141516171819s.begin() // 返回指向第一个元素的迭代器s.clear() // 清除所有元素s.count() // 返回某个值元素的个数s.empty() // 如果集合为空，返回true(真）s.end() // 返回指向最后一个元素之后的迭代器，不是最后一个元素s.equal_range() // 返回集合中与给定值相等的上下限的两个迭代器s.erase() // 删除集合中的元素s.find() // 返回一个指向被查找到元素的迭代器s.get_allocator() // 返回集合的分配器s.insert() // 在集合中插入元素s.lower_bound() // 返回指向大于（或等于）某值的第一个元素的迭代器s.key_comp() // 返回一个用于元素间值比较的函数s.max_size() // 返回集合能容纳的元素的最大限值s.rbegin() // 返回指向集合中最后一个元素的反向迭代器s.rend() // 返回指向集合中第一个元素的反向迭代器s.size() // 集合中元素的数目s.swap() // 交换两个集合变量s.upper_bound() // 返回大于某个值元素的迭代器s.value_comp() // 返回一个用于比较元素间的值的函数 最长路有一张n个点n-1条边的无向联通图,每个点编号为1~n,每条边都有一个长度小w现在在点x上她想知道从点x出发经过每个点至少一次，最少需要走多少路 输入：第一行两个整数 n,x,代表点数,和小w所处的位置第二到第n行,每行三个整数 u,v,w,表示u和v之间有一条长为w的道路 输出：一个结果表示答案 思路：所有路径长度*2减去最长路的长度12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define ll long long#define msy(a) memset(a,-1,sizeof(a))const double E=exp(1);const int maxn=1e6+10;const int mod=1e9+7;using namespace std;vector&lt;pair&lt;int, ll&gt; &gt; G[maxn];ll dis[maxn], mmax;//计算最长路，maxx是最长路void dfs(int x)&#123; int size = G[x].size(); for(int i=0; i&lt;size; ++i) &#123; int u = G[x][i].first; if(dis[u] == -1) &#123; dis[u] = G[x][i].second + dis[x]; mmax = max(mmax, dis[u]); dfs(u); &#125; &#125;&#125;int main(int argc, char const *argv[])&#123; ios::sync_with_stdio(false); msy(dis); int n, x; cin &gt;&gt; n &gt;&gt; x; int u, v; ll w, ans = 0; for(int i=1; i&lt;n; ++i) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; G[u].push_back(make_pair(v, w)); G[v].push_back(make_pair(u, w)); ans+=w; &#125; ans*=2; dis[x] = 0; dfs(x); ans -= mmax; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 分段打表题意：计算1+1/2+1/3+……+1/n ; 思路：分段打表，将每1000的和存一下，需要计算时找出对应的1000的权值，再计算后面的部分相加即可1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;cmath&gt;double a[100005]; void init()&#123; int tm = 1; a[0] = 0; for (int i = 1; i &lt;= 100002; ++i)&#123; a[i] = a[i-1];//a[i]计算的从(i-1)*1000+1到i*1000的和 for (int j = tm; j &lt;= tm+999; ++j)&#123; a[i] += 1.0/j; &#125; tm = tm+1000; &#125;&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); init(); int Case = 1; while (t--)&#123; int n; scanf(&quot;%d&quot;,&amp;n); int r = n/1000*1000;//找出他的对应1000的位置 for (int i = r+1; i &lt;= n; ++i)&#123;//计算一下剩余的值的和 tmp += 1.0/i; &#125; double tt; tt = a[n/1000]; //printf(&quot;%lf %lf\n&quot;,tt,tmp); double ans = tt+tmp; printf(&quot;Case %d: %.9lf\n&quot;,Case++,ans); &#125; return 0;&#125; SG函数结论：游戏和的SG函数等于各个游戏SG函数的Nim和应用条件：当进行游戏有多种选取方式，可以打sg表或者用dfs得到 例题：有三堆石子，每堆石子的数量为n,m,k.每次每人可以拿去的石子数量为斐波那契的项的数量，1、 这是一个二人游戏;2、 一共有3堆石子，数量分别是m, n, p个；3、 两人轮流走;4、 每走一步可以选择任意一堆石子，然后取走f个；5、 f只能是菲波那契数列中的元素（即每次只能取1，2，3，5，8…等数量）；6、 最先取光所有石子的人为胜者； 123456789101112131415161718192021222324252627282930313233//f[N]:可改变当前状态的方式，N为方式的种类，f[N]要在getSG之前先预处理//SG[]:0~n的SG函数值//S[]:为x后继状态的集合#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXN 1000 + 10#define N 20int f[N],SG[MAXN],S[MAXN];void getSG(int n)&#123; int i,j; memset(SG,0,sizeof(SG)); for(i = 1; i &lt;= n; i++)&#123; memset(S,0,sizeof(S)); for(j = 0; f[j] &lt;= i &amp;&amp; j &lt;= N; j++) S[SG[i-f[j]]] = 1; for(j = 0;;j++) if(!S[j])&#123; SG[i] = j; break; &#125; &#125;&#125;int main()&#123; int n,m,k; f[0] = f[1] = 1; for(int i = 2; i &lt;= 16; i++) f[i] = f[i-1] + f[i-2]; getSG(1000); while(scanf(&quot;%d%d%d&quot;,&amp;m,&amp;n,&amp;k),m||n||k)&#123; if(SG[n]^SG[m]^SG[k]) printf(&quot;Fibo\n&quot;); else printf(&quot;Nacci\n&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>template</category>
      </categories>
  </entry>
</search>
